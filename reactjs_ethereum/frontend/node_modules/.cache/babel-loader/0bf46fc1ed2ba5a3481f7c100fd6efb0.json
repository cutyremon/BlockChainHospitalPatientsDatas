{"ast":null,"code":"'use strict';\n\nvar crypto = require('libp2p-crypto');\n\nvar bs58 = require('bs58');\n\nexports = module.exports;\n/**\n * Generatea random sequence number.\n *\n * @returns {Buffer}\n * @private\n */\n\nexports.randomSeqno = function () {\n  return crypto.randomBytes(20);\n};\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Buffer} seqno\n * @returns {string}\n * @private\n */\n\n\nexports.msgId = function (from, seqno) {\n  return from + seqno.toString('hex');\n};\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\n\n\nexports.anyMatch = function (a, b) {\n  var bHas;\n\n  if (Array.isArray(b)) {\n    bHas = function bHas(val) {\n      return b.indexOf(val) > -1;\n    };\n  } else {\n    bHas = function bHas(val) {\n      return b.has(val);\n    };\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = a[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var val = _step.value;\n\n      if (bHas(val)) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\n\n\nexports.ensureArray = function (maybeArray) {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray];\n  }\n\n  return maybeArray;\n};\n\nexports.normalizeInRpcMessages = function (messages) {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(function (msg) {\n    var m = Object.assign({}, msg);\n\n    if (Buffer.isBuffer(msg.from)) {\n      m.from = bs58.encode(msg.from);\n    }\n\n    return m;\n  });\n};\n\nexports.normalizeOutRpcMessage = function (message) {\n  var m = Object.assign({}, message);\n\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = bs58.decode(message.from);\n  }\n\n  return m;\n};\n\nexports.normalizeOutRpcMessages = function (messages) {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(exports.normalizeOutRpcMessage);\n};","map":null,"metadata":{},"sourceType":"script"}