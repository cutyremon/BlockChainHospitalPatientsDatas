{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar pull = require('pull-stream');\n\nvar pullDefer = require('pull-defer');\n\nvar pullTraverse = require('pull-traverse');\n\nvar pullCat = require('pull-cat');\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode;\n\nvar _require2 = require('./utils'),\n    normalizePath = _require2.normalizePath;\n\nvar _require3 = require('./refs'),\n    Format = _require3.Format;\n\nmodule.exports = function (self) {\n  return function (ipfsPath) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.maxDepth === 0) {\n      return pull.empty();\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      return pull.error(new Error('Cannot set edges to true and also specify format'));\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    var paths;\n\n    try {\n      var rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n      paths = rawPaths.map(function (p) {\n        return getFullPath(self, p, options);\n      });\n    } catch (err) {\n      return pull.error(err);\n    }\n\n    return pullCat(paths.map(function (p) {\n      return refsStream(self, p, options);\n    }));\n  };\n};\n\nfunction getFullPath(ipfs, ipfsPath, options) {\n  // normalizePath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  var path = normalizePath(ipfsPath);\n  var pathComponents = path.split('/');\n  var cid = pathComponents[0];\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(\"Error resolving path '\".concat(path, \"': '\").concat(cid, \"' is not a valid CID\"));\n  }\n\n  if (options.preload !== false) {\n    ipfs._preload(cid);\n  }\n\n  return '/ipfs/' + path;\n} // Get a stream of refs at the given path\n\n\nfunction refsStream(ipfs, path, options) {\n  var deferred = pullDefer.source(); // Resolve to the target CID of the path\n\n  ipfs.resolve(path, function (err, resPath) {\n    if (err) {\n      return deferred.resolve(pull.error(err));\n    } // path is /ipfs/<cid>\n\n\n    var parts = resPath.split('/');\n    var cid = parts[2];\n    deferred.resolve(pull( // Traverse the DAG, converting it into a stream\n    objectStream(ipfs, cid, options.maxDepth, options.unique), // Root object will not have a parent\n    pull.filter(function (obj) {\n      return Boolean(obj.parent);\n    }), // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    pull.filter(function (obj) {\n      return !obj.isDuplicate;\n    }), // Format the links\n    pull.map(function (obj) {\n      return formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format);\n    }), // Clients expect refs to be in the format { ref: <ref> }\n    pull.map(function (ref) {\n      return {\n        ref: ref\n      };\n    })));\n  });\n  return deferred;\n} // Get formatted link\n\n\nfunction formatLink(srcCid, dstCid, linkName, format) {\n  var out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n} // Do a depth first search of the DAG, starting from the given root cid\n\n\nfunction objectStream(ipfs, rootCid, maxDepth, isUnique) {\n  var uniques = new Set();\n  var root = {\n    node: {\n      cid: rootCid\n    },\n    depth: 0\n  };\n\n  var traverseLevel = function traverseLevel(obj) {\n    var node = obj.node,\n        depth = obj.depth; // Check the depth\n\n    var nextLevelDepth = depth + 1;\n\n    if (nextLevelDepth > maxDepth) {\n      return pull.empty();\n    } // If unique option is enabled, check if the CID has been seen before.\n    // Note we need to do this here rather than before adding to the stream\n    // so that the unique check happens in the order that items are examined\n    // in the DAG.\n\n\n    if (isUnique) {\n      if (uniques.has(node.cid.toString())) {\n        // Mark this object as a duplicate so we can filter it out later\n        obj.isDuplicate = true;\n        return pull.empty();\n      }\n\n      uniques.add(node.cid.toString());\n    }\n\n    var deferred = pullDefer.source(); // Get this object's links\n\n    getLinks(ipfs, node.cid, function (err, links) {\n      if (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          err.message = \"Could not find object with CID: \".concat(node.cid);\n        }\n\n        return deferred.resolve(pull.error(err));\n      } // Add to the stream each link, parent and the new depth\n\n\n      var vals = links.map(function (link) {\n        return {\n          parent: node,\n          node: link,\n          depth: nextLevelDepth\n        };\n      });\n      deferred.resolve(pull.values(vals));\n    });\n    return deferred;\n  };\n\n  return pullTraverse.depthFirst(root, traverseLevel);\n} // Fetch a node from IPLD then get all its links\n\n\nfunction getLinks(ipfs, cid, callback) {\n  ipfs._ipld.get(new CID(cid)).then(function (node) {\n    var links;\n\n    if (DAGNode.isDAGNode(node)) {\n      links = node.Links.map(function (_ref) {\n        var Name = _ref.Name,\n            Hash = _ref.Hash;\n        return {\n          name: Name,\n          cid: new CID(Hash)\n        };\n      });\n    } else {\n      links = getNodeLinks(node);\n    }\n\n    callback(null, links);\n  }).catch(callback);\n} // Recursively search the node for CIDs\n\n\nfunction getNodeLinks(node) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var links = [];\n\n  var _arr = Object.entries(node);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var _arr$_i = _slicedToArray(_arr[_i], 2),\n        name = _arr$_i[0],\n        value = _arr$_i[1];\n\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      });\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'));\n    }\n  }\n\n  return links;\n}","map":null,"metadata":{},"sourceType":"script"}