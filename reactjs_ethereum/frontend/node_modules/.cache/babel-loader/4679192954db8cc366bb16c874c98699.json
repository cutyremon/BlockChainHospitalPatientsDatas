{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar debug = require('debug');\n\nvar withIs = require('class-is');\n\nvar BaseConnection =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(BaseConnection, _EventEmitter);\n\n  function BaseConnection(_ref) {\n    var _this;\n\n    var _switch = _ref._switch,\n        name = _ref.name;\n\n    _classCallCheck(this, BaseConnection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseConnection).call(this));\n    _this.switch = _switch;\n    _this.ourPeerInfo = _this.switch._peerInfo;\n    _this.log = debug(\"libp2p:conn:\".concat(name));\n    _this.log.error = debug(\"libp2p:conn:\".concat(name, \":error\"));\n    return _this;\n  }\n  /**\n   * Puts the state into its disconnecting flow\n   *\n   * @param {Error} err Will be emitted if provided\n   * @returns {void}\n   */\n\n\n  _createClass(BaseConnection, [{\n    key: \"close\",\n    value: function close(err) {\n      if (this._state._state === 'DISCONNECTING') return;\n      this.log('closing connection to %s', this.theirB58Id);\n\n      if (err && this._events.error) {\n        this.emit('error', err);\n      }\n\n      this._state('disconnect');\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (eventName === 'error' && !this._events.error) {\n        var _this$log;\n\n        (_this$log = this.log).error.apply(_this$log, args);\n      } else {\n        var _get2;\n\n        (_get2 = _get(_getPrototypeOf(BaseConnection.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n    /**\n     * Gets the current state of the connection\n     *\n     * @returns {string} The current state of the connection\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this._state._state;\n    }\n    /**\n     * Puts the state into encrypting mode\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt() {\n      this._state('encrypt');\n    }\n    /**\n     * Puts the state into privatizing mode\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"protect\",\n    value: function protect() {\n      this._state('privatize');\n    }\n    /**\n     * Puts the state into muxing mode\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"upgrade\",\n    value: function upgrade() {\n      this._state('upgrade');\n    }\n    /**\n     * Event handler for disconnected.\n     *\n     * @fires BaseConnection#close\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onDisconnected\",\n    value: function _onDisconnected() {\n      this.switch.connection.remove(this);\n      this.log('disconnected from %s', this.theirB58Id);\n      this.emit('close');\n      this.removeAllListeners();\n    }\n    /**\n     * Event handler for privatized\n     *\n     * @fires BaseConnection#private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onPrivatized\",\n    value: function _onPrivatized() {\n      this.emit('private', this.conn);\n    }\n    /**\n     * Wraps this.conn with the Switch.protector for private connections\n     *\n     * @private\n     * @fires ConnectionFSM#error\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onPrivatizing\",\n    value: function _onPrivatizing() {\n      var _this2 = this;\n\n      if (!this.switch.protector) {\n        return this._state('done');\n      }\n\n      this.conn = this.switch.protector.protect(this.conn, function (err) {\n        if (err) {\n          return _this2.close(err);\n        }\n\n        _this2.log('successfully privatized conn to %s', _this2.theirB58Id);\n\n        _this2.conn.setPeerInfo(_this2.theirPeerInfo);\n\n        _this2._state('done');\n      });\n    }\n  }]);\n\n  return BaseConnection;\n}(EventEmitter);\n\nmodule.exports = withIs(BaseConnection, {\n  className: 'BaseConnection',\n  symbolName: 'libp2p-switch/BaseConnection'\n});","map":null,"metadata":{},"sourceType":"script"}