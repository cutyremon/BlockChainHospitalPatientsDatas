{"ast":null,"code":"import _slicedToArray from \"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _wrapNativeSuper from \"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\n/**\n * Define a struct error.\n *\n * @type {StructError}\n */\nvar StructError =\n/*#__PURE__*/\nfunction (_TypeError) {\n  _inherits(StructError, _TypeError);\n\n  _createClass(StructError, null, [{\n    key: \"format\",\n    value: function format(attrs) {\n      var type = attrs.type,\n          path = attrs.path,\n          value = attrs.value;\n      var message = \"Expected a value of type `\".concat(type, \"`\").concat(path.length ? \" for `\".concat(path.join('.'), \"`\") : '', \" but received `\").concat(JSON.stringify(value), \"`.\");\n      return message;\n    }\n  }]);\n\n  function StructError(attrs) {\n    var _this;\n\n    _classCallCheck(this, StructError);\n\n    var message = StructError.format(attrs);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StructError).call(this, message));\n    var data = attrs.data,\n        path = attrs.path,\n        value = attrs.value,\n        reason = attrs.reason,\n        type = attrs.type,\n        _attrs$errors = attrs.errors,\n        errors = _attrs$errors === void 0 ? [] : _attrs$errors;\n    _this.data = data;\n    _this.path = path;\n    _this.value = value;\n    _this.reason = reason;\n    _this.type = type;\n    _this.errors = errors;\n\n    if (!errors.length) {\n      errors.push(_assertThisInitialized(_assertThisInitialized(_this)));\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    } else {\n      _this.stack = new Error().stack;\n    }\n\n    return _this;\n  }\n\n  return StructError;\n}(_wrapNativeSuper(TypeError));\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol':\n      return 'symbol';\n\n    case 'Promise':\n      return 'promise';\n    // Set, Map, WeakSet, WeakMap\n\n    case 'WeakMap':\n      return 'weakmap';\n\n    case 'WeakSet':\n      return 'weakset';\n\n    case 'Map':\n      return 'map';\n\n    case 'Set':\n      return 'set';\n    // 8-bit typed arrays\n\n    case 'Int8Array':\n      return 'int8array';\n\n    case 'Uint8Array':\n      return 'uint8array';\n\n    case 'Uint8ClampedArray':\n      return 'uint8clampedarray';\n    // 16-bit typed arrays\n\n    case 'Int16Array':\n      return 'int16array';\n\n    case 'Uint16Array':\n      return 'uint16array';\n    // 32-bit typed arrays\n\n    case 'Int32Array':\n      return 'int32array';\n\n    case 'Uint32Array':\n      return 'uint32array';\n\n    case 'Float32Array':\n      return 'float32array';\n\n    case 'Float64Array':\n      return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  } // Non-plain objects\n\n\n  type = toString.call(val);\n\n  switch (type) {\n    case '[object Object]':\n      return 'object';\n    // iterators\n\n    case '[object Map Iterator]':\n      return 'mapiterator';\n\n    case '[object Set Iterator]':\n      return 'setiterator';\n\n    case '[object String Iterator]':\n      return 'stringiterator';\n\n    case '[object Array Iterator]':\n      return 'arrayiterator';\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n\n  return false;\n}\n/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\n\nvar IS_STRUCT = '@@__STRUCT__@@';\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nvar KIND = '@@__KIND__@@';\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nfunction isStruct(value) {\n  return !!(value && value[IS_STRUCT]);\n}\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\n\nfunction resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults;\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\n\nvar Kind = function Kind(name, type, validate) {\n  _classCallCheck(this, Kind);\n\n  this.name = name;\n  this.type = type;\n  this.validate = validate;\n};\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction any(schema, defaults$$1, options) {\n  if (isStruct(schema)) {\n    return schema[KIND];\n  }\n\n  if (schema instanceof Kind) {\n    return schema;\n  }\n\n  switch (kindOf(schema)) {\n    case 'array':\n      {\n        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);\n      }\n\n    case 'function':\n      {\n        return func(schema, defaults$$1, options);\n      }\n\n    case 'object':\n      {\n        return object(schema, defaults$$1, options);\n      }\n\n    case 'string':\n      {\n        var required = true;\n        var type;\n\n        if (schema.endsWith('?')) {\n          required = false;\n          schema = schema.slice(0, -1);\n        }\n\n        if (schema.includes('|')) {\n          var scalars = schema.split(/\\s*\\|\\s*/g);\n          type = union(scalars, defaults$$1, options);\n        } else if (schema.includes('&')) {\n          var _scalars = schema.split(/\\s*&\\s*/g);\n\n          type = intersection(_scalars, defaults$$1, options);\n        } else {\n          type = scalar(schema, defaults$$1, options);\n        }\n\n        if (!required) {\n          type = optional(type, undefined, options);\n        }\n\n        return type;\n      }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(\"A schema definition must be an object, array, string or function, but you passed: \".concat(schema));\n  } else {\n    throw new Error(\"Invalid schema: \".concat(schema));\n  }\n}\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction dict(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Dict structs must be defined as an array with two elements, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var obj = scalar('object', undefined, options);\n  var keys = any(schema[0], undefined, options);\n  var values = any(schema[1], undefined, options);\n  var name = 'dict';\n  var type = \"dict<\".concat(keys.type, \",\").concat(values.type, \">\");\n\n  var validate = function validate(value) {\n    var resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n\n    var _obj$validate = obj.validate(value),\n        _obj$validate2 = _slicedToArray(_obj$validate, 1),\n        error = _obj$validate2[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var ret = {};\n    var errors = [];\n\n    var _loop = function _loop(_k) {\n      var v = value[_k];\n\n      var _keys$validate = keys.validate(_k),\n          _keys$validate2 = _slicedToArray(_keys$validate, 2),\n          e = _keys$validate2[0],\n          r = _keys$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        k = _k;\n        return \"continue\";\n      }\n\n      _k = r;\n\n      var _values$validate = values.validate(v),\n          _values$validate2 = _slicedToArray(_values$validate, 2),\n          e2 = _values$validate2[0],\n          r2 = _values$validate2[1];\n\n      if (e2) {\n        var allE2 = e2.errors || [e2];\n        allE2.forEach(function (singleE) {\n          singleE.path = [_k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        k = _k;\n        return \"continue\";\n      }\n\n      ret[_k] = r2;\n      k = _k;\n    };\n\n    for (var k in value) {\n      var _ret = _loop(k);\n\n      if (_ret === \"continue\") continue;\n    }\n\n    if (errors.length) {\n      var first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction en(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Enum structs must be defined as an array, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var name = 'enum';\n  var type = schema.map(function (s) {\n    try {\n      return JSON.stringify(s);\n    } catch (e) {\n      return String(s);\n    }\n  }).join(' | ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return schema.includes(value) ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction enums(schema, defaults$$1, options) {\n  var e = en(schema, undefined, options);\n  var l = list([e], defaults$$1, options);\n  return l;\n}\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction func(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Function structs must be defined as a function, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var name = 'function';\n  var type = '<function>';\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var data = arguments.length > 1 ? arguments[1] : undefined;\n    var result = schema(value, data);\n    var failure = {\n      path: [],\n      reason: null\n    };\n    var isValid;\n\n    switch (kindOf(result)) {\n      case 'boolean':\n        {\n          isValid = result;\n          break;\n        }\n\n      case 'string':\n        {\n          isValid = false;\n          failure.reason = result;\n          break;\n        }\n\n      case 'object':\n        {\n          isValid = false;\n          failure = _extends({}, failure, result);\n          break;\n        }\n\n      default:\n        {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\"Validator functions must return a boolean, an error reason string or an error reason object, but you passed: \".concat(schema));\n          } else {\n            throw new Error(\"Invalid result: \".concat(result));\n          }\n        }\n    }\n\n    return isValid ? [undefined, value] : [_extends({\n      type: type,\n      value: value,\n      data: value\n    }, failure)];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction instance(schema, defaults$$1, options) {\n  var name = 'instance';\n  var type = \"instance<\".concat(schema.name, \">\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return value instanceof schema ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction inter(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Interface structs must be defined as an object, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'interface';\n  var type = \"{\".concat(ks.join(), \"}\");\n\n  var validate = function validate(value) {\n    var resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n    var errors = [];\n    var ret = value;\n\n    var _loop2 = function _loop2(_key) {\n      var v = value[_key];\n      var kind = properties[_key];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[_key];\n        v = resolveDefaults(d, value);\n      }\n\n      var _kind$validate = kind.validate(v, value),\n          _kind$validate2 = _slicedToArray(_kind$validate, 2),\n          e = _kind$validate2[0],\n          r = _kind$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      if (_key in value || r !== undefined) {\n        ret[_key] = r;\n      }\n    };\n\n    for (var _key in properties) {\n      var _ret2 = _loop2(_key);\n\n      if (_ret2 === \"continue\") continue;\n    }\n\n    if (errors.length) {\n      var first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction lazy(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Lazy structs must be defined as an function that returns a schema, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var kind;\n  var struct;\n  var name = 'lazy';\n  var type = \"lazy...\";\n\n  var compile = function compile(value) {\n    struct = schema();\n    kind.name = struct.kind;\n    kind.type = struct.type;\n    kind.validate = struct.validate;\n    return kind.validate(value);\n  };\n\n  kind = new Kind(name, type, compile);\n  return kind;\n}\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction dynamic(createSchema, defaults$$1, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Dynamic structs must be defined as a function, but you passed: \".concat(createSchema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(createSchema));\n    }\n  }\n\n  var name = 'dynamic';\n  var type = 'dynamic...';\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var data = arguments.length > 1 ? arguments[1] : undefined;\n    var schema = createSchema(value, data);\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\"Dynamic structs must return a schema, but you passed: \".concat(schema));\n      } else {\n        throw new Error(\"Invalid schema: \".concat(schema));\n      }\n    }\n\n    var _schema$validate = schema.validate(value),\n        _schema$validate2 = _slicedToArray(_schema$validate, 2),\n        error = _schema$validate2[0],\n        result = _schema$validate2[1];\n\n    if (error) {\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\n\nfunction list(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"List structs must be defined as an array with a single element, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var array = scalar('array', undefined, options);\n  var element = any(schema[0], undefined, options);\n  var name = 'list';\n  var type = \"[\".concat(element.type, \"]\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _array$validate = array.validate(value),\n        _array$validate2 = _slicedToArray(_array$validate, 2),\n        error = _array$validate2[0],\n        result = _array$validate2[1];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    value = result;\n    var errors = [];\n    var ret = [];\n\n    var _loop3 = function _loop3(i) {\n      var v = value[i];\n\n      var _element$validate = element.validate(v),\n          _element$validate2 = _slicedToArray(_element$validate, 2),\n          e = _element$validate2[0],\n          r = _element$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      ret[i] = r;\n    };\n\n    for (var i = 0; i < value.length; i++) {\n      var _ret3 = _loop3(i);\n\n      if (_ret3 === \"continue\") continue;\n    }\n\n    if (errors.length) {\n      var first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction literal(schema, defaults$$1, options) {\n  var name = 'literal';\n  var type = \"literal: \".concat(JSON.stringify(schema));\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return value === schema ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction object(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Object structs must be defined as an object, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var obj = scalar('object', undefined, options);\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'object';\n  var type = \"{\".concat(ks.join(), \"}\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _obj$validate3 = obj.validate(value),\n        _obj$validate4 = _slicedToArray(_obj$validate3, 1),\n        error = _obj$validate4[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var errors = [];\n    var ret = {};\n    var valueKeys = Object.keys(value);\n    var propertiesKeys = Object.keys(properties);\n    var keys = new Set(valueKeys.concat(propertiesKeys));\n    keys.forEach(function (key) {\n      var v = value[key];\n      var kind = properties[key];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      if (!kind) {\n        var _e = {\n          data: value,\n          path: [key],\n          value: v\n        };\n        errors.push(_e);\n        return;\n      }\n\n      var _kind$validate3 = kind.validate(v, value),\n          _kind$validate4 = _slicedToArray(_kind$validate3, 2),\n          e = _kind$validate4[0],\n          r = _kind$validate4[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    });\n\n    if (errors.length) {\n      var first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction optional(schema, defaults$$1, options) {\n  return union([schema, 'undefined'], defaults$$1, options);\n}\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction partial(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Partial structs must be defined as an object, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var obj = scalar('object', undefined, options);\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'partial';\n  var type = \"{\".concat(ks.join(), \",...}\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _obj$validate5 = obj.validate(value),\n        _obj$validate6 = _slicedToArray(_obj$validate5, 1),\n        error = _obj$validate6[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var errors = [];\n    var ret = {};\n\n    var _loop4 = function _loop4(_key2) {\n      var v = value[_key2];\n      var kind = properties[_key2];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[_key2];\n        v = resolveDefaults(d, value);\n      }\n\n      var _kind$validate5 = kind.validate(v, value),\n          _kind$validate6 = _slicedToArray(_kind$validate5, 2),\n          e = _kind$validate6[0],\n          r = _kind$validate6[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_key2].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      if (_key2 in value || r !== undefined) {\n        ret[_key2] = r;\n      }\n    };\n\n    for (var _key2 in properties) {\n      var _ret4 = _loop4(_key2);\n\n      if (_ret4 === \"continue\") continue;\n    }\n\n    if (errors.length) {\n      var first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction scalar(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Scalar structs must be defined as a string, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var types = options.types;\n  var fn = types[schema];\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"No struct validator function found for type \\\"\".concat(schema, \"\\\".\"));\n    } else {\n      throw new Error(\"Invalid type: \".concat(schema));\n    }\n  }\n\n  var kind = func(fn, defaults$$1, options);\n  var name = 'scalar';\n  var type = schema;\n\n  var validate = function validate(value) {\n    var _kind$validate7 = kind.validate(value),\n        _kind$validate8 = _slicedToArray(_kind$validate7, 2),\n        error = _kind$validate8[0],\n        result = _kind$validate8[1];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\n\nfunction tuple(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Tuple structs must be defined as an array, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var kinds = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var array = scalar('array', undefined, options);\n  var name = 'tuple';\n  var type = \"[\".concat(kinds.map(function (k) {\n    return k.type;\n  }).join(), \"]\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _array$validate3 = array.validate(value),\n        _array$validate4 = _slicedToArray(_array$validate3, 1),\n        error = _array$validate4[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var ret = [];\n    var errors = [];\n    var length = Math.max(value.length, kinds.length);\n\n    var _loop5 = function _loop5(i) {\n      var kind = kinds[i];\n      var v = value[i];\n\n      if (!kind) {\n        var _e2 = {\n          data: value,\n          path: [i],\n          value: v\n        };\n        errors.push(_e2);\n        return \"continue\";\n      }\n\n      var _kind$validate9 = kind.validate(v),\n          _kind$validate10 = _slicedToArray(_kind$validate9, 2),\n          e = _kind$validate10[0],\n          r = _kind$validate10[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      ret[i] = r;\n    };\n\n    for (var i = 0; i < length; i++) {\n      var _ret5 = _loop5(i);\n\n      if (_ret5 === \"continue\") continue;\n    }\n\n    if (errors.length) {\n      var first = errors[0];\n      first.errors = errors;\n      return [first];\n    }\n\n    return [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction union(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Union structs must be defined as an array, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var kinds = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var name = 'union';\n  var type = kinds.map(function (k) {\n    return k.type;\n  }).join(' | ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var errors = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = kinds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _k2 = _step.value;\n\n        var _k2$validate = _k2.validate(value),\n            _k2$validate2 = _slicedToArray(_k2$validate, 2),\n            e = _k2$validate2[0],\n            r = _k2$validate2[1];\n\n        if (!e) {\n          return [undefined, r];\n        }\n\n        errors.push(e);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    errors[0].type = type;\n    return errors;\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction intersection(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Intersection structs must be defined as an array, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var types = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var name = 'intersection';\n  var type = types.map(function (t) {\n    return t.type;\n  }).join(' & ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var v = value;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = types[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var t = _step2.value;\n\n        var _t$validate = t.validate(v),\n            _t$validate2 = _slicedToArray(_t$validate, 2),\n            e = _t$validate2[0],\n            r = _t$validate2[1];\n\n        if (e) {\n          e.type = type;\n          return [e];\n        }\n\n        v = r;\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return [undefined, v];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\n\nvar Kinds = {\n  any: any,\n  dict: dict,\n  enum: en,\n  enums: enums,\n  function: func,\n  instance: instance,\n  interface: inter,\n  lazy: lazy,\n  list: list,\n  literal: literal,\n  object: object,\n  optional: optional,\n  partial: partial,\n  scalar: scalar,\n  tuple: tuple,\n  union: union,\n  intersection: intersection,\n  dynamic: dynamic\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nvar TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nvar Types = {\n  any: function any(value) {\n    return value !== undefined;\n  }\n};\nTYPES.forEach(function (type) {\n  Types[type] = function (value) {\n    return kindOf(value) === type;\n  };\n});\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = function (value) {\n  return kindOf(value) === 'date' && !isNaN(value);\n};\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\n\nfunction superstruct() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var types = _extends({}, Types, config.types || {});\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n\n  function struct(schema, defaults$$1) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (isStruct(schema)) {\n      schema = schema.schema;\n    }\n\n    var kind = Kinds.any(schema, defaults$$1, _extends({}, options, {\n      types: types\n    }));\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');\n        } else {\n          throw new Error('Invalid `new` keyword!');\n        }\n      }\n\n      return Struct.assert(data);\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, {\n      value: true\n    });\n    Object.defineProperty(Struct, KIND, {\n      value: kind\n    });\n    Struct.kind = kind.name;\n    Struct.type = kind.type;\n    Struct.schema = schema;\n    Struct.defaults = defaults$$1;\n    Struct.options = options;\n\n    Struct.assert = function (value) {\n      var _kind$validate11 = kind.validate(value),\n          _kind$validate12 = _slicedToArray(_kind$validate11, 2),\n          error = _kind$validate12[0],\n          result = _kind$validate12[1];\n\n      if (error) {\n        throw new StructError(error);\n      }\n\n      return result;\n    };\n\n    Struct.test = function (value) {\n      var _kind$validate13 = kind.validate(value),\n          _kind$validate14 = _slicedToArray(_kind$validate13, 1),\n          error = _kind$validate14[0];\n\n      return !error;\n    };\n\n    Struct.validate = function (value) {\n      var _kind$validate15 = kind.validate(value),\n          _kind$validate16 = _slicedToArray(_kind$validate15, 2),\n          error = _kind$validate16[0],\n          result = _kind$validate16[1];\n\n      if (error) {\n        return [new StructError(error)];\n      }\n\n      return [undefined, result];\n    };\n\n    return Struct;\n  }\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n\n  Object.keys(Kinds).forEach(function (name) {\n    var kind = Kinds[name];\n\n    struct[name] = function (schema, defaults$$1, options) {\n      var type = kind(schema, defaults$$1, _extends({}, options, {\n        types: types\n      }));\n      var s = struct(type, defaults$$1, options);\n      return s;\n    };\n  });\n  /**\n   * Return the struct factory.\n   */\n\n  return struct;\n}\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\n\nvar struct = superstruct();\nexport { struct, superstruct, isStruct, StructError };","map":null,"metadata":{},"sourceType":"module"}