{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _awaitAsyncGenerator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar log = require('debug')('ipfs:mfs:write');\n\nvar importer = require('ipfs-unixfs-importer');\n\nvar stat = require('./stat');\n\nvar mkdir = require('./mkdir');\n\nvar addLink = require('./utils/add-link');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar createLock = require('./utils/create-lock');\n\nvar toAsyncIterator = require('./utils/to-async-iterator');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar toTrail = require('./utils/to-trail');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar errCode = require('err-code');\n\nvar _require = require('./utils/constants'),\n    MAX_CHUNK_SIZE = _require.MAX_CHUNK_SIZE;\n\nvar last = require('async-iterator-last');\n\nvar defaultOptions = {\n  offset: 0,\n  // the offset in the file to begin writing\n  length: undefined,\n  // how many bytes from the incoming buffer to write\n  create: false,\n  // whether to create the file if it does not exist\n  truncate: false,\n  // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  format: 'dag-pb',\n  parents: false,\n  // whether to create intermediate directories if they do not exist\n  progress: function progress() {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n};\n\nmodule.exports = function (context) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _mfsWrite = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(path, content, options) {\n        var source, destination, parent;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                log('Hello world, writing', path, content, options);\n                options = applyDefaultOptions(options, defaultOptions);\n                log('Reading source, destination and parent');\n                _context2.next = 5;\n                return createLock().readLock(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee() {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return toAsyncIterator(content, options);\n\n                        case 2:\n                          source = _context.sent;\n                          _context.next = 5;\n                          return toMfsPath(context, path);\n\n                        case 5:\n                          destination = _context.sent;\n                          _context.next = 8;\n                          return toMfsPath(context, destination.mfsDirectory);\n\n                        case 8:\n                          parent = _context.sent;\n\n                        case 9:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                })))();\n\n              case 5:\n                log('Read source, destination and parent');\n\n                if (!(!options.parents && !parent.exists)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST');\n\n              case 8:\n                if (!(!options.create && !destination.exists)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST');\n\n              case 10:\n                return _context2.abrupt(\"return\", updateOrImport(context, path, source, destination, options));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function mfsWrite(_x4, _x5, _x6) {\n        return _mfsWrite.apply(this, arguments);\n      }\n\n      return mfsWrite;\n    }()\n  );\n};\n\nvar updateOrImport =\n/*#__PURE__*/\nfunction () {\n  var _ref5 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(context, path, source, destination, options) {\n    var child;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return write(context, source, destination, options);\n\n          case 2:\n            child = _context4.sent;\n            _context4.next = 5;\n            return createLock().writeLock(\n            /*#__PURE__*/\n            _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee3() {\n              var pathComponents, fileName, parentExists, updatedPath, trail, parent, parentNode, result, newRootCid;\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      pathComponents = toPathComponents(path);\n                      fileName = pathComponents.pop();\n                      parentExists = false;\n                      _context3.prev = 3;\n                      _context3.next = 6;\n                      return stat(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 6:\n                      parentExists = true;\n                      _context3.next = 13;\n                      break;\n\n                    case 9:\n                      _context3.prev = 9;\n                      _context3.t0 = _context3[\"catch\"](3);\n\n                      if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                        _context3.next = 13;\n                        break;\n                      }\n\n                      throw _context3.t0;\n\n                    case 13:\n                      if (parentExists) {\n                        _context3.next = 16;\n                        break;\n                      }\n\n                      _context3.next = 16;\n                      return mkdir(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 16:\n                      _context3.next = 18;\n                      return toMfsPath(context, path);\n\n                    case 18:\n                      updatedPath = _context3.sent;\n                      _context3.next = 21;\n                      return toTrail(context, updatedPath.mfsDirectory, options);\n\n                    case 21:\n                      trail = _context3.sent;\n                      parent = trail[trail.length - 1];\n\n                      if (parent.type.includes('directory')) {\n                        _context3.next = 25;\n                        break;\n                      }\n\n                      throw errCode(new Error(\"cannot write to \".concat(parent.name, \": Not a directory\")), 'ERR_NOT_A_DIRECTORY');\n\n                    case 25:\n                      _context3.next = 27;\n                      return context.ipld.get(parent.cid);\n\n                    case 27:\n                      parentNode = _context3.sent;\n                      _context3.next = 30;\n                      return addLink(context, {\n                        parent: parentNode,\n                        name: fileName,\n                        cid: child.cid,\n                        size: child.size,\n                        flush: options.flush,\n                        shardSplitThreshold: options.shardSplitThreshold,\n                        format: options.format,\n                        hashAlg: options.hashAlg,\n                        cidVersion: options.cidVersion\n                      });\n\n                    case 30:\n                      result = _context3.sent;\n                      parent.cid = result.cid; // update the tree with the new child\n\n                      _context3.next = 34;\n                      return updateTree(context, trail, options);\n\n                    case 34:\n                      newRootCid = _context3.sent;\n                      _context3.next = 37;\n                      return updateMfsRoot(context, newRootCid);\n\n                    case 37:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[3, 9]]);\n            })))();\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateOrImport(_x7, _x8, _x9, _x10, _x11) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar write =\n/*#__PURE__*/\nfunction () {\n  var _ref7 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee6(context, source, destination, options) {\n    var sources, content, result;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (destination.exists) {\n              log(\"Overwriting file \".concat(destination.cid, \" offset \").concat(options.offset, \" length \").concat(options.length));\n            } else {\n              log(\"Writing file offset \".concat(options.offset, \" length \").concat(options.length));\n            }\n\n            sources = []; // pad start of file if necessary\n\n            if (options.offset > 0) {\n              if (destination.unixfs && destination.unixfs.fileSize() > options.offset) {\n                log(\"Writing first \".concat(options.offset, \" bytes of original file\"));\n                sources.push(function () {\n                  return destination.content({\n                    offset: 0,\n                    length: options.offset\n                  });\n                });\n              } else {\n                log(\"Writing zeros for first \".concat(options.offset, \" bytes\"));\n                sources.push(asyncZeroes(options.offset));\n              }\n            }\n\n            sources.push(limitAsyncStreamBytes(source, options.length));\n            content = countBytesStreamed(catAsyncInterators(sources), function (bytesWritten) {\n              if (destination.unixfs && !options.truncate) {\n                // if we've done reading from the new source and we are not going\n                // to truncate the file, add the end of the existing file to the output\n                var fileSize = destination.unixfs.fileSize();\n\n                if (fileSize > bytesWritten) {\n                  log(\"Writing last \".concat(fileSize - bytesWritten, \" of \").concat(fileSize, \" bytes from original file starting at offset \").concat(bytesWritten));\n                  return destination.content({\n                    offset: bytesWritten\n                  });\n                } else {\n                  log(\"Not writing last bytes from original file\");\n                }\n              }\n\n              return _defineProperty({}, Symbol.asyncIterator, _wrapAsyncGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee5() {\n                return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5);\n              })));\n            });\n            _context6.next = 7;\n            return last(importer([{\n              content: content\n            }], context.ipld, {\n              progress: options.progress,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              strategy: options.strategy,\n              rawLeaves: options.rawLeaves,\n              reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n              leafType: options.leafType\n            }));\n\n          case 7:\n            result = _context6.sent;\n            log(\"Wrote \".concat(result.cid));\n            return _context6.abrupt(\"return\", {\n              cid: result.cid,\n              size: result.size\n            });\n\n          case 10:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function write(_x12, _x13, _x14, _x15) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar limitAsyncStreamBytes = function limitAsyncStreamBytes(stream, limit) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _limitAsyncStreamBytes2 = _wrapAsyncGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7() {\n        var emitted, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, buf;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                emitted = 0;\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context7.prev = 3;\n                _iterator = _asyncIterator(stream);\n\n              case 5:\n                _context7.next = 7;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 7:\n                _step = _context7.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context7.next = 11;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 11:\n                _value = _context7.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context7.next = 24;\n                  break;\n                }\n\n                buf = _value;\n                emitted += buf.length;\n\n                if (!(emitted > limit)) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                _context7.next = 18;\n                return buf.slice(0, limit - emitted);\n\n              case 18:\n                return _context7.abrupt(\"return\");\n\n              case 19:\n                _context7.next = 21;\n                return buf;\n\n              case 21:\n                _iteratorNormalCompletion = true;\n                _context7.next = 5;\n                break;\n\n              case 24:\n                _context7.next = 30;\n                break;\n\n              case 26:\n                _context7.prev = 26;\n                _context7.t0 = _context7[\"catch\"](3);\n                _didIteratorError = true;\n                _iteratorError = _context7.t0;\n\n              case 30:\n                _context7.prev = 30;\n                _context7.prev = 31;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context7.next = 35;\n                  break;\n                }\n\n                _context7.next = 35;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 35:\n                _context7.prev = 35;\n\n                if (!_didIteratorError) {\n                  _context7.next = 38;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 38:\n                return _context7.finish(35);\n\n              case 39:\n                return _context7.finish(30);\n\n              case 40:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[3, 26, 30, 40], [31,, 35, 39]]);\n      }));\n\n      function _limitAsyncStreamBytes() {\n        return _limitAsyncStreamBytes2.apply(this, arguments);\n      }\n\n      return _limitAsyncStreamBytes;\n    }()\n  );\n};\n\nvar asyncZeroes = function asyncZeroes(count) {\n  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_CHUNK_SIZE;\n  var buf = Buffer.alloc(chunkSize, 0);\n\n  var stream = _defineProperty({}, Symbol.asyncIterator, function () {\n    var _asyncZeroes2 = _wrapAsyncGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee8() {\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!true) {\n                _context8.next = 5;\n                break;\n              }\n\n              _context8.next = 3;\n              return buf.slice();\n\n            case 3:\n              _context8.next = 0;\n              break;\n\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n\n    function _asyncZeroes() {\n      return _asyncZeroes2.apply(this, arguments);\n    }\n\n    return _asyncZeroes;\n  }());\n\n  return limitAsyncStreamBytes(stream, count);\n};\n\nvar catAsyncInterators =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _wrapAsyncGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee9(sources) {\n    var i, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, buf;\n\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context9.next = 39;\n              break;\n            }\n\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context9.prev = 4;\n            _iterator2 = _asyncIterator(sources[i]());\n\n          case 6:\n            _context9.next = 8;\n            return _awaitAsyncGenerator(_iterator2.next());\n\n          case 8:\n            _step2 = _context9.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context9.next = 12;\n            return _awaitAsyncGenerator(_step2.value);\n\n          case 12:\n            _value2 = _context9.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context9.next = 20;\n              break;\n            }\n\n            buf = _value2;\n            _context9.next = 17;\n            return buf;\n\n          case 17:\n            _iteratorNormalCompletion2 = true;\n            _context9.next = 6;\n            break;\n\n          case 20:\n            _context9.next = 26;\n            break;\n\n          case 22:\n            _context9.prev = 22;\n            _context9.t0 = _context9[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context9.t0;\n\n          case 26:\n            _context9.prev = 26;\n            _context9.prev = 27;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context9.next = 31;\n              break;\n            }\n\n            _context9.next = 31;\n            return _awaitAsyncGenerator(_iterator2.return());\n\n          case 31:\n            _context9.prev = 31;\n\n            if (!_didIteratorError2) {\n              _context9.next = 34;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 34:\n            return _context9.finish(31);\n\n          case 35:\n            return _context9.finish(26);\n\n          case 36:\n            i++;\n            _context9.next = 1;\n            break;\n\n          case 39:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[4, 22, 26, 36], [27,, 31, 35]]);\n  }));\n\n  return function catAsyncInterators(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar countBytesStreamed =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _wrapAsyncGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee10(source, notify) {\n    var wrote, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, buf, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, _buf;\n\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            wrote = 0;\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _context10.prev = 3;\n            _iterator3 = _asyncIterator(source);\n\n          case 5:\n            _context10.next = 7;\n            return _awaitAsyncGenerator(_iterator3.next());\n\n          case 7:\n            _step3 = _context10.sent;\n            _iteratorNormalCompletion3 = _step3.done;\n            _context10.next = 11;\n            return _awaitAsyncGenerator(_step3.value);\n\n          case 11:\n            _value3 = _context10.sent;\n\n            if (_iteratorNormalCompletion3) {\n              _context10.next = 20;\n              break;\n            }\n\n            buf = _value3;\n            wrote += buf.length;\n            _context10.next = 17;\n            return buf;\n\n          case 17:\n            _iteratorNormalCompletion3 = true;\n            _context10.next = 5;\n            break;\n\n          case 20:\n            _context10.next = 26;\n            break;\n\n          case 22:\n            _context10.prev = 22;\n            _context10.t0 = _context10[\"catch\"](3);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context10.t0;\n\n          case 26:\n            _context10.prev = 26;\n            _context10.prev = 27;\n\n            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n              _context10.next = 31;\n              break;\n            }\n\n            _context10.next = 31;\n            return _awaitAsyncGenerator(_iterator3.return());\n\n          case 31:\n            _context10.prev = 31;\n\n            if (!_didIteratorError3) {\n              _context10.next = 34;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 34:\n            return _context10.finish(31);\n\n          case 35:\n            return _context10.finish(26);\n\n          case 36:\n            _iteratorNormalCompletion4 = true;\n            _didIteratorError4 = false;\n            _context10.prev = 38;\n            _iterator4 = _asyncIterator(notify(wrote));\n\n          case 40:\n            _context10.next = 42;\n            return _awaitAsyncGenerator(_iterator4.next());\n\n          case 42:\n            _step4 = _context10.sent;\n            _iteratorNormalCompletion4 = _step4.done;\n            _context10.next = 46;\n            return _awaitAsyncGenerator(_step4.value);\n\n          case 46:\n            _value4 = _context10.sent;\n\n            if (_iteratorNormalCompletion4) {\n              _context10.next = 55;\n              break;\n            }\n\n            _buf = _value4;\n            wrote += _buf.length;\n            _context10.next = 52;\n            return _buf;\n\n          case 52:\n            _iteratorNormalCompletion4 = true;\n            _context10.next = 40;\n            break;\n\n          case 55:\n            _context10.next = 61;\n            break;\n\n          case 57:\n            _context10.prev = 57;\n            _context10.t1 = _context10[\"catch\"](38);\n            _didIteratorError4 = true;\n            _iteratorError4 = _context10.t1;\n\n          case 61:\n            _context10.prev = 61;\n            _context10.prev = 62;\n\n            if (!(!_iteratorNormalCompletion4 && _iterator4.return != null)) {\n              _context10.next = 66;\n              break;\n            }\n\n            _context10.next = 66;\n            return _awaitAsyncGenerator(_iterator4.return());\n\n          case 66:\n            _context10.prev = 66;\n\n            if (!_didIteratorError4) {\n              _context10.next = 69;\n              break;\n            }\n\n            throw _iteratorError4;\n\n          case 69:\n            return _context10.finish(66);\n\n          case 70:\n            return _context10.finish(61);\n\n          case 71:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[3, 22, 26, 36], [27,, 31, 35], [38, 57, 61, 71], [62,, 66, 70]]);\n  }));\n\n  return function countBytesStreamed(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}