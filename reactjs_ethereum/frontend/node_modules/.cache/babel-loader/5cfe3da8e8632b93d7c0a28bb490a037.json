{"ast":null,"code":"'use strict';\n\nvar PeerId = require('peer-id');\n\nvar libp2pRecord = require('libp2p-record');\n\nvar waterfall = require('async/waterfall');\n\nvar each = require('async/each');\n\nvar timeout = require('async/timeout');\n\nvar PeerInfo = require('peer-info');\n\nvar errcode = require('err-code');\n\nvar utils = require('./utils');\n\nvar Message = require('./message');\n\nvar c = require('./constants');\n\nvar Query = require('./query');\n\nvar LimitedPeerList = require('./limited-peer-list');\n\nvar Record = libp2pRecord.Record;\n\nmodule.exports = function (dht) {\n  return {\n    /**\n     * Returns the routing tables closest peers, for the key of\n     * the message.\n     *\n     * @param {Message} msg\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {undefined}\n     * @private\n     */\n    _nearestPeersToQuery: function _nearestPeersToQuery(msg, callback) {\n      utils.convertBuffer(msg.key, function (err, key) {\n        if (err) {\n          return callback(err);\n        }\n\n        var ids;\n\n        try {\n          ids = dht.routingTable.closestPeers(key, dht.kBucketSize);\n        } catch (err) {\n          return callback(err);\n        }\n\n        callback(null, ids.map(function (p) {\n          if (dht.peerBook.has(p)) {\n            return dht.peerBook.get(p);\n          } else {\n            return dht.peerBook.put(new PeerInfo(p));\n          }\n        }));\n      });\n    },\n\n    /**\n     * Get the nearest peers to the given query, but iff closer\n     * than self.\n     *\n     * @param {Message} msg\n     * @param {PeerInfo} peer\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {undefined}\n     * @private\n     */\n    _betterPeersToQuery: function _betterPeersToQuery(msg, peer, callback) {\n      dht._log('betterPeersToQuery');\n\n      dht._nearestPeersToQuery(msg, function (err, closer) {\n        if (err) {\n          return callback(err);\n        }\n\n        var filtered = closer.filter(function (closer) {\n          if (dht._isSelf(closer.id)) {\n            // Should bail, not sure\n            dht._log.error('trying to return self as closer');\n\n            return false;\n          }\n\n          return !closer.id.isEqual(peer.id);\n        });\n        callback(null, filtered);\n      });\n    },\n\n    /**\n     * Try to fetch a given record by from the local datastore.\n     * Returns the record iff it is still valid, meaning\n     * - it was either authored by this node, or\n     * - it was received less than `MAX_RECORD_AGE` ago.\n     *\n     * @param {Buffer} key\n     * @param {function(Error, Record)} callback\n     * @returns {undefined}\n     *\n     *@private\n     */\n    _checkLocalDatastore: function _checkLocalDatastore(key, callback) {\n      dht._log('checkLocalDatastore: %b', key);\n\n      var dsKey = utils.bufferToKey(key); // 2. fetch value from ds\n\n      dht.datastore.has(dsKey, function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!exists) {\n          return callback();\n        }\n\n        dht.datastore.get(dsKey, function (err, res) {\n          if (err) {\n            return callback(err);\n          }\n\n          var rawRecord = res; // 4. create record from the returned bytes\n\n          var record;\n\n          try {\n            record = Record.deserialize(rawRecord);\n          } catch (err) {\n            return callback(err);\n          }\n\n          if (!record) {\n            return callback(errcode(new Error('Invalid record'), 'ERR_INVALID_RECORD'));\n          } // 5. check validity\n          // compare recvtime with maxrecordage\n\n\n          if (record.timeReceived == null || utils.now() - record.timeReceived > c.MAX_RECORD_AGE) {\n            // 6. if: record is bad delete it and return\n            return dht.datastore.delete(dsKey, callback);\n          } //    else: return good record\n\n\n          callback(null, record);\n        });\n      });\n    },\n\n    /**\n     * Add the peer to the routing table and update it in the peerbook.\n     *\n     * @param {PeerInfo} peer\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     * @private\n     */\n    _add: function _add(peer, callback) {\n      peer = dht.peerBook.put(peer);\n      dht.routingTable.add(peer.id, callback);\n    },\n\n    /**\n     * Verify a record without searching the DHT.\n     *\n     * @param {Record} record\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     * @private\n     */\n    _verifyRecordLocally: function _verifyRecordLocally(record, callback) {\n      dht._log('verifyRecordLocally');\n\n      libp2pRecord.validator.verifyRecord(dht.validators, record, callback);\n    },\n\n    /**\n     * Find close peers for a given peer\n     *\n     * @param {Buffer} key\n     * @param {PeerId} peer\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _closerPeersSingle: function _closerPeersSingle(key, peer, callback) {\n      dht._log('_closerPeersSingle %b from %s', key, peer.toB58String());\n\n      dht._findPeerSingle(peer, new PeerId(key), function (err, msg) {\n        if (err) {\n          return callback(err);\n        }\n\n        var out = msg.closerPeers.filter(function (pInfo) {\n          return !dht._isSelf(pInfo.id);\n        });\n        callback(null, out);\n      });\n    },\n\n    /**\n     * Is the given peer id our PeerId?\n     *\n     * @param {PeerId} other\n     * @returns {bool}\n     *\n     * @private\n     */\n    _isSelf: function _isSelf(other) {\n      return other && dht.peerInfo.id.id.equals(other.id);\n    },\n\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     *\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _findPeerSingle: function _findPeerSingle(peer, target, callback) {\n      dht._log('_findPeerSingle %s', peer.toB58String());\n\n      var msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n      dht.network.sendRequest(peer, msg, callback);\n    },\n\n    /**\n     * Store the given key/value pair at the peer `target`.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @param {PeerId} target\n     * @param {function(Error)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _putValueToPeer: function _putValueToPeer(key, rec, target, callback) {\n      var msg = new Message(Message.TYPES.PUT_VALUE, key, 0);\n      msg.record = rec;\n      dht.network.sendRequest(target, msg, function (err, resp) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!resp.record.value.equals(Record.deserialize(rec).value)) {\n          return callback(errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID'));\n        }\n\n        callback();\n      });\n    },\n\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @param {function(Error)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _putLocal: function _putLocal(key, rec, callback) {\n      dht.datastore.put(utils.bufferToKey(key), rec, callback);\n    },\n\n    /**\n     * Get the value to the given key.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout (default: 60000)\n     * @param {function(Error, Record)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _get: function _get(key, options, callback) {\n      dht._log('_get %b', key);\n\n      waterfall([function (cb) {\n        return dht.getMany(key, c.GET_MANY_RECORD_COUNT, options, cb);\n      }, function (vals, cb) {\n        var recs = vals.map(function (v) {\n          return v.val;\n        });\n        var i = 0;\n\n        try {\n          i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n        } catch (err) {\n          // Assume the first record if no selector available\n          if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n            return cb(err);\n          }\n        }\n\n        var best = recs[i];\n\n        dht._log('GetValue %b %s', key, best);\n\n        if (!best) {\n          return cb(errcode(new Error('best value was not found'), 'ERR_NOT_FOUND'));\n        } // Send out correction record\n\n\n        waterfall([function (cb) {\n          return utils.createPutRecord(key, best, cb);\n        }, function (fixupRec, cb) {\n          return each(vals, function (v, cb) {\n            // no need to do anything\n            if (v.val.equals(best)) {\n              return cb();\n            } // correct ourself\n\n\n            if (dht._isSelf(v.from)) {\n              return dht._putLocal(key, fixupRec, function (err) {\n                if (err) {\n                  dht._log.error('Failed error correcting self', err);\n                }\n\n                cb();\n              });\n            } // send correction\n\n\n            dht._putValueToPeer(key, fixupRec, v.from, function (err) {\n              if (err) {\n                dht._log.error('Failed error correcting entry', err);\n              }\n\n              cb();\n            });\n          }, cb);\n        }], function (err) {\n          return cb(err, err ? null : best);\n        });\n      }], callback);\n    },\n\n    /**\n     * Attempt to retrieve the value for the given key from\n     * the local datastore.\n     *\n     * @param {Buffer} key\n     * @param {function(Error, Record)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _getLocal: function _getLocal(key, callback) {\n      dht._log('getLocal %b', key);\n\n      waterfall([function (cb) {\n        return dht.datastore.get(utils.bufferToKey(key), cb);\n      }, function (raw, cb) {\n        dht._log('found %b in local datastore', key);\n\n        var rec;\n\n        try {\n          rec = Record.deserialize(raw);\n        } catch (err) {\n          return cb(err);\n        }\n\n        dht._verifyRecordLocally(rec, function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          cb(null, rec);\n        });\n      }], callback);\n    },\n\n    /**\n     * Query a particular peer for the value for the given key.\n     * It will either return the value or a list of closer peers.\n     *\n     * Note: The peerbook is updated with new addresses found for the given peer.\n     *\n     * @param {PeerId} peer\n     * @param {Buffer} key\n     * @param {function(Error, Redcord, Array<PeerInfo>)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _getValueOrPeers: function _getValueOrPeers(peer, key, callback) {\n      waterfall([function (cb) {\n        return dht._getValueSingle(peer, key, cb);\n      }, function (msg, cb) {\n        var peers = msg.closerPeers;\n        var record = msg.record;\n\n        if (record) {\n          // We have a record\n          return dht._verifyRecordOnline(record, function (err) {\n            if (err) {\n              var errMsg = 'invalid record received, discarded';\n\n              dht._log(errMsg);\n\n              return cb(errcode(new Error(errMsg), 'ERR_INVALID_RECORD'));\n            }\n\n            return cb(null, record, peers);\n          });\n        }\n\n        if (peers.length > 0) {\n          return cb(null, null, peers);\n        }\n\n        cb(errcode(new Error('Not found'), 'ERR_NOT_FOUND'));\n      }], callback);\n    },\n\n    /**\n     * Get a value via rpc call for the given parameters.\n     *\n     * @param {PeerId} peer\n     * @param {Buffer} key\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _getValueSingle: function _getValueSingle(peer, key, callback) {\n      var msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n      dht.network.sendRequest(peer, msg, callback);\n    },\n\n    /**\n     * Verify a record, fetching missing public keys from the network.\n     * Calls back with an error if the record is invalid.\n     *\n     * @param {Record} record\n     * @param {function(Error)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _verifyRecordOnline: function _verifyRecordOnline(record, callback) {\n      libp2pRecord.validator.verifyRecord(dht.validators, record, callback);\n    },\n\n    /**\n     * Get the public key directly from a node.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error, PublicKey)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _getPublicKeyFromNode: function _getPublicKeyFromNode(peer, callback) {\n      var pkKey = utils.keyForPublicKey(peer);\n      waterfall([function (cb) {\n        return dht._getValueSingle(peer, pkKey, cb);\n      }, function (msg, cb) {\n        if (!msg.record || !msg.record.value) {\n          return cb(errcode(new Error(\"Node not responding with its public key: \".concat(peer.toB58String())), 'ERR_INVALID_RECORD'));\n        }\n\n        PeerId.createFromPubKey(msg.record.value, cb);\n      }, function (recPeer, cb) {\n        // compare hashes of the pub key\n        if (!recPeer.isEqual(peer)) {\n          return cb(errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID'));\n        }\n\n        cb(null, recPeer.pubKey);\n      }], callback);\n    },\n\n    /**\n     * Search the dht for up to `n` providers of the given CID.\n     *\n     * @param {CID} key\n     * @param {number} providerTimeout - How long the query should maximally run in milliseconds.\n     * @param {number} n\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _findNProviders: function _findNProviders(key, providerTimeout, n, callback) {\n      var out = new LimitedPeerList(n);\n      dht.providers.getProviders(key, function (err, provs) {\n        if (err) {\n          return callback(err);\n        }\n\n        provs.forEach(function (id) {\n          var info;\n\n          if (dht.peerBook.has(id)) {\n            info = dht.peerBook.get(id);\n          } else {\n            info = dht.peerBook.put(new PeerInfo(id));\n          }\n\n          out.push(info);\n        }); // All done\n\n        if (out.length >= n) {\n          return callback(null, out.toArray());\n        } // need more, query the network\n\n\n        var paths = [];\n        var query = new Query(dht, key.buffer, function (pathIndex, numPaths) {\n          // This function body runs once per disjoint path\n          var pathSize = utils.pathSize(out.length - n, numPaths);\n          var pathProviders = new LimitedPeerList(pathSize);\n          paths.push(pathProviders); // Here we return the query function to use on this particular disjoint path\n\n          return function (peer, cb) {\n            waterfall([function (cb) {\n              return dht._findProvidersSingle(peer, key, cb);\n            }, function (msg, cb) {\n              var provs = msg.providerPeers;\n\n              dht._log('(%s) found %s provider entries', dht.peerInfo.id.toB58String(), provs.length);\n\n              provs.forEach(function (prov) {\n                pathProviders.push(dht.peerBook.put(prov));\n              }); // hooray we have all that we want\n\n              if (pathProviders.length >= pathSize) {\n                return cb(null, {\n                  pathComplete: true\n                });\n              } // it looks like we want some more\n\n\n              cb(null, {\n                closerPeers: msg.closerPeers\n              });\n            }], cb);\n          };\n        });\n        var peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize);\n        timeout(function (cb) {\n          return query.run(peers, cb);\n        }, providerTimeout)(function (err) {\n          query.stop(); // combine peers from each path\n\n          paths.forEach(function (path) {\n            path.toArray().forEach(function (peer) {\n              out.push(peer);\n            });\n          });\n\n          if (err) {\n            if (err.code === 'ETIMEDOUT' && out.length > 0) {\n              return callback(null, out.toArray());\n            }\n\n            return callback(err);\n          }\n\n          callback(null, out.toArray());\n        });\n      });\n    },\n\n    /**\n     * Check for providers from a single node.\n     *\n     * @param {PeerId} peer\n     * @param {CID} key\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _findProvidersSingle: function _findProvidersSingle(peer, key, callback) {\n      var msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0);\n      dht.network.sendRequest(peer, msg, callback);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}