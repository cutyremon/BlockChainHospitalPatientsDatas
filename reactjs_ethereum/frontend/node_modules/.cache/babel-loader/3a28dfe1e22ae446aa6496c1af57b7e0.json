{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar pull = require('pull-stream');\n\nvar lp = require('pull-length-prefixed');\n\nvar assert = require('assert');\n\nvar BaseProtocol = require('libp2p-pubsub');\n\nvar _require = require('libp2p-pubsub'),\n    message = _require.message,\n    utils = _require.utils;\n\nvar config = require('./config');\n\nvar multicodec = config.multicodec;\nvar ensureArray = utils.ensureArray;\n\nvar setImmediate = require('async/setImmediate');\n\nvar asyncMap = require('async/map');\n\nvar noop = function noop() {};\n/**\n * FloodSub (aka dumbsub is an implementation of pubsub focused on\n * delivering an API for Publish/Subscribe, but with no CastTree Forming\n * (it just floods the network).\n */\n\n\nvar FloodSub =\n/*#__PURE__*/\nfunction (_BaseProtocol) {\n  _inherits(FloodSub, _BaseProtocol);\n\n  /**\n   * @param {Object} libp2p\n   * @constructor\n   */\n  function FloodSub(libp2p) {\n    var _this;\n\n    _classCallCheck(this, FloodSub);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FloodSub).call(this, 'libp2p:floodsub', multicodec, libp2p));\n    /**\n     * List of our subscriptions\n     * @type {Set<string>}\n     */\n\n    _this.subscriptions = new Set();\n    return _this;\n  }\n  /**\n   * Dial a received peer.\n   * @override\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @param {function} callback\n   */\n\n\n  _createClass(FloodSub, [{\n    key: \"_onDial\",\n    value: function _onDial(peerInfo, conn, callback) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(FloodSub.prototype), \"_onDial\", this).call(this, peerInfo, conn, function (err) {\n        if (err) return callback(err);\n        var idB58Str = peerInfo.id.toB58String();\n\n        var peer = _this2.peers.get(idB58Str);\n\n        if (peer && peer.isWritable) {\n          // Immediately send my own subscriptions to the newly established conn\n          peer.sendSubscriptions(_this2.subscriptions);\n        }\n\n        setImmediate(function () {\n          return callback();\n        });\n      });\n    }\n    /**\n     * Overriding the implementation of _processConnection should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @override\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {PeerInfo} peer peer info\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"_processConnection\",\n    value: function _processConnection(idB58Str, conn, peer) {\n      var _this3 = this;\n\n      pull(conn, lp.decode(), pull.map(function (data) {\n        return message.rpc.RPC.decode(data);\n      }), pull.drain(function (rpc) {\n        return _this3._onRpc(idB58Str, rpc);\n      }, function (err) {\n        return _this3._onConnectionEnd(idB58Str, peer, err);\n      }));\n    }\n  }, {\n    key: \"_onRpc\",\n    value: function _onRpc(idB58Str, rpc) {\n      if (!rpc) {\n        return;\n      }\n\n      this.log('rpc from', idB58Str);\n      var subs = rpc.subscriptions;\n      var msgs = rpc.msgs;\n\n      if (msgs && msgs.length) {\n        this._processRpcMessages(utils.normalizeInRpcMessages(rpc.msgs));\n      }\n\n      if (subs && subs.length) {\n        var peer = this.peers.get(idB58Str);\n\n        if (peer) {\n          peer.updateSubscriptions(subs);\n          this.emit('floodsub:subscription-change', peer.info, peer.topics, subs);\n        }\n      }\n    }\n  }, {\n    key: \"_processRpcMessages\",\n    value: function _processRpcMessages(msgs) {\n      var _this4 = this;\n\n      msgs.forEach(function (msg) {\n        var seqno = utils.msgId(msg.from, msg.seqno); // 1. check if I've seen the message, if yes, ignore\n\n        if (_this4.seenCache.has(seqno)) {\n          return;\n        }\n\n        _this4.seenCache.put(seqno); // 2. emit to self\n\n\n        _this4._emitMessages(msg.topicIDs, [msg]); // 3. propagate msg to others\n\n\n        _this4._forwardMessages(msg.topicIDs, [msg]);\n      });\n    }\n  }, {\n    key: \"_emitMessages\",\n    value: function _emitMessages(topics, messages) {\n      var _this5 = this;\n\n      topics.forEach(function (topic) {\n        if (!_this5.subscriptions.has(topic)) {\n          return;\n        }\n\n        messages.forEach(function (message) {\n          _this5.emit(topic, message);\n        });\n      });\n    }\n  }, {\n    key: \"_forwardMessages\",\n    value: function _forwardMessages(topics, messages) {\n      var _this6 = this;\n\n      this.peers.forEach(function (peer) {\n        if (!peer.isWritable || !utils.anyMatch(peer.topics, topics)) {\n          return;\n        }\n\n        peer.sendMessages(utils.normalizeOutRpcMessages(messages));\n\n        _this6.log('publish msgs on topics', topics, peer.info.id.toB58String());\n      });\n    }\n    /**\n     * Unmounts the floodsub protocol and shuts down every connection\n     * @override\n     * @param {Function} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this7 = this;\n\n      _get(_getPrototypeOf(FloodSub.prototype), \"stop\", this).call(this, function (err) {\n        if (err) return callback(err);\n        _this7.subscriptions = new Set();\n        callback();\n      });\n    }\n    /**\n     * Publish messages to the given topics.\n     * @override\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(topics, messages, callback) {\n      var _this8 = this;\n\n      assert(this.started, 'FloodSub is not started');\n      callback = callback || noop;\n      this.log('publish', topics, messages);\n      topics = ensureArray(topics);\n      messages = ensureArray(messages);\n      var from = this.libp2p.peerInfo.id.toB58String();\n\n      var buildMessage = function buildMessage(msg, cb) {\n        var seqno = utils.randomSeqno();\n\n        _this8.seenCache.put(utils.msgId(from, seqno));\n\n        var message = {\n          from: from,\n          data: msg,\n          seqno: seqno,\n          topicIDs: topics // Emit to self if I'm interested\n\n        };\n\n        _this8._emitMessages(topics, [message]);\n\n        _this8._buildMessage(message, cb);\n      };\n\n      asyncMap(messages, buildMessage, function (err, msgObjects) {\n        if (err) return callback(err); // send to all the other peers\n\n        _this8._forwardMessages(topics, msgObjects);\n\n        callback(null);\n      });\n    }\n    /**\n     * Subscribe to the given topic(s).\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topics) {\n      var _this9 = this;\n\n      assert(this.started, 'FloodSub is not started');\n      topics = ensureArray(topics);\n      topics.forEach(function (topic) {\n        return _this9.subscriptions.add(topic);\n      });\n      this.peers.forEach(function (peer) {\n        return sendSubscriptionsOnceReady(peer);\n      }); // make sure that FloodSub is already mounted\n\n      function sendSubscriptionsOnceReady(peer) {\n        if (peer && peer.isWritable) {\n          return peer.sendSubscriptions(topics);\n        }\n\n        var onConnection = function onConnection() {\n          peer.removeListener('connection', onConnection);\n          sendSubscriptionsOnceReady(peer);\n        };\n\n        peer.on('connection', onConnection);\n        peer.once('close', function () {\n          return peer.removeListener('connection', onConnection);\n        });\n      }\n    }\n    /**\n     * Unsubscribe from the given topic(s).\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topics) {\n      var _this10 = this;\n\n      // Avoid race conditions, by quietly ignoring unsub when shutdown.\n      if (!this.started) {\n        return;\n      }\n\n      topics = ensureArray(topics);\n      topics.forEach(function (topic) {\n        return _this10.subscriptions.delete(topic);\n      });\n      this.peers.forEach(function (peer) {\n        return checkIfReady(peer);\n      }); // make sure that FloodSub is already mounted\n\n      function checkIfReady(peer) {\n        if (peer && peer.isWritable) {\n          peer.sendUnsubscriptions(topics);\n        } else {\n          setImmediate(checkIfReady.bind(peer));\n        }\n      }\n    }\n  }]);\n\n  return FloodSub;\n}(BaseProtocol);\n\nmodule.exports = FloodSub;","map":null,"metadata":{},"sourceType":"script"}