{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pull = require('pull-stream');\n\nvar timeout = require('async/timeout');\n\nvar lp = require('pull-length-prefixed');\n\nvar setImmediate = require('async/setImmediate');\n\nvar errcode = require('err-code');\n\nvar rpc = require('./rpc');\n\nvar c = require('./constants');\n\nvar Message = require('./message');\n\nvar utils = require('./utils');\n/**\n * Handle network operations for the dht\n */\n\n\nvar Network =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  function Network(self) {\n    _classCallCheck(this, Network);\n\n    this.dht = self;\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;\n    this._log = utils.logger(this.dht.peerInfo.id, 'net');\n    this._rpc = rpc(this.dht);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._running = false;\n  }\n  /**\n   * Start the network.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function start(callback) {\n      var cb = function cb(err) {\n        return setImmediate(function () {\n          return callback(err);\n        });\n      };\n\n      if (this._running) {\n        return cb(errcode(new Error('Network is already running'), 'ERR_NETWORK_ALREADY_RUNNING'));\n      } // TODO add a way to check if switch has started or not\n\n\n      if (!this.dht.isStarted) {\n        return cb(errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK'));\n      }\n\n      this._running = true; // handle incoming connections\n\n      this.dht.switch.handle(c.PROTOCOL_DHT, this._rpc); // handle new connections\n\n      this.dht.switch.on('peer-mux-established', this._onPeerConnected);\n      cb();\n    }\n    /**\n     * Stop all network activity.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var cb = function cb(err) {\n        return setImmediate(function () {\n          return callback(err);\n        });\n      };\n\n      if (!this.dht.isStarted && !this.isStarted) {\n        return cb(errcode(new Error('Network is already stopped'), 'ERR_NETWORK_ALREADY_STOPPED'));\n      }\n\n      this._running = false;\n      this.dht.switch.removeListener('peer-mux-established', this._onPeerConnected);\n      this.dht.switch.unhandle(c.PROTOCOL_DHT);\n      cb();\n    }\n    /**\n     * Is the network online?\n     *\n     * @type {bool}\n     */\n\n  }, {\n    key: \"_onPeerConnected\",\n\n    /**\n     * Handle new connections in the switch.\n     *\n     * @param {PeerInfo} peer\n     * @returns {void}\n     * @private\n     */\n    value: function _onPeerConnected(peer) {\n      var _this = this;\n\n      if (!this.isConnected) {\n        return this._log.error('Network is offline');\n      }\n\n      this.dht.switch.dial(peer, c.PROTOCOL_DHT, function (err, conn) {\n        if (err) {\n          return _this._log('%s does not support protocol: %s', peer.id.toB58String(), c.PROTOCOL_DHT);\n        } // TODO: conn.close()\n\n\n        pull(pull.empty(), conn);\n\n        _this.dht._add(peer, function (err) {\n          if (err) {\n            return _this._log.error('Failed to add to the routing table', err);\n          }\n\n          _this._log('added to the routing table: %s', peer.id.toB58String());\n        });\n      });\n    }\n    /**\n     * Send a request and record RTT for latency measurements.\n     *\n     * @param {PeerId} to - The peer that should receive a message\n     * @param {Message} msg - The message to send.\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"sendRequest\",\n    value: function sendRequest(to, msg, callback) {\n      var _this2 = this;\n\n      // TODO: record latency\n      if (!this.isConnected) {\n        return callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE'));\n      }\n\n      this._log('sending to: %s', to.toB58String());\n\n      this.dht.switch.dial(to, c.PROTOCOL_DHT, function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this2._writeReadMessage(conn, msg.serialize(), callback);\n      });\n    }\n    /**\n     * Sends a message without expecting an answer.\n     *\n     * @param {PeerId} to\n     * @param {Message} msg\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(to, msg, callback) {\n      var _this3 = this;\n\n      if (!this.isConnected) {\n        return setImmediate(function () {\n          return callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE'));\n        });\n      }\n\n      this._log('sending to: %s', to.toB58String());\n\n      this.dht.switch.dial(to, c.PROTOCOL_DHT, function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3._writeMessage(conn, msg.serialize(), callback);\n      });\n    }\n    /**\n     * Write a message and read its response.\n     * If no response is received after the specified timeout\n     * this will error out.\n     *\n     * @param {Connection} conn - the connection to use\n     * @param {Buffer} msg - the message to send\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_writeReadMessage\",\n    value: function _writeReadMessage(conn, msg, callback) {\n      timeout(writeReadMessage, this.readMessageTimeout)(conn, msg, callback);\n    }\n    /**\n     * Write a message to the given connection.\n     *\n     * @param {Connection} conn - the connection to use\n     * @param {Buffer} msg - the message to send\n     * @param {function(Error)} callback\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_writeMessage\",\n    value: function _writeMessage(conn, msg, callback) {\n      pull(pull.values([msg]), lp.encode(), conn, pull.onEnd(callback));\n    }\n  }, {\n    key: \"isStarted\",\n    get: function get() {\n      return this._running;\n    }\n    /**\n     * Are all network components there?\n     *\n     * @type {bool}\n     */\n\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      // TODO add a way to check if switch has started or not\n      return this.dht.isStarted && this.isStarted;\n    }\n  }]);\n\n  return Network;\n}();\n\nfunction writeReadMessage(conn, msg, callback) {\n  pull(pull.values([msg]), lp.encode(), conn, pull.filter(function (msg) {\n    return msg.length < c.maxMessageSize;\n  }), lp.decode(), pull.collect(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (res.length === 0) {\n      return callback(errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED'));\n    }\n\n    var response;\n\n    try {\n      response = Message.deserialize(res[0]);\n    } catch (err) {\n      return callback(errcode(err, 'ERR_FAILED_DESERIALIZE_RESPONSE'));\n    }\n\n    callback(null, response);\n  }));\n}\n\nmodule.exports = Network;","map":null,"metadata":{},"sourceType":"script"}