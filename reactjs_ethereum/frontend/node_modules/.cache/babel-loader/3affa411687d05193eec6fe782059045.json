{"ast":null,"code":"'use strict';\n/* eslint no-warning-comments: off */\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parallel = require('async/parallel');\n\nvar once = require('once');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:transport');\n\nvar LimitDialer = require('./limit-dialer');\n\nvar _require = require('./constants'),\n    DIAL_TIMEOUT = _require.DIAL_TIMEOUT;\n\nvar _require2 = require('./utils'),\n    uniqueBy = _require2.uniqueBy; // number of concurrent outbound dials to make per peer, same as go-libp2p-swtch\n\n\nvar defaultPerPeerRateLimit = 8;\n/**\n * Manages the transports for the switch. This simplifies dialing and listening across\n * multiple transports.\n */\n\nvar TransportManager =\n/*#__PURE__*/\nfunction () {\n  function TransportManager(_switch) {\n    _classCallCheck(this, TransportManager);\n\n    this.switch = _switch;\n    this.dialer = new LimitDialer(defaultPerPeerRateLimit, this.switch._options.dialTimeout || DIAL_TIMEOUT);\n  }\n  /**\n   * Adds a `Transport` to the list of transports on the switch, and assigns it to the given key\n   *\n   * @param {String} key\n   * @param {Transport} transport\n   * @returns {void}\n   */\n\n\n  _createClass(TransportManager, [{\n    key: \"add\",\n    value: function add(key, transport) {\n      log('adding %s', key);\n\n      if (this.switch.transports[key]) {\n        throw new Error('There is already a transport with this key');\n      }\n\n      this.switch.transports[key] = transport;\n\n      if (!this.switch.transports[key].listeners) {\n        this.switch.transports[key].listeners = [];\n      }\n    }\n    /**\n     * Closes connections for the given transport key\n     * and removes it from the switch.\n     *\n     * @param {String} key\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(key, callback) {\n      var _this = this;\n\n      callback = callback || function () {};\n\n      if (!this.switch.transports[key]) {\n        return callback();\n      }\n\n      this.close(key, function (err) {\n        delete _this.switch.transports[key];\n        callback(err);\n      });\n    }\n    /**\n     * Calls `remove` on each transport the switch has\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"removeAll\",\n    value: function removeAll(callback) {\n      var _this2 = this;\n\n      var tasks = Object.keys(this.switch.transports).map(function (key) {\n        return function (cb) {\n          _this2.remove(key, cb);\n        };\n      });\n      parallel(tasks, callback);\n    }\n    /**\n     * For a given transport `key`, dial to all that transport multiaddrs\n     *\n     * @param {String} key Key of the `Transport` to dial\n     * @param {PeerInfo} peerInfo\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(key, peerInfo, callback) {\n      var transport = this.switch.transports[key];\n      var multiaddrs = peerInfo.multiaddrs.toArray();\n\n      if (!Array.isArray(multiaddrs)) {\n        multiaddrs = [multiaddrs];\n      } // filter the multiaddrs that are actually valid for this transport\n\n\n      multiaddrs = TransportManager.dialables(transport, multiaddrs, this.switch._peerInfo);\n      log('dialing %s', key, multiaddrs.map(function (m) {\n        return m.toString();\n      })); // dial each of the multiaddrs with the given transport\n\n      this.dialer.dialMany(peerInfo.id, transport, multiaddrs, function (errors, success) {\n        if (errors) {\n          return callback(errors);\n        }\n\n        peerInfo.connect(success.multiaddr);\n        callback(null, success.conn);\n      });\n    }\n    /**\n     * For a given Transport `key`, listen on all multiaddrs in the switch's `_peerInfo`.\n     * If a `handler` is not provided, the Switch's `protocolMuxer` will be used.\n     *\n     * @param {String} key\n     * @param {*} _options Currently ignored\n     * @param {function(Connection)} handler\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(key, _options, handler, callback) {\n      var _this3 = this;\n\n      handler = this.switch._connectionHandler(key, handler);\n      var transport = this.switch.transports[key];\n\n      var originalAddrs = this.switch._peerInfo.multiaddrs.toArray(); // Until TCP can handle distinct addresses on listen, https://github.com/libp2p/interface-transport/issues/41,\n      // make sure we aren't trying to listen on duplicate ports. This also applies to websockets.\n\n\n      originalAddrs = uniqueBy(originalAddrs, function (addr) {\n        // Any non 0 port should register as unique\n        var port = Number(addr.toOptions().port);\n        return isNaN(port) || port === 0 ? addr.toString() : port;\n      });\n      var multiaddrs = TransportManager.dialables(transport, originalAddrs);\n\n      if (!transport.listeners) {\n        transport.listeners = [];\n      }\n\n      var freshMultiaddrs = [];\n      var createListeners = multiaddrs.map(function (ma) {\n        return function (cb) {\n          var done = once(cb);\n          var listener = transport.createListener(handler);\n          listener.once('error', done);\n          listener.listen(ma, function (err) {\n            if (err) {\n              return done(err);\n            }\n\n            listener.removeListener('error', done);\n            listener.getAddrs(function (err, addrs) {\n              if (err) {\n                return done(err);\n              }\n\n              freshMultiaddrs = freshMultiaddrs.concat(addrs);\n              transport.listeners.push(listener);\n              done();\n            });\n          });\n        };\n      });\n      parallel(createListeners, function (err) {\n        if (err) {\n          return callback(err);\n        } // cause we can listen on port 0 or 0.0.0.0\n\n\n        _this3.switch._peerInfo.multiaddrs.replace(multiaddrs, freshMultiaddrs);\n\n        callback();\n      });\n    }\n    /**\n     * Closes the transport with the given key, by closing all of its listeners\n     *\n     * @param {String} key\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(key, callback) {\n      var transport = this.switch.transports[key];\n\n      if (!transport) {\n        return callback(new Error(\"Trying to close non existing transport: \".concat(key)));\n      }\n\n      parallel(transport.listeners.map(function (listener) {\n        return function (cb) {\n          listener.close(cb);\n        };\n      }), callback);\n    }\n    /**\n     * For a given transport, return its multiaddrs that match the given multiaddrs\n     *\n     * @param {Transport} transport\n     * @param {Array<Multiaddr>} multiaddrs\n     * @param {PeerInfo} peerInfo Optional - a peer whose addresses should not be returned\n     * @returns {Array<Multiaddr>}\n     */\n\n  }], [{\n    key: \"dialables\",\n    value: function dialables(transport, multiaddrs, peerInfo) {\n      // If we dont have a proper transport, return no multiaddrs\n      if (!transport || !transport.filter) return [];\n      var transportAddrs = transport.filter(multiaddrs);\n\n      if (!peerInfo || !transportAddrs.length) {\n        return transportAddrs;\n      }\n\n      var ourAddrs = ourAddresses(peerInfo);\n      var result = transportAddrs.filter(function (transportAddr) {\n        // If our address is in the destination address, filter it out\n        return !ourAddrs.some(function (a) {\n          return getDestination(transportAddr).startsWith(a);\n        });\n      });\n      return result;\n    }\n  }]);\n\n  return TransportManager;\n}();\n/**\n * Expand addresses in peer info into array of addresses with and without peer\n * ID suffix.\n *\n * @param {PeerInfo} peerInfo Our peer info object\n * @returns {String[]}\n */\n\n\nfunction ourAddresses(peerInfo) {\n  var ourPeerId = peerInfo.id.toB58String();\n  return peerInfo.multiaddrs.toArray().reduce(function (ourAddrs, addr) {\n    var peerId = addr.getPeerId();\n    addr = addr.toString();\n    var otherAddr = peerId ? addr.slice(0, addr.lastIndexOf(\"/ipfs/\".concat(peerId))) : \"\".concat(addr, \"/ipfs/\").concat(ourPeerId);\n    return ourAddrs.concat([addr, otherAddr]);\n  }, []).filter(function (a) {\n    return Boolean(a);\n  }).concat(\"/ipfs/\".concat(ourPeerId));\n}\n\nvar RelayProtos = ['p2p-circuit', 'p2p-websocket-star', 'p2p-webrtc-star', 'p2p-stardust'];\n/**\n * Get the destination address of a (possibly relay) multiaddr as a string\n *\n * @param {Multiaddr} addr\n * @returns {String}\n */\n\nfunction getDestination(addr) {\n  var protos = addr.protoNames().reverse();\n  var splitProto = protos.find(function (p) {\n    return RelayProtos.includes(p);\n  });\n  addr = addr.toString();\n  if (!splitProto) return addr;\n  return addr.slice(addr.lastIndexOf(splitProto) + splitProto.length);\n}\n\nmodule.exports = TransportManager;","map":null,"metadata":{},"sourceType":"script"}