{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('libp2p-record'),\n    Record = _require2.Record;\n\nvar _require3 = require('./utils'),\n    encodeBase32 = _require3.encodeBase32;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:offline-datastore');\nlog.error = debug('ipfs:ipns:offline-datastore:error'); // Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\n\nvar OfflineDatastore =\n/*#__PURE__*/\nfunction () {\n  function OfflineDatastore(repo) {\n    _classCallCheck(this, OfflineDatastore);\n\n    this._repo = repo;\n  }\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(OfflineDatastore, [{\n    key: \"put\",\n    value: function put(key, value, callback) {\n      if (!Buffer.isBuffer(key)) {\n        var errMsg = \"Offline datastore key must be a buffer\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'));\n      }\n\n      if (!Buffer.isBuffer(value)) {\n        var _errMsg = \"Offline datastore value must be a buffer\";\n        log.error(_errMsg);\n        return callback(errcode(new Error(_errMsg), 'ERR_INVALID_VALUE'));\n      }\n\n      var routingKey;\n\n      try {\n        routingKey = this._routingKey(key);\n      } catch (err) {\n        var _errMsg2 = \"Not possible to generate the routing key\";\n        log.error(_errMsg2);\n        return callback(errcode(new Error(_errMsg2), 'ERR_GENERATING_ROUTING_KEY'));\n      } // Marshal to libp2p record as the DHT does\n\n\n      var record = new Record(key, value);\n\n      this._repo.datastore.put(routingKey, record.serialize(), callback);\n    }\n    /**\n     * Get a value from the local datastore indexed by the received key properly encoded.\n     * @param {Buffer} key identifier of the value to be obtained.\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, callback) {\n      if (!Buffer.isBuffer(key)) {\n        var errMsg = \"Offline datastore key must be a buffer\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'));\n      }\n\n      var routingKey;\n\n      try {\n        routingKey = this._routingKey(key);\n      } catch (err) {\n        var _errMsg3 = \"Not possible to generate the routing key\";\n        log.error(_errMsg3);\n        return callback(errcode(new Error(_errMsg3), 'ERR_GENERATING_ROUTING_KEY'));\n      }\n\n      this._repo.datastore.get(routingKey, function (err, res) {\n        if (err) {\n          return callback(err);\n        } // Unmarshal libp2p record as the DHT does\n\n\n        var record;\n\n        try {\n          record = Record.deserialize(res);\n        } catch (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        callback(null, record.value);\n      });\n    } // encode key properly - base32(/ipns/{cid})\n\n  }, {\n    key: \"_routingKey\",\n    value: function _routingKey(key) {\n      return new Key('/' + encodeBase32(key), false);\n    }\n  }]);\n\n  return OfflineDatastore;\n}();\n\nexports = module.exports = OfflineDatastore;","map":null,"metadata":{},"sourceType":"script"}