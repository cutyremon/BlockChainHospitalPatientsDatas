{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _require = require('superstruct'),\n    struct = _require.struct,\n    superstruct = _require.superstruct;\n\nvar optional = struct.optional,\n    list = struct.list; // Define custom types\n\nvar s = superstruct();\nvar transport = s.union([s.interface({\n  createListener: 'function',\n  dial: 'function'\n}), 'function']);\nvar modulesSchema = s({\n  connEncryption: optional(list([s('object|function')])),\n  // this is hacky to simulate optional because interface doesnt work correctly with it\n  // change to optional when fixed upstream\n  connProtector: s.union(['undefined', s.interface({\n    protect: 'function'\n  })]),\n  contentRouting: optional(list(['object'])),\n  dht: optional(s('null|function|object')),\n  peerDiscovery: optional(list([s('object|function')])),\n  peerRouting: optional(list(['object'])),\n  streamMuxer: optional(list([s('object|function')])),\n  transport: s.intersection([[transport], s.interface({\n    length: function length(v) {\n      return v > 0 ? true : 'ERROR_EMPTY';\n    }\n  })])\n});\nvar configSchema = s({\n  peerDiscovery: s('object', {\n    autoDial: true\n  }),\n  relay: s({\n    enabled: 'boolean',\n    hop: optional(s({\n      enabled: 'boolean',\n      active: 'boolean'\n    }, {\n      // HOP defaults\n      enabled: false,\n      active: false\n    }))\n  }, {\n    // Relay defaults\n    enabled: true\n  }),\n  // DHT config\n  dht: s('object?', {\n    // DHT defaults\n    enabled: false,\n    kBucketSize: 20,\n    randomWalk: {\n      enabled: false,\n      // disabled waiting for https://github.com/libp2p/js-libp2p-kad-dht/issues/86\n      queriesPerPeriod: 1,\n      interval: 300e3,\n      timeout: 10e3\n    }\n  }),\n  // Experimental config\n  EXPERIMENTAL: s({\n    pubsub: 'boolean'\n  }, {\n    // Experimental defaults\n    pubsub: false\n  })\n}, {});\nvar optionsSchema = s({\n  switch: 'object?',\n  connectionManager: s('object', {\n    minPeers: 25\n  }),\n  datastore: 'object?',\n  peerInfo: 'object',\n  peerBook: 'object?',\n  modules: modulesSchema,\n  config: configSchema\n});\n\nmodule.exports.validate = function (opts) {\n  var _optionsSchema$valida = optionsSchema.validate(opts),\n      _optionsSchema$valida2 = _slicedToArray(_optionsSchema$valida, 2),\n      error = _optionsSchema$valida2[0],\n      options = _optionsSchema$valida2[1]; // Improve errors throwed, reduce stack by throwing here and add reason to the message\n\n\n  if (error) {\n    throw new Error(\"\".concat(error.message).concat(error.reason ? ' - ' + error.reason : ''));\n  } else {\n    // Throw when dht is enabled but no dht module provided\n    if (options.config.dht.enabled) {\n      s('function|object')(options.modules.dht);\n    }\n  }\n\n  if (options.config.peerDiscovery.autoDial === undefined) {\n    options.config.peerDiscovery.autoDial = true;\n  }\n\n  return options;\n};","map":null,"metadata":{},"sourceType":"script"}