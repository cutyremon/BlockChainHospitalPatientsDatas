{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events');\n\nvar pull = require('pull-stream/pull');\n\nvar empty = require('pull-stream/sources/empty');\n\nvar asyncEach = require('async/each');\n\nvar TimeCache = require('time-cache');\n\nvar debug = require('debug');\n\nvar errcode = require('err-code');\n\nvar Peer = require('./peer');\n\nvar message = require('./message');\n\nvar _require = require('./message/sign'),\n    signMessage = _require.signMessage;\n\nvar utils = require('./utils');\n\nvar nextTick = require('async/nextTick');\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\n\n\nvar PubsubBaseProtocol =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(PubsubBaseProtocol, _EventEmitter);\n\n  /**\n   * @param {String} debugName\n   * @param {String} multicodec\n   * @param {Object} libp2p libp2p implementation\n   * @param {Object} options\n   * @param {boolean} options.signMessages if messages should be signed, defaults to true\n   * @constructor\n   */\n  function PubsubBaseProtocol(debugName, multicodec, libp2p, options) {\n    var _this;\n\n    _classCallCheck(this, PubsubBaseProtocol);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PubsubBaseProtocol).call(this));\n    options = _objectSpread({\n      signMessages: true\n    }, options);\n    _this.log = debug(debugName);\n    _this.log.err = debug(\"\".concat(debugName, \":error\"));\n    _this.multicodec = multicodec;\n    _this.libp2p = libp2p;\n    _this.started = false;\n\n    if (options.signMessages) {\n      _this.peerId = _this.libp2p.peerInfo.id;\n    }\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n\n\n    _this.topics = new Map();\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    _this.seenCache = new TimeCache();\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    _this.peers = new Map(); // Dials that are currently in progress\n\n    _this._dials = new Set();\n    _this._onConnection = _this._onConnection.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._dialPeer = _this._dialPeer.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerInfo} peer peer info\n   * @returns {PeerInfo}\n   */\n\n\n  _createClass(PubsubBaseProtocol, [{\n    key: \"_addPeer\",\n    value: function _addPeer(peer) {\n      var _this2 = this;\n\n      var id = peer.info.id.toB58String();\n      /*\n        Always use an existing peer.\n         What is happening here is: \"If the other peer has already dialed to me, we already have\n        an establish link between the two, what might be missing is a\n        Connection specifically between me and that Peer\"\n       */\n\n      var existing = this.peers.get(id);\n\n      if (!existing) {\n        this.log('new peer', id);\n        this.peers.set(id, peer);\n        existing = peer;\n        peer.once('close', function () {\n          return _this2._removePeer(peer);\n        });\n      }\n\n      ++existing._references;\n      return existing;\n    }\n    /**\n     * Remove a peer from the peers map if it has no references.\n     * @private\n     * @param {Peer} peer peer state\n     * @returns {PeerInfo}\n     */\n\n  }, {\n    key: \"_removePeer\",\n    value: function _removePeer(peer) {\n      var id = peer.info.id.toB58String();\n      this.log('remove', id, peer._references); // Only delete when no one else is referencing this peer.\n\n      if (--peer._references === 0) {\n        this.log('delete peer', id);\n        this.peers.delete(id);\n      }\n\n      return peer;\n    }\n    /**\n     * Dial a received peer.\n     * @private\n     * @param {PeerInfo} peerInfo peer info\n     * @param {function} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(peerInfo, callback) {\n      var _this3 = this;\n\n      callback = callback || function noop() {};\n\n      var idB58Str = peerInfo.id.toB58String(); // If already have a PubSub conn, ignore\n\n      var peer = this.peers.get(idB58Str);\n\n      if (peer && peer.isConnected) {\n        return nextTick(function () {\n          return callback();\n        });\n      } // If already dialing this peer, ignore\n\n\n      if (this._dials.has(idB58Str)) {\n        this.log('already dialing %s, ignoring dial attempt', idB58Str);\n        return nextTick(function () {\n          return callback();\n        });\n      }\n\n      this._dials.add(idB58Str);\n\n      this.log('dialing %s', idB58Str);\n      this.libp2p.dialProtocol(peerInfo, this.multicodec, function (err, conn) {\n        _this3.log('dial to %s complete', idB58Str); // If the dial is not in the set, it means that pubsub has been\n        // stopped\n\n\n        var pubsubStopped = !_this3._dials.has(idB58Str);\n\n        _this3._dials.delete(idB58Str);\n\n        if (err) {\n          _this3.log.err(err);\n\n          return callback();\n        } // pubsub has been stopped, so we should just bail out\n\n\n        if (pubsubStopped) {\n          _this3.log('pubsub was stopped, not processing dial to %s', idB58Str);\n\n          return callback();\n        }\n\n        _this3._onDial(peerInfo, conn, callback);\n      });\n    }\n    /**\n     * Dial a received peer.\n     * @private\n     * @param {PeerInfo} peerInfo peer info\n     * @param {Connection} conn connection to the peer\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"_onDial\",\n    value: function _onDial(peerInfo, conn, callback) {\n      var idB58Str = peerInfo.id.toB58String();\n      this.log('connected', idB58Str);\n\n      var peer = this._addPeer(new Peer(peerInfo));\n\n      peer.attachConnection(conn);\n      nextTick(function () {\n        return callback();\n      });\n    }\n    /**\n     * On successful connection event.\n     * @private\n     * @param {String} protocol connection protocol\n     * @param {Connection} conn connection to the peer\n     */\n\n  }, {\n    key: \"_onConnection\",\n    value: function _onConnection(protocol, conn) {\n      var _this4 = this;\n\n      conn.getPeerInfo(function (err, peerInfo) {\n        if (err) {\n          _this4.log.err('Failed to identify incomming conn', err);\n\n          return pull(empty(), conn);\n        }\n\n        var idB58Str = peerInfo.id.toB58String();\n\n        var peer = _this4._addPeer(new Peer(peerInfo));\n\n        _this4._processConnection(idB58Str, conn, peer);\n      });\n    }\n    /**\n     * Overriding the implementation of _processConnection should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @abstract\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {PeerInfo} peer peer info\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"_processConnection\",\n    value: function _processConnection(idB58Str, conn, peer) {\n      throw errcode('_processConnection must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * On connection end event.\n     * @private\n     * @param {string} idB58Str peer id string in base58\n     * @param {PeerInfo} peer peer info\n     * @param {Error} err error for connection end\n     */\n\n  }, {\n    key: \"_onConnectionEnd\",\n    value: function _onConnectionEnd(idB58Str, peer, err) {\n      // socket hang up, means the one side canceled\n      if (err && err.message !== 'socket hang up') {\n        this.log.err(err);\n      }\n\n      this.log('connection ended', idB58Str, err ? err.message : '');\n\n      this._removePeer(peer);\n    }\n    /**\n     * Normalizes the message and signs it, if signing is enabled\n     *\n     * @param {Message} message\n     * @param {function(Error, Message)} callback\n     */\n\n  }, {\n    key: \"_buildMessage\",\n    value: function _buildMessage(message, callback) {\n      var msg = utils.normalizeOutRpcMessage(message);\n\n      if (this.peerId) {\n        signMessage(this.peerId, msg, callback);\n      } else {\n        nextTick(callback, null, msg);\n      }\n    }\n    /**\n     * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(topics, messages, callback) {\n      throw errcode('publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topics) {\n      throw errcode('subscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topics) {\n      throw errcode('unsubscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Mounts the pubsub protocol onto the libp2p node and sends our\n     * subscriptions to every peer conneceted\n     *\n     * @param {Function} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this5 = this;\n\n      if (this.started) {\n        return nextTick(function () {\n          return callback(new Error('already started'));\n        });\n      }\n\n      this.log('starting');\n      this.libp2p.handle(this.multicodec, this._onConnection); // Speed up any new peer that comes in my way\n\n      this.libp2p.on('peer:connect', this._dialPeer); // Dial already connected peers\n\n      var peerInfos = Object.values(this.libp2p.peerBook.getAll());\n      asyncEach(peerInfos, function (peer, cb) {\n        return _this5._dialPeer(peer, cb);\n      }, function (err) {\n        nextTick(function () {\n          _this5.log('started');\n\n          _this5.started = true;\n          callback(err);\n        });\n      });\n    }\n    /**\n     * Unmounts the pubsub protocol and shuts down every connection\n     *\n     * @param {Function} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this6 = this;\n\n      if (!this.started) {\n        return nextTick(function () {\n          return callback(new Error('not started yet'));\n        });\n      }\n\n      this.libp2p.unhandle(this.multicodec);\n      this.libp2p.removeListener('peer:connect', this._dialPeer); // Prevent any dials that are in flight from being processed\n\n      this._dials = new Set();\n      this.log('stopping');\n      asyncEach(this.peers.values(), function (peer, cb) {\n        return peer.close(cb);\n      }, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this6.log('stopped');\n\n        _this6.peers = new Map();\n        _this6.started = false;\n        callback();\n      });\n    }\n  }]);\n\n  return PubsubBaseProtocol;\n}(EventEmitter);\n\nmodule.exports = PubsubBaseProtocol;\nmodule.exports.message = message;\nmodule.exports.utils = utils;","map":null,"metadata":{},"sourceType":"script"}