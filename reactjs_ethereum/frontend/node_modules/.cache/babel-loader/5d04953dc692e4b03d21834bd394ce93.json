{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar FSM = require('fsm-event');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar each = require('async/each');\n\nvar eachSeries = require('async/eachSeries');\n\nvar series = require('async/series');\n\nvar Circuit = require('libp2p-circuit');\n\nvar TransportManager = require('./transport');\n\nvar ConnectionManager = require('./connection/manager');\n\nvar getPeerInfo = require('./get-peer-info');\n\nvar getDialer = require('./dialer');\n\nvar connectionHandler = require('./connection/handler');\n\nvar ProtocolMuxer = require('./protocol-muxer');\n\nvar plaintext = require('./plaintext');\n\nvar Observer = require('./observer');\n\nvar Stats = require('./stats');\n\nvar assert = require('assert');\n\nvar Errors = require('./errors');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch');\nlog.error = debug('libp2p:switch:error');\n/**\n * @fires Switch#stop Triggered when the switch has stopped\n * @fires Switch#start Triggered when the switch has started\n * @fires Switch#error Triggered whenever an error occurs\n */\n\nvar Switch =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Switch, _EventEmitter);\n\n  function Switch(peerInfo, peerBook, options) {\n    var _this;\n\n    _classCallCheck(this, Switch);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Switch).call(this));\n    assert(peerInfo, 'You must provide a `peerInfo`');\n    assert(peerBook, 'You must provide a `peerBook`');\n    _this._peerInfo = peerInfo;\n    _this._peerBook = peerBook;\n    _this._options = options || {};\n\n    _this.setMaxListeners(Infinity); // transports --\n    // { key: transport }; e.g { tcp: <tcp> }\n\n\n    _this.transports = {}; // connections --\n    // { peerIdB58: { conn: <conn> }}\n\n    _this.conns = {}; // { protocol: handler }\n\n    _this.protocols = {}; // { muxerCodec: <muxer> } e.g { '/spdy/0.3.1': spdy }\n\n    _this.muxers = {}; // is the Identify protocol enabled?\n\n    _this.identify = false; // Crypto details\n\n    _this.crypto = plaintext;\n    _this.protector = _this._options.protector || null;\n    _this.transport = new TransportManager(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.connection = new ConnectionManager(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.observer = Observer(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.stats = Stats(_this.observer, _this._options.stats);\n    _this.protocolMuxer = ProtocolMuxer(_this.protocols, _this.observer); // All purpose connection handler for managing incoming connections\n\n    _this._connectionHandler = connectionHandler(_assertThisInitialized(_assertThisInitialized(_this))); // Setup the internal state\n\n    _this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPING' // ensures that any transports that were manually started are stopped\n\n      },\n      STARTING: {\n        done: 'STARTED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    });\n\n    _this.state.on('STARTING', function () {\n      log('The switch is starting');\n\n      _this._onStarting();\n    });\n\n    _this.state.on('STOPPING', function () {\n      log('The switch is stopping');\n\n      _this._onStopping();\n    });\n\n    _this.state.on('STARTED', function () {\n      log('The switch has started');\n\n      _this.emit('start');\n    });\n\n    _this.state.on('STOPPED', function () {\n      log('The switch has stopped');\n\n      _this.emit('stop');\n    });\n\n    _this.state.on('error', function (err) {\n      log.error(err);\n\n      _this.emit('error', err);\n    }); // higher level (public) API\n\n\n    _this.dialer = getDialer(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dial = _this.dialer.dial;\n    _this.dialFSM = _this.dialer.dialFSM;\n    return _this;\n  }\n  /**\n   * Returns a list of the transports peerInfo has addresses for\n   *\n   * @param {PeerInfo} peerInfo\n   * @returns {Array<Transport>}\n   */\n\n\n  _createClass(Switch, [{\n    key: \"availableTransports\",\n    value: function availableTransports(peerInfo) {\n      var _this2 = this;\n\n      var myAddrs = peerInfo.multiaddrs.toArray();\n      var myTransports = Object.keys(this.transports); // Only listen on transports we actually have addresses for\n\n      return myTransports.filter(function (ts) {\n        return _this2.transports[ts].filter(myAddrs).length > 0;\n      }) // push Circuit to be the last proto to be dialed, and alphabetize the others\n      .sort(function (a, b) {\n        if (a === Circuit.tag) return 1;\n        if (b === Circuit.tag) return -1;\n        return a < b ? -1 : 1;\n      });\n    }\n    /**\n     * Adds the `handlerFunc` and `matchFunc` to the Switch's protocol\n     * handler list for the given `protocol`. If the `matchFunc` returns\n     * true for a protocol check, the `handlerFunc` will be called.\n     *\n     * @param {string} protocol\n     * @param {function(string, Connection)} handlerFunc\n     * @param {function(string, string, function(Error, boolean))} matchFunc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"handle\",\n    value: function handle(protocol, handlerFunc, matchFunc) {\n      this.protocols[protocol] = {\n        handlerFunc: handlerFunc,\n        matchFunc: matchFunc\n      };\n\n      this._peerInfo.protocols.add(protocol);\n    }\n    /**\n     * Removes the given protocol from the Switch's protocol list\n     *\n     * @param {string} protocol\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocol) {\n      if (this.protocols[protocol]) {\n        delete this.protocols[protocol];\n      }\n\n      this._peerInfo.protocols.delete(protocol);\n    }\n    /**\n     * If a muxed Connection exists for the given peer, it will be closed\n     * and its reference on the Switch will be removed.\n     *\n     * @param {PeerInfo|Multiaddr|PeerId} peer\n     * @param {function()} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"hangUp\",\n    value: function hangUp(peer, callback) {\n      var peerInfo = getPeerInfo(peer, this._peerBook);\n      var key = peerInfo.id.toB58String();\n\n      var conns = _toConsumableArray(this.connection.getAllById(key));\n\n      each(conns, function (conn, cb) {\n        conn.once('close', cb);\n        conn.close();\n      }, callback);\n    }\n    /**\n     * Returns whether or not the switch has any transports\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasTransports\",\n    value: function hasTransports() {\n      var transports = Object.keys(this.transports).filter(function (t) {\n        return t !== Circuit.tag;\n      });\n      return transports && transports.length > 0;\n    }\n    /**\n     * Issues a start on the Switch state.\n     *\n     * @param {function} callback deprecated: Listening for the `error` and `start` events are recommended\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      // Add once listener for deprecated callback support\n      this.once('start', callback);\n      this.state('start');\n    }\n    /**\n     * Issues a stop on the Switch state.\n     *\n     * @param {function} callback deprecated: Listening for the `error` and `stop` events are recommended\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      // Add once listener for deprecated callback support\n      this.once('stop', callback);\n      this.state('stop');\n    }\n    /**\n     * A listener that will start any necessary services and listeners\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onStarting\",\n    value: function _onStarting() {\n      var _this3 = this;\n\n      this.stats.start();\n      eachSeries(this.availableTransports(this._peerInfo), function (ts, cb) {\n        // Listen on the given transport\n        _this3.transport.listen(ts, {}, null, cb);\n      }, function (err) {\n        if (err) {\n          log.error(err);\n\n          _this3.emit('error', err);\n\n          return _this3.state('stop');\n        }\n\n        _this3.state('done');\n      });\n    }\n    /**\n     * A listener that will turn off all running services and listeners\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onStopping\",\n    value: function _onStopping() {\n      var _this4 = this;\n\n      this.stats.stop();\n      series([function (cb) {\n        each(_this4.transports, function (transport, cb) {\n          each(transport.listeners, function (listener, cb) {\n            listener.close(function (err) {\n              if (err) log.error(err);\n              cb();\n            });\n          }, cb);\n        }, cb);\n      }, function (cb) {\n        return each(_this4.connection.getAll(), function (conn, cb) {\n          conn.once('close', cb);\n          conn.close();\n        }, cb);\n      }], function (_) {\n        _this4.state('done');\n      });\n    }\n  }]);\n\n  return Switch;\n}(EventEmitter);\n\nmodule.exports = Switch;\nmodule.exports.errors = Errors;","map":null,"metadata":{},"sourceType":"script"}