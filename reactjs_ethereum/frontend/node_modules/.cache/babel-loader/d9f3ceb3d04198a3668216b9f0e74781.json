{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar _require = require('multihashes'),\n    fromB58String = _require.fromB58String,\n    toB58String = _require.toB58String;\n\nvar PubsubDatastore = require('datastore-pubsub');\n\nvar withIs = require('class-is');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:pubsub');\nlog.error = debug('ipfs:ipns:pubsub:error'); // Pubsub datastore aims to manage the pubsub subscriptions for IPNS\n\nvar IpnsPubsubDatastore =\n/*#__PURE__*/\nfunction () {\n  function IpnsPubsubDatastore(pubsub, localDatastore, peerId) {\n    _classCallCheck(this, IpnsPubsubDatastore);\n\n    this._pubsub = pubsub;\n    this._subscriptions = {}; // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);\n  }\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(IpnsPubsubDatastore, [{\n    key: \"put\",\n    value: function put(key, value, callback) {\n      this._pubsubDs.put(key, value, callback);\n    }\n    /**\n     * Get a value from the pubsub datastore indexed by the received key properly encoded.\n     * Moreover, the identifier topic is subscribed and the pubsub datastore records will be\n     * updated once new publishes occur.\n     * @param {Buffer} key identifier of the value to be obtained.\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, callback) {\n      var _this = this;\n\n      this._pubsubDs.get(key, function (err, res) {\n        // Add topic subscribed\n        var ns = key.slice(0, ipns.namespaceLength);\n\n        if (ns.toString() === ipns.namespace) {\n          var stringifiedTopic = key.toString();\n          var id = toB58String(key.slice(ipns.namespaceLength));\n          _this._subscriptions[stringifiedTopic] = id;\n          log(\"subscribed pubsub \".concat(stringifiedTopic, \": \").concat(id));\n        } // If no data was obtained, after storing the subscription, return the error.\n\n\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, res);\n      });\n    } // Modify subscription key to have a proper encoding\n\n  }, {\n    key: \"_handleSubscriptionKey\",\n    value: function _handleSubscriptionKey(key, callback) {\n      var subscriber = this._subscriptions[key];\n\n      if (!subscriber) {\n        var errMsg = \"key \".concat(key, \" does not correspond to a subscription\");\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'));\n      }\n\n      var keys;\n\n      try {\n        keys = ipns.getIdKeys(fromB58String(subscriber));\n      } catch (err) {\n        log.error(err);\n        return callback(err);\n      }\n\n      callback(null, keys.routingKey.toBuffer());\n    }\n    /**\n     * Get pubsub subscriptions related to ipns.\n     * @param {function(Error, Object)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getSubscriptions\",\n    value: function getSubscriptions(callback) {\n      var subscriptions = Object.values(this._subscriptions).filter(Boolean);\n      return callback(null, subscriptions.map(function (sub) {\n        return \"\".concat(ipns.namespace).concat(sub);\n      }));\n    }\n    /**\n     * Cancel pubsub subscriptions related to ipns.\n     * @param {String} name ipns path to cancel the pubsub subscription.\n     * @param {function(Error, Object)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(name, callback) {\n      var _this2 = this;\n\n      if (typeof name !== 'string') {\n        var errMsg = \"received subscription name is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_SUBSCRIPTION_NAME'));\n      } // Trim /ipns/ prefix from the name\n\n\n      if (name.startsWith(ipns.namespace)) {\n        name = name.substring(ipns.namespaceLength);\n      }\n\n      var stringifiedTopic = Object.keys(this._subscriptions).find(function (key) {\n        return _this2._subscriptions[key] === name;\n      }); // Not found topic\n\n      if (!stringifiedTopic) {\n        return callback(null, {\n          canceled: false\n        });\n      } // Unsubscribe topic\n\n\n      try {\n        var bufTopic = Buffer.from(stringifiedTopic);\n\n        this._pubsubDs.unsubscribe(bufTopic);\n      } catch (err) {\n        return callback(err);\n      }\n\n      this._subscriptions[stringifiedTopic] = undefined;\n      log(\"unsubscribed pubsub \".concat(stringifiedTopic, \": \").concat(name));\n      callback(null, {\n        canceled: true\n      });\n    }\n  }]);\n\n  return IpnsPubsubDatastore;\n}();\n\nexports = module.exports = withIs(IpnsPubsubDatastore, {\n  className: 'IpnsPubsubDatastore',\n  symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore'\n});","map":null,"metadata":{},"sourceType":"script"}