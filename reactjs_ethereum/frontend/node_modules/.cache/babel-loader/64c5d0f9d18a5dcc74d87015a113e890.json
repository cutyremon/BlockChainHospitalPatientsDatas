{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar cache = require('hashlru');\n\nvar varint = require('varint');\n\nvar each = require('async/each');\n\nvar pull = require('pull-stream');\n\nvar CID = require('cids');\n\nvar PeerId = require('peer-id');\n\nvar Key = require('interface-datastore').Key;\n\nvar c = require('./constants');\n\nvar utils = require('./utils');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\n\nvar Providers =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  function Providers(datastore, self, cacheSize) {\n    _classCallCheck(this, Providers);\n\n    this.datastore = datastore;\n    this._log = utils.logger(self, 'providers');\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.provideValidity = c.PROVIDERS_VALIDITY;\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE;\n    this.providers = cache(this.lruCacheSize);\n  }\n  /**\n   * Release any resources.\n   *\n   * @returns {undefined}\n   */\n\n\n  _createClass(Providers, [{\n    key: \"stop\",\n    value: function stop() {\n      if (this._cleaner) {\n        clearInterval(this._cleaner);\n        this._cleaner = null;\n      }\n    }\n    /**\n     * Check all providers if they are still valid, and if not\n     * delete them.\n     *\n     * @returns {undefined}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var _this = this;\n\n      this._getProviderCids(function (err, cids) {\n        if (err) {\n          return _this._log.error('Failed to get cids', err);\n        }\n\n        each(cids, function (cid, cb) {\n          _this._getProvidersMap(cid, function (err, provs) {\n            if (err) {\n              return cb(err);\n            }\n\n            provs.forEach(function (time, provider) {\n              _this._log('comparing: %s - %s > %s', Date.now(), time, _this.provideValidity);\n\n              if (Date.now() - time > _this.provideValidity) {\n                provs.delete(provider);\n              }\n            });\n\n            if (provs.size === 0) {\n              return _this._deleteProvidersMap(cid, cb);\n            }\n\n            cb();\n          });\n        }, function (err) {\n          if (err) {\n            return _this._log.error('Failed to cleanup', err);\n          }\n\n          _this._log('Cleanup successfull');\n        });\n      });\n    }\n    /**\n     * Get a list of all cids that providers are known for.\n     *\n     * @param {function(Error, Array<CID>)} callback\n     * @returns {undefined}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getProviderCids\",\n    value: function _getProviderCids(callback) {\n      var _this2 = this;\n\n      pull(this.datastore.query({\n        prefix: c.PROVIDERS_KEY_PREFIX\n      }), pull.map(function (entry) {\n        var parts = entry.key.toString().split('/');\n\n        if (parts.length !== 4) {\n          _this2._log.error('incorrectly formatted provider entry in datastore: %s', entry.key);\n\n          return;\n        }\n\n        var decoded;\n\n        try {\n          decoded = utils.decodeBase32(parts[2]);\n        } catch (err) {\n          _this2._log.error('error decoding base32 provider key: %s', parts[2]);\n\n          return;\n        }\n\n        var cid;\n\n        try {\n          cid = new CID(decoded);\n        } catch (err) {\n          _this2._log.error('error converting key to cid from datastore: %s', err.message);\n        }\n\n        return cid;\n      }), pull.filter(Boolean), pull.collect(callback));\n    }\n    /**\n     * Get the currently known provider maps for a given CID.\n     *\n     * @param {CID} cid\n     * @param {function(Error, Map<PeerId, Date>)} callback\n     * @returns {undefined}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getProvidersMap\",\n    value: function _getProvidersMap(cid, callback) {\n      var provs = this.providers.get(makeProviderKey(cid));\n\n      if (!provs) {\n        return loadProviders(this.datastore, cid, callback);\n      }\n\n      callback(null, provs);\n    }\n    /**\n     * Completely remove a providers map entry for a given CID.\n     *\n     * @param {CID} cid\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_deleteProvidersMap\",\n    value: function _deleteProvidersMap(cid, callback) {\n      var dsKey = makeProviderKey(cid);\n      this.providers.set(dsKey, null);\n      var batch = this.datastore.batch();\n      pull(this.datastore.query({\n        keysOnly: true,\n        prefix: dsKey\n      }), pull.through(function (entry) {\n        return batch.delete(entry.key);\n      }), pull.onEnd(function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        batch.commit(callback);\n      }));\n    }\n  }, {\n    key: \"addProvider\",\n\n    /**\n     * Add a new provider.\n     *\n     * @param {CID} cid\n     * @param {PeerId} provider\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     */\n    value: function addProvider(cid, provider, callback) {\n      var _this3 = this;\n\n      this._log('addProvider %s', cid.toBaseEncodedString());\n\n      var dsKey = makeProviderKey(cid);\n      var provs = this.providers.get(dsKey);\n\n      var next = function next(err, provs) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3._log('loaded %s provs', provs.size);\n\n        var now = Date.now();\n        provs.set(provider, now);\n\n        _this3.providers.set(dsKey, provs);\n\n        writeProviderEntry(_this3.datastore, cid, provider, now, callback);\n      };\n\n      if (!provs) {\n        loadProviders(this.datastore, cid, next);\n      } else {\n        next(null, provs);\n      }\n    }\n    /**\n     * Get a list of providers for the given CID.\n     *\n     * @param {CID} cid\n     * @param {function(Error, Array<PeerId>)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"getProviders\",\n    value: function getProviders(cid, callback) {\n      this._log('getProviders %s', cid.toBaseEncodedString());\n\n      this._getProvidersMap(cid, function (err, provs) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, Array.from(provs.keys()));\n      });\n    }\n  }, {\n    key: \"cleanupInterval\",\n    get: function get() {\n      return this._cleanupInterval;\n    },\n    set: function set(val) {\n      var _this4 = this;\n\n      this._cleanupInterval = val;\n\n      if (this._cleaner) {\n        clearInterval(this._cleaner);\n      }\n\n      this._cleaner = setInterval(function () {\n        return _this4._cleanup();\n      }, this.cleanupInterval);\n    }\n  }]);\n\n  return Providers;\n}();\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID} cid\n * @returns {string}\n *\n * @private\n */\n\n\nfunction makeProviderKey(cid) {\n  return c.PROVIDERS_KEY_PREFIX + utils.encodeBase32(cid.buffer);\n}\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {number} time\n * @param {function(Error)} callback\n * @returns {undefined}\n *\n * @private\n */\n\n\nfunction writeProviderEntry(store, cid, peer, time, callback) {\n  var dsKey = [makeProviderKey(cid), '/', utils.encodeBase32(peer.id)].join('');\n  store.put(new Key(dsKey), Buffer.from(varint.encode(time)), callback);\n}\n/**\n * Load providers from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {function(Error, Map<PeerId, Date>)} callback\n * @returns {undefined}\n *\n * @private\n */\n\n\nfunction loadProviders(store, cid, callback) {\n  pull(store.query({\n    prefix: makeProviderKey(cid)\n  }), pull.map(function (entry) {\n    var parts = entry.key.toString().split('/');\n    var lastPart = parts[parts.length - 1];\n    var rawPeerId = utils.decodeBase32(lastPart);\n    return [new PeerId(rawPeerId), readTime(entry.value)];\n  }), pull.collect(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null, new Map(res));\n  }));\n}\n\nfunction readTime(buf) {\n  return varint.decode(buf);\n}\n\nmodule.exports = Providers;","map":null,"metadata":{},"sourceType":"script"}