{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar once = require('once');\n\nvar Queue = require('./queue');\n\nvar _require = require('../errors'),\n    DIAL_ABORTED = _require.DIAL_ABORTED;\n\nvar nextTick = require('async/nextTick');\n\nvar retimer = require('retimer');\n\nvar _require2 = require('../constants'),\n    QUARTER_HOUR = _require2.QUARTER_HOUR,\n    PRIORITY_HIGH = _require2.PRIORITY_HIGH;\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:dial:manager');\n\nvar noop = function noop() {};\n\nvar DialQueueManager =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {Switch} _switch\n   */\n  function DialQueueManager(_switch) {\n    _classCallCheck(this, DialQueueManager);\n\n    this._queue = new Set();\n    this._coldCallQueue = new Set();\n    this._dialingQueues = new Set();\n    this._queues = {};\n    this.switch = _switch;\n    this._cleanInterval = retimer(this._clean.bind(this), QUARTER_HOUR);\n    this.start();\n  }\n  /**\n   * Runs through all queues, aborts and removes them if they\n   * are no longer valid. A queue that is blacklisted indefinitely,\n   * is considered no longer valid.\n   * @private\n   */\n\n\n  _createClass(DialQueueManager, [{\n    key: \"_clean\",\n    value: function _clean() {\n      var _this = this;\n\n      var queues = Object.values(this._queues);\n      queues.forEach(function (dialQueue) {\n        // Clear if the queue has reached max blacklist\n        if (dialQueue.blackListed === Infinity) {\n          dialQueue.abort();\n          delete _this._queues[dialQueue.id];\n          return;\n        } // Keep track of blacklisted queues\n\n\n        if (dialQueue.blackListed) return; // Clear if peer is no longer active\n        // To avoid reallocating memory, dont delete queues of\n        // connected peers, as these are highly likely to leverage the\n        // queues in the immediate term\n\n        if (!dialQueue.isRunning && dialQueue.length < 1) {\n          var isConnected = false;\n\n          try {\n            var peerInfo = _this.switch._peerBook.get(dialQueue.id);\n\n            isConnected = Boolean(peerInfo.isConnected());\n          } catch (_) {// If we get an error, that means the peerbook doesnt have the peer\n          }\n\n          if (!isConnected) {\n            dialQueue.abort();\n            delete _this._queues[dialQueue.id];\n          }\n        }\n      });\n\n      this._cleanInterval.reschedule(QUARTER_HOUR);\n    }\n    /**\n     * Allows the `DialQueueManager` to execute dials\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.isRunning = true;\n    }\n    /**\n     * Iterates over all items in the DialerQueue\n     * and executes there callback with an error.\n     *\n     * This causes the entire DialerQueue to be drained\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this2 = this;\n\n      this.isRunning = false; // Clear the general queue\n\n      this._queue.clear(); // Clear the cold call queue\n\n\n      this._coldCallQueue.clear();\n\n      this._cleanInterval.clear(); // Abort the individual peer queues\n\n\n      var queues = Object.values(this._queues);\n      queues.forEach(function (dialQueue) {\n        dialQueue.abort();\n        delete _this2._queues[dialQueue.id];\n      });\n    }\n    /**\n     * Adds the `dialRequest` to the queue and ensures queue is running\n     *\n     * @param {DialRequest} dialRequest\n     * @returns {void}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(_ref) {\n      var peerInfo = _ref.peerInfo,\n          protocol = _ref.protocol,\n          options = _ref.options,\n          callback = _ref.callback;\n      callback = callback ? once(callback) : noop; // Add the dial to its respective queue\n\n      var targetQueue = this.getQueue(peerInfo); // Cold Call\n\n      if (options.priority > PRIORITY_HIGH) {\n        // If we have too many cold calls, abort the dial immediately\n        if (this._coldCallQueue.size >= this.switch.dialer.MAX_COLD_CALLS) {\n          return nextTick(callback, DIAL_ABORTED());\n        }\n\n        if (this._queue.has(targetQueue.id)) {\n          return nextTick(callback, DIAL_ABORTED());\n        }\n      }\n\n      targetQueue.add(protocol, options.useFSM, callback); // If we're already connected to the peer, start the queue now\n      // While it might cause queues to go over the max parallel amount,\n      // it avoids blocking peers we're already connected to\n\n      if (peerInfo.isConnected()) {\n        targetQueue.start();\n        return;\n      } // If dialing is not allowed, abort\n\n\n      if (!targetQueue.isDialAllowed()) {\n        return;\n      } // Add the id to its respective queue set if the queue isn't running\n\n\n      if (!targetQueue.isRunning) {\n        if (options.priority <= PRIORITY_HIGH) {\n          this._queue.add(targetQueue.id);\n\n          this._coldCallQueue.delete(targetQueue.id); // Only add it to the cold queue if it's not in the normal queue\n\n        } else {\n          this._coldCallQueue.add(targetQueue.id);\n        }\n      }\n\n      this.run();\n    }\n    /**\n     * Will execute up to `MAX_PARALLEL_DIALS` dials\n     */\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (!this.isRunning) return;\n\n      if (this._dialingQueues.size < this.switch.dialer.MAX_PARALLEL_DIALS) {\n        var nextQueue = {\n          done: true // Check the queue first and fall back to the cold call queue\n\n        };\n\n        if (this._queue.size > 0) {\n          nextQueue = this._queue.values().next();\n\n          this._queue.delete(nextQueue.value);\n        } else if (this._coldCallQueue.size > 0) {\n          nextQueue = this._coldCallQueue.values().next();\n\n          this._coldCallQueue.delete(nextQueue.value);\n        }\n\n        if (nextQueue.done) {\n          return;\n        }\n\n        var targetQueue = this._queues[nextQueue.value];\n\n        if (!targetQueue) {\n          log('missing queue %s, maybe it was aborted?', nextQueue.value);\n          return;\n        }\n\n        this._dialingQueues.add(targetQueue.id);\n\n        targetQueue.start();\n      }\n    }\n    /**\n     * Will remove the `peerInfo` from the dial blacklist\n     * @param {PeerInfo} peerInfo\n     */\n\n  }, {\n    key: \"clearBlacklist\",\n    value: function clearBlacklist(peerInfo) {\n      var queue = this.getQueue(peerInfo);\n      queue.blackListed = null;\n      queue.blackListCount = 0;\n    }\n    /**\n     * A handler for when dialing queues stop. This will trigger\n     * `run()` in order to keep the queue processing.\n     * @private\n     * @param {string} id peer id of the queue that stopped\n     */\n\n  }, {\n    key: \"_onQueueStopped\",\n    value: function _onQueueStopped(id) {\n      this._dialingQueues.delete(id);\n\n      this.run();\n    }\n    /**\n     * Returns the `Queue` for the given `peerInfo`\n     * @param {PeerInfo} peerInfo\n     * @returns {Queue}\n     */\n\n  }, {\n    key: \"getQueue\",\n    value: function getQueue(peerInfo) {\n      var id = peerInfo.id.toB58String();\n      this._queues[id] = this._queues[id] || new Queue(id, this.switch, this._onQueueStopped.bind(this));\n      return this._queues[id];\n    }\n  }]);\n\n  return DialQueueManager;\n}();\n\nmodule.exports = DialQueueManager;","map":null,"metadata":{},"sourceType":"script"}