{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar varint = require('varint');\n\nvar through = require('pull-through');\n\nvar debug = require('debug');\n\nvar log = debug('pull-plex:coder');\nlog.err = debug('pull-plex:coder:err');\nvar PULL_LENGTH = 10 * 1024;\nvar empty = Buffer.alloc(0);\n/**\n * Creates a Through PullStream that will varint encode all\n * messages passed through it.\n *\n * @returns {PullStream} A through stream that varint encodes all messages\n */\n\nexports.encode = function () {\n  var pool = Buffer.allocUnsafe(PULL_LENGTH);\n  var used = 0;\n  return through(function (msg) {\n    var oldUsed = used;\n    varint.encode(msg[0] << 3 | msg[1], pool, used);\n    used += varint.encode.bytes;\n    varint.encode(msg[2] ? msg[2].length : 0, pool, used);\n    used += varint.encode.bytes;\n    this.queue(pool.slice(oldUsed, used)); // send header\n\n    if (PULL_LENGTH - used < 100) {\n      pool = Buffer.allocUnsafe(PULL_LENGTH);\n      used = 0;\n    }\n\n    this.queue(msg[2] ? msg[2] : empty);\n  });\n};\n/**\n * @typedef {number} States\n */\n\n/**\n * @enum {States}\n */\n\n\nvar States = {\n  PARSING: 0,\n  READING: 1\n  /**\n   * Creates a Through PullStream that will varint decodes all\n   * messages passed through it.\n   *\n   * @returns {PullStream} A through stream that varint decodes all messages\n   */\n\n};\n\nexports.decode = function () {\n  var state = States.PARSING;\n\n  var tryDecode = function tryDecode(msg) {\n    var offset = 0;\n    var length = 0;\n\n    try {\n      var h = varint.decode(msg);\n      offset += varint.decode.bytes;\n      length = varint.decode(msg, offset);\n      offset += varint.decode.bytes;\n      return [h, offset, length];\n    } catch (err) {\n      log.err(err); // ignore if data is empty\n    }\n\n    return [];\n  };\n\n  var decode = function decode(msg) {\n    var _tryDecode = tryDecode(msg),\n        _tryDecode2 = _slicedToArray(_tryDecode, 3),\n        h = _tryDecode2[0],\n        offset = _tryDecode2[1],\n        length = _tryDecode2[2]; // If there is a header, process it\n\n\n    if (h !== void 0) {\n      var _message = {\n        id: h >> 3,\n        type: h & 7,\n        data: []\n      };\n      state = States.READING;\n      return [msg.slice(offset), _message, length];\n    } // There was no header, return the message\n\n\n    return [msg];\n  };\n\n  var read = function read(msg, data, length) {\n    // If we're done reading, start parsing the message\n    if (length <= 0) {\n      state = States.PARSING;\n      return [0, msg, data];\n    } // Read more data\n\n\n    var left = length - msg.length;\n\n    if (left < 0) {\n      left = 0;\n    }\n\n    var size = length - left;\n\n    if (msg.length > 0) {\n      var buff = Buffer.isBuffer(msg) ? msg : Buffer.from(msg);\n      data.push(buff.slice(0, size));\n    } // If we finished reading, start parsing\n\n\n    if (left <= 0) {\n      state = States.PARSING;\n    }\n\n    return [left, msg.slice(size), data];\n  };\n\n  var length = 0;\n  var message = null;\n  var accumulating = false;\n  var array = [];\n  return through(function (msg) {\n    var ps = this;\n\n    function more() {\n      if (msg && msg.length) {\n        // Reading is done for this message, start processing it\n        if (States.PARSING === state) {\n          if (accumulating) {\n            array.push(msg);\n            msg = Buffer.concat(array);\n          }\n\n          var _decode = decode(msg);\n\n          var _decode2 = _slicedToArray(_decode, 3);\n\n          msg = _decode2[0];\n          message = _decode2[1];\n          length = _decode2[2];\n\n          if (!message) {\n            if (!accumulating) {\n              array.push(msg);\n            }\n\n            accumulating = true;\n            return;\n          }\n\n          array = [];\n          accumulating = false;\n        } // We're not done reading the message, keep reading it\n\n\n        if (States.READING === state) {\n          var _read = read(msg, message.data, length);\n\n          var _read2 = _slicedToArray(_read, 3);\n\n          length = _read2[0];\n          msg = _read2[1];\n          message.data = _read2[2];\n\n          // If we read the whole message, add it to the queue\n          if (length <= 0 && States.PARSING === state) {\n            message.data = Buffer.concat(message.data);\n            ps.queue(message);\n            message = null;\n            length = 0;\n          }\n        }\n\n        more();\n      }\n    }\n\n    more();\n  });\n};","map":null,"metadata":{},"sourceType":"script"}