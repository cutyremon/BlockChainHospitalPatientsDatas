{"ast":null,"code":"'use strict';\n\nvar peerId = require('peer-id');\n\nvar mergeOptions = require('merge-options');\n\nvar waterfall = require('async/waterfall');\n\nvar parallel = require('async/parallel');\n\nvar promisify = require('promisify-es6');\n\nvar defaultConfig = require('../runtime/config-nodejs.js');\n\nvar Keychain = require('libp2p-keychain');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode;\n\nvar UnixFs = require('ipfs-unixfs');\n\nvar multicodec = require('multicodec');\n\nvar IPNS = require('../ipns');\n\nvar OfflineDatastore = require('../ipns/routing/offline-datastore');\n\nvar addDefaultAssets = require('./init-assets');\n\nmodule.exports = function init(self) {\n  return promisify(function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    var done = function done(err, res) {\n      if (err) {\n        self.emit('error', err);\n        return callback(err);\n      }\n\n      self.preStart(function (err) {\n        if (err) {\n          self.emit('error', err);\n          return callback(err);\n        }\n\n        self.state.initialized();\n        self.emit('init');\n        callback(null, res);\n      });\n    };\n\n    if (self.state.state() !== 'uninitialized') {\n      return done(new Error('Not able to init from state: ' + self.state.state()));\n    }\n\n    self.state.init();\n    self.log('init'); // An initialized, open repo was passed, use this one!\n\n    if (opts.repo) {\n      self._repo = opts.repo;\n      return done(null, true);\n    }\n\n    opts.emptyRepo = opts.emptyRepo || false;\n    opts.bits = Number(opts.bits) || 2048;\n\n    opts.log = opts.log || function () {};\n\n    var config = mergeOptions(defaultConfig(), self._options.config);\n    var privateKey;\n    waterfall([// Verify repo does not yet exist.\n    function (cb) {\n      return self._repo.exists(cb);\n    }, function (exists, cb) {\n      self.log('repo exists?', exists);\n\n      if (exists === true) {\n        return cb(new Error('repo already exists'));\n      }\n\n      if (opts.privateKey) {\n        self.log('using user-supplied private-key');\n\n        if (typeof opts.privateKey === 'object') {\n          cb(null, opts.privateKey);\n        } else {\n          peerId.createFromPrivKey(Buffer.from(opts.privateKey, 'base64'), cb);\n        }\n      } else {\n        // Generate peer identity keypair + transform to desired format + add to config.\n        opts.log(\"generating \".concat(opts.bits, \"-bit RSA keypair...\"), false);\n        self.log('generating peer id: %s bits', opts.bits);\n        peerId.create({\n          bits: opts.bits\n        }, cb);\n      }\n    }, function (peerId, cb) {\n      self.log('identity generated');\n      config.Identity = {\n        PeerID: peerId.toB58String(),\n        PrivKey: peerId.privKey.bytes.toString('base64')\n      };\n      privateKey = peerId.privKey;\n\n      if (opts.pass) {\n        config.Keychain = Keychain.generateOptions();\n      }\n\n      opts.log('done');\n      opts.log('peer identity: ' + config.Identity.PeerID);\n\n      self._repo.init(config, cb);\n    }, function (_, cb) {\n      return self._repo.open(cb);\n    }, function (cb) {\n      self.log('repo opened');\n\n      if (opts.pass) {\n        self.log('creating keychain');\n        var keychainOptions = Object.assign({\n          passPhrase: opts.pass\n        }, config.Keychain);\n        self._keychain = new Keychain(self._repo.keys, keychainOptions);\n\n        self._keychain.importPeer('self', {\n          privKey: privateKey\n        }, cb);\n      } else {\n        cb(null, true);\n      }\n    }, // Setup the offline routing for IPNS.\n    // This is primarily used for offline ipns modifications, such as the initializeKeyspace feature.\n    function (_, cb) {\n      var offlineDatastore = new OfflineDatastore(self._repo);\n      self._ipns = new IPNS(offlineDatastore, self._repo.datastore, self._peerInfo, self._keychain, self._options);\n      cb(null, true);\n    }, // add empty unixfs dir object (go-ipfs assumes this exists)\n    function (_, cb) {\n      if (opts.emptyRepo) {\n        return cb(null, true);\n      }\n\n      var tasks = [function (cb) {\n        waterfall([function (cb) {\n          try {\n            cb(null, DAGNode.create(new UnixFs('directory').marshal()));\n          } catch (err) {\n            cb(err);\n          }\n        }, function (node, cb) {\n          return self.dag.put(node, {\n            version: 0,\n            format: multicodec.DAG_PB,\n            hashAlg: multicodec.SHA2_256\n          }).then(function (cid) {\n            return cb(null, cid);\n          }, function (error) {\n            return cb(error);\n          });\n        }, function (cid, cb) {\n          return self._ipns.initializeKeyspace(privateKey, cid.toBaseEncodedString(), cb);\n        }], cb);\n      }];\n\n      if (typeof addDefaultAssets === 'function') {\n        // addDefaultAssets is undefined on browsers.\n        // See package.json browser config\n        tasks.push(function (cb) {\n          return addDefaultAssets(self, opts.log, cb);\n        });\n      }\n\n      self.log('adding assets');\n      parallel(tasks, function (err) {\n        if (err) {\n          cb(err);\n        } else {\n          cb(null, true);\n        }\n      });\n    }], done);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}