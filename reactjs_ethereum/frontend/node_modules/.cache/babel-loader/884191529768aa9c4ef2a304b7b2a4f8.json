{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar BlockService = require('ipfs-block-service');\n\nvar Ipld = require('ipld');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar crypto = require('libp2p-crypto');\n\nvar isIPFS = require('is-ipfs');\n\nvar multiaddr = require('multiaddr');\n\nvar multihash = require('multihashes');\n\nvar PeerBook = require('peer-book');\n\nvar multibase = require('multibase');\n\nvar multicodec = require('multicodec');\n\nvar multihashing = require('multihashing-async');\n\nvar CID = require('cids');\n\nvar debug = require('debug');\n\nvar mergeOptions = require('merge-options');\n\nvar EventEmitter = require('events');\n\nvar config = require('./config');\n\nvar boot = require('./boot');\n\nvar components = require('./components'); // replaced by repo-browser when running in the browser\n\n\nvar defaultRepo = require('./runtime/repo-nodejs');\n\nvar preload = require('./preload');\n\nvar mfsPreload = require('./mfs-preload');\n\nvar ipldOptions = require('./runtime/ipld-nodejs');\n\nvar IPFS =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(IPFS, _EventEmitter);\n\n  function IPFS(options) {\n    var _this;\n\n    _classCallCheck(this, IPFS);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(IPFS).call(this));\n    var defaults = {\n      init: true,\n      start: true,\n      EXPERIMENTAL: {},\n      preload: {\n        enabled: true,\n        addresses: ['/dnsaddr/node0.preload.ipfs.io/https', '/dnsaddr/node1.preload.ipfs.io/https']\n      }\n    };\n    options = config.validate(options || {});\n    _this._options = mergeOptions(defaults, options);\n\n    if (options.init === false) {\n      _this._options.init = false;\n    }\n\n    if (!(options.start === false)) {\n      _this._options.start = true;\n    }\n\n    if (typeof options.repo === 'string' || options.repo === undefined) {\n      _this._repo = defaultRepo(options.repo);\n    } else {\n      _this._repo = options.repo;\n    } // IPFS utils\n\n\n    _this.log = debug('ipfs');\n    _this.log.err = debug('ipfs:err'); // IPFS Core Internals\n    // this._repo - assigned above\n\n    _this._peerInfoBook = new PeerBook();\n    _this._peerInfo = undefined;\n    _this._bitswap = undefined;\n    _this._blockService = new BlockService(_this._repo);\n    _this._ipld = new Ipld(ipldOptions(_this._blockService, _this._options.ipld, _this.log));\n    _this._preload = preload(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._mfsPreload = mfsPreload(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._ipns = undefined; // eslint-disable-next-line no-console\n\n    _this._print = _this._options.silent ? _this.log : console.log; // IPFS Core exposed components\n    //   - for booting up a node\n\n    _this.init = components.init(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.preStart = components.preStart(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.start = components.start(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.stop = components.stop(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.shutdown = _this.stop;\n    _this.isOnline = components.isOnline(_assertThisInitialized(_assertThisInitialized(_this))); //   - interface-ipfs-core defined API\n\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), components.filesRegular(_assertThisInitialized(_assertThisInitialized(_this))));\n    _this.version = components.version(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.id = components.id(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.repo = components.repo(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.bootstrap = components.bootstrap(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.config = components.config(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.block = components.block(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.object = components.object(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dag = components.dag(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.files = components.filesMFS(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.libp2p = null; // assigned on start\n\n    _this.swarm = components.swarm(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.name = components.name(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.bitswap = components.bitswap(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.pin = components.pin(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.ping = components.ping(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.pingPullStream = components.pingPullStream(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.pingReadableStream = components.pingReadableStream(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.pubsub = components.pubsub(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dht = components.dht(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dns = components.dns(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.key = components.key(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.stats = components.stats(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.resolve = components.resolve(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    if (_this._options.EXPERIMENTAL.pubsub) {\n      _this.log('EXPERIMENTAL pubsub is enabled');\n    }\n\n    if (_this._options.EXPERIMENTAL.ipnsPubsub) {\n      if (!_this._options.EXPERIMENTAL.pubsub) {\n        _this.log('EXPERIMENTAL pubsub is enabled to use IPNS pubsub');\n\n        _this._options.EXPERIMENTAL.pubsub = true;\n      }\n\n      _this.log('EXPERIMENTAL IPNS pubsub is enabled');\n    }\n\n    if (_this._options.EXPERIMENTAL.sharding) {\n      _this.log('EXPERIMENTAL sharding is enabled');\n    }\n\n    _this.state = require('./state')(_assertThisInitialized(_assertThisInitialized(_this)));\n    boot(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  return IPFS;\n}(EventEmitter);\n\nmodule.exports = IPFS; // Note: We need to do this to force browserify to load the Buffer module\n\nvar BufferImpl = Buffer;\nObject.assign(module.exports, {\n  crypto: crypto,\n  isIPFS: isIPFS,\n  Buffer: BufferImpl,\n  CID: CID,\n  multiaddr: multiaddr,\n  multibase: multibase,\n  multihash: multihash,\n  multihashing: multihashing,\n  multicodec: multicodec,\n  PeerId: PeerId,\n  PeerInfo: PeerInfo\n});\n\nmodule.exports.createNode = function (options) {\n  return new IPFS(options);\n};","map":null,"metadata":{},"sourceType":"script"}