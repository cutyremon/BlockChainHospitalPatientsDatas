{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar pull = require('pull-stream/pull');\n\nvar debug = require('debug');\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar EE = require('events').EventEmitter;\n\nvar once = require('once');\n\nvar utilsFactory = require('./utils');\n\nvar StreamHandler = require('./stream-handler');\n\nvar proto = require('../protocol').CircuitRelay;\n\nvar multiaddr = require('multiaddr');\n\nvar series = require('async/series');\n\nvar waterfall = require('async/waterfall');\n\nvar multicodec = require('./../multicodec');\n\nvar log = debug('libp2p:circuit:relay');\nlog.err = debug('libp2p:circuit:error:relay');\n\nvar Hop =\n/*#__PURE__*/\nfunction (_EE) {\n  _inherits(Hop, _EE);\n\n  /**\n   * Construct a Circuit object\n   *\n   * This class will handle incoming circuit connections and\n   * either start a relay or hand the relayed connection to\n   * the swarm\n   *\n   * @param {Swarm} swarm\n   * @param {Object} options\n   */\n  function Hop(swarm, options) {\n    var _this;\n\n    _classCallCheck(this, Hop);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Hop).call(this));\n    _this.swarm = swarm;\n    _this.peerInfo = _this.swarm._peerInfo;\n    _this.utils = utilsFactory(swarm);\n    _this.config = options || {\n      active: false,\n      enabled: false\n    };\n    _this.active = _this.config.active;\n    return _this;\n  }\n  /**\n   * Handle the relay message\n   *\n   * @param {CircuitRelay} message\n   * @param {StreamHandler} sh\n   * @returns {*}\n   */\n\n\n  _createClass(Hop, [{\n    key: \"handle\",\n    value: function handle(message, sh) {\n      var _this2 = this;\n\n      if (!this.config.enabled) {\n        this.utils.writeResponse(sh, proto.Status.HOP_CANT_SPEAK_RELAY);\n        return sh.close();\n      } // check if message is `CAN_HOP`\n\n\n      if (message.type === proto.Type.CAN_HOP) {\n        this.utils.writeResponse(sh, proto.Status.SUCCESS);\n        return sh.close();\n      } // This is a relay request - validate and create a circuit\n\n\n      var srcPeerId = null;\n      var dstPeerId = null;\n\n      try {\n        srcPeerId = PeerId.createFromBytes(message.srcPeer.id).toB58String();\n        dstPeerId = PeerId.createFromBytes(message.dstPeer.id).toB58String();\n      } catch (err) {\n        log.err(err);\n\n        if (!srcPeerId) {\n          this.utils.writeResponse(sh, proto.Status.HOP_SRC_MULTIADDR_INVALID);\n          return sh.close();\n        }\n\n        if (!dstPeerId) {\n          this.utils.writeResponse(sh, proto.Status.HOP_DST_MULTIADDR_INVALID);\n          return sh.close();\n        }\n      }\n\n      if (srcPeerId === dstPeerId) {\n        this.utils.writeResponse(sh, proto.Status.HOP_CANT_RELAY_TO_SELF);\n        return sh.close();\n      }\n\n      if (!message.dstPeer.addrs.length) {\n        // TODO: use encapsulate here\n        var addr = multiaddr(\"/p2p-circuit/ipfs/\".concat(dstPeerId)).buffer;\n        message.dstPeer.addrs.push(addr);\n      }\n\n      log('trying to establish a circuit: %s <-> %s', srcPeerId, dstPeerId);\n\n      var noPeer = function noPeer() {\n        // log.err(err)\n        _this2.utils.writeResponse(sh, proto.Status.HOP_NO_CONN_TO_DST);\n\n        return sh.close();\n      };\n\n      var isConnected = function isConnected(cb) {\n        var dstPeer;\n\n        try {\n          dstPeer = _this2.swarm._peerBook.get(dstPeerId);\n\n          if (!dstPeer.isConnected() && !_this2.active) {\n            var err = new Error(\"No Connection to peer \".concat(dstPeerId));\n            noPeer(err);\n            return cb(err);\n          }\n        } catch (err) {\n          if (!_this2.active) {\n            noPeer(err);\n            return cb(err);\n          }\n        }\n\n        cb();\n      };\n\n      series([function (cb) {\n        return _this2.utils.validateAddrs(message, sh, proto.Type.HOP, cb);\n      }, function (cb) {\n        return isConnected(cb);\n      }, function (cb) {\n        return _this2._circuit(sh, message, cb);\n      }], function (err) {\n        if (err) {\n          log.err(err);\n          sh.close();\n          return setImmediate(function () {\n            return _this2.emit('circuit:error', err);\n          });\n        }\n\n        setImmediate(function () {\n          return _this2.emit('circuit:success');\n        });\n      });\n    }\n    /**\n     * Connect to STOP\n     *\n     * @param {PeerInfo} peer\n     * @param {StreamHandler} srcSh\n     * @param {function} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_connectToStop\",\n    value: function _connectToStop(peer, srcSh, callback) {\n      var _this3 = this;\n\n      this._dialPeer(peer, function (err, dstConn) {\n        if (err) {\n          _this3.utils.writeResponse(srcSh, proto.Status.HOP_CANT_DIAL_DST);\n\n          log.err(err);\n          return callback(err);\n        }\n\n        return _this3.utils.writeResponse(srcSh, proto.Status.SUCCESS, function (err) {\n          if (err) {\n            log.err(err);\n            return callback(err);\n          }\n\n          return callback(null, dstConn);\n        });\n      });\n    }\n    /**\n     * Negotiate STOP\n     *\n     * @param {StreamHandler} dstSh\n     * @param {StreamHandler} srcSh\n     * @param {CircuitRelay} message\n     * @param {function} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_negotiateStop\",\n    value: function _negotiateStop(dstSh, srcSh, message, callback) {\n      var _this4 = this;\n\n      var stopMsg = Object.assign({}, message, {\n        type: proto.Type.STOP // change the message type\n\n      });\n      dstSh.write(proto.encode(stopMsg), function (err) {\n        if (err) {\n          _this4.utils.writeResponse(srcSh, proto.Status.HOP_CANT_OPEN_DST_STREAM);\n\n          log.err(err);\n          return callback(err);\n        } // read response from STOP\n\n\n        dstSh.read(function (err, msg) {\n          if (err) {\n            log.err(err);\n            return callback(err);\n          }\n\n          var message = proto.decode(msg);\n\n          if (message.code !== proto.Status.SUCCESS) {\n            return callback(new Error(\"Unable to create circuit!\"));\n          }\n\n          return callback(null, msg);\n        });\n      });\n    }\n    /**\n     * Attempt to make a circuit from A <-> R <-> B where R is this relay\n     *\n     * @param {StreamHandler} srcSh - the source stream handler\n     * @param {CircuitRelay} message - the message with the src and dst entries\n     * @param {Function} callback - callback to signal success or failure\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_circuit\",\n    value: function _circuit(srcSh, message, callback) {\n      var _this5 = this;\n\n      var dstSh = null;\n      waterfall([function (cb) {\n        return _this5._connectToStop(message.dstPeer, srcSh, cb);\n      }, function (_dstConn, cb) {\n        dstSh = new StreamHandler(_dstConn);\n\n        _this5._negotiateStop(dstSh, srcSh, message, cb);\n      }], function (err) {\n        if (err) {\n          // close/end the source stream if there was an error\n          if (srcSh) {\n            srcSh.close();\n          }\n\n          if (dstSh) {\n            dstSh.close();\n          }\n\n          return callback(err);\n        }\n\n        var src = srcSh.rest();\n        var dst = dstSh.rest();\n        var srcIdStr = PeerId.createFromBytes(message.srcPeer.id).toB58String();\n        var dstIdStr = PeerId.createFromBytes(message.dstPeer.id).toB58String(); // circuit the src and dst streams\n\n        pull(src, dst, src);\n        log('circuit %s <-> %s established', srcIdStr, dstIdStr);\n        callback();\n      });\n    }\n    /**\n     * Dial the dest peer and create a circuit\n     *\n     * @param {Multiaddr} dstPeer\n     * @param {Function} callback\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(dstPeer, callback) {\n      var peerInfo = new PeerInfo(PeerId.createFromBytes(dstPeer.id));\n      dstPeer.addrs.forEach(function (a) {\n        return peerInfo.multiaddrs.add(a);\n      });\n      this.swarm.dial(peerInfo, multicodec.relay, once(function (err, conn) {\n        if (err) {\n          log.err(err);\n          return callback(err);\n        }\n\n        callback(null, conn);\n      }));\n    }\n  }]);\n\n  return Hop;\n}(EE);\n\nmodule.exports = Hop;","map":null,"metadata":{},"sourceType":"script"}