{"ast":null,"code":"'use strict';\n\nvar pull = require('pull-stream');\n\nvar lp = require('pull-length-prefixed');\n\nvar Message = require('../message');\n\nvar handlers = require('./handlers');\n\nvar utils = require('../utils');\n\nvar c = require('../constants');\n\nmodule.exports = function (dht) {\n  var log = utils.logger(dht.peerInfo.id, 'rpc');\n  var getMessageHandler = handlers(dht);\n  /**\n   * Process incoming DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  function handleMessage(peer, msg, callback) {\n    // update the peer\n    dht._add(peer, function (err) {\n      if (err) {\n        log.error('Failed to update the kbucket store');\n        log.error(err);\n      } // get handler & exectue it\n\n\n      var handler = getMessageHandler(msg.type);\n\n      if (!handler) {\n        log.error(\"no handler found for message type: \".concat(msg.type));\n        return callback();\n      }\n\n      handler(peer, msg, callback);\n    });\n  }\n  /**\n   * Handle incoming streams from the Switch, on the dht protocol.\n   *\n   * @param {string} protocol\n   * @param {Connection} conn\n   * @returns {undefined}\n   */\n\n\n  return function protocolHandler(protocol, conn) {\n    conn.getPeerInfo(function (err, peer) {\n      if (err) {\n        log.error('Failed to get peer info');\n        log.error(err);\n        return;\n      }\n\n      log('from: %s', peer.id.toB58String());\n      pull(conn, lp.decode(), pull.filter(function (msg) {\n        return msg.length < c.maxMessageSize;\n      }), pull.map(function (rawMsg) {\n        var msg;\n\n        try {\n          msg = Message.deserialize(rawMsg);\n        } catch (err) {\n          log.error('failed to read incoming message', err);\n          return;\n        }\n\n        return msg;\n      }), pull.filter(Boolean), pull.asyncMap(function (msg, cb) {\n        return handleMessage(peer, msg, cb);\n      }), // Not all handlers will return a response\n      pull.filter(Boolean), pull.map(function (response) {\n        var msg;\n\n        try {\n          msg = response.serialize();\n        } catch (err) {\n          log.error('failed to send message', err);\n          return;\n        }\n\n        return msg;\n      }), pull.filter(Boolean), lp.encode(), conn);\n    });\n  };\n};","map":null,"metadata":{},"sourceType":"script"}