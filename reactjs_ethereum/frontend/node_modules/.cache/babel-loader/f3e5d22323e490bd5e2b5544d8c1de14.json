{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar KBucket = require('k-bucket');\n\nvar utils = require('./utils');\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrival for peers.\n */\n\n\nvar RoutingTable =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {PeerId} self\n   * @param {number} kBucketSize\n   */\n  function RoutingTable(self, kBucketSize) {\n    var _this = this;\n\n    _classCallCheck(this, RoutingTable);\n\n    this.self = self;\n    this._onPing = this._onPing.bind(this);\n    utils.convertPeerId(self, function (err, selfKey) {\n      if (err) {\n        throw err;\n      }\n\n      _this.kb = new KBucket({\n        localNodeId: selfKey,\n        numberOfNodesPerKBucket: kBucketSize,\n        numberOfNodesToPing: 1\n      });\n\n      _this.kb.on('ping', _this._onPing);\n    });\n  } // -- Private Methods\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without acutally pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {Array<Object>} oldContacts\n   * @param {Object} newContact\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _createClass(RoutingTable, [{\n    key: \"_onPing\",\n    value: function _onPing(oldContacts, newContact) {\n      // just use the first one (k-bucket sorts from oldest to newest)\n      var oldest = oldContacts[0]; // remove the oldest one\n\n      this.kb.remove(oldest.id); // add the new one\n\n      this.kb.add(newContact);\n    } // -- Public Interface\n\n    /**\n     * Amount of currently stored peers.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: \"find\",\n\n    /**\n     * Find a specific peer by id.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error, PeerId)} callback\n     * @returns {void}\n     */\n    value: function find(peer, callback) {\n      var _this2 = this;\n\n      utils.convertPeerId(peer, function (err, key) {\n        if (err) {\n          return callback(err);\n        }\n\n        var closest = _this2.closestPeer(key);\n\n        if (closest && closest.isEqual(peer)) {\n          return callback(null, closest);\n        }\n\n        callback();\n      });\n    }\n    /**\n     * Retrieve the closest peers to the given key.\n     *\n     * @param {Buffer} key\n     * @param {number} count\n     * @returns {PeerId|undefined}\n     */\n\n  }, {\n    key: \"closestPeer\",\n    value: function closestPeer(key, count) {\n      var res = this.closestPeers(key, 1);\n\n      if (res.length > 0) {\n        return res[0];\n      }\n    }\n    /**\n     * Retrieve the `count`-closest peers to the given key.\n     *\n     * @param {Buffer} key\n     * @param {number} count\n     * @returns {Array<PeerId>}\n     */\n\n  }, {\n    key: \"closestPeers\",\n    value: function closestPeers(key, count) {\n      return this.kb.closest(key, count).map(function (p) {\n        return p.peer;\n      });\n    }\n    /**\n     * Add or update the routing table with the given peer.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(peer, callback) {\n      var _this3 = this;\n\n      utils.convertPeerId(peer, function (err, id) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3.kb.add({\n          id: id,\n          peer: peer\n        });\n\n        callback();\n      });\n    }\n    /**\n     * Remove a given peer from the table.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(peer, callback) {\n      var _this4 = this;\n\n      utils.convertPeerId(peer, function (err, id) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this4.kb.remove(id);\n\n        callback();\n      });\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.kb.count();\n    }\n  }]);\n\n  return RoutingTable;\n}();\n\nmodule.exports = RoutingTable;","map":null,"metadata":{},"sourceType":"script"}