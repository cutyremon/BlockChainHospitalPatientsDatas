{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar pull = require('pull-stream');\n\nvar pushable = require('pull-pushable');\n\nvar through = require('pull-through');\n\nvar looper = require('looper');\n\nvar nextTick = require('async/nextTick');\n\nvar EE = require('events');\n\nvar debug = require('debug');\n\nvar _require = require('./util'),\n    emitError = _require.emitError,\n    emitStream = _require.emitStream;\n\nvar _require2 = require('./consts'),\n    Types = _require2.Types,\n    MAX_MSG_SIZE = _require2.MAX_MSG_SIZE;\n\nvar Channel = require('./channel');\n\nvar coder = require('./coder');\n\nvar log = debug('pull-plex');\nlog.err = debug('pull-plex:err');\n/**\n * @typedef {Object} Message\n * @property {number} id\n * @property {MessageType} type\n * @property {Buffer} data\n */\n\n/**\n * @fires Mplex#close Emitted when Mplex closes\n * @fires Mplex#error Emitted when an error occurs\n * @fires Mplex#stream Emitted when a new stream is opened\n */\n\nvar Mplex =\n/*#__PURE__*/\nfunction (_EE) {\n  _inherits(Mplex, _EE);\n\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {boolean} opts.initiator Is this starting the stream. Default: `true`\n   * @param {function(Channel, number)} opts.onChan A handler for new streams. Can be used instead of `.on('stream')`\n   * @param {number} opts.maxChannels Maximum number of channels to have open. Default: `10000`\n   * @param {number} opts.maxMsgSize Maximum size messages are allowed to be. Default: `1 << 20` (1MB)\n   * @param {boolean} opts.lazy Should channels be opened lazily? If false, channels will be opened when they are created. Default: `false`\n   */\n  function Mplex(opts) {\n    var _this;\n\n    _classCallCheck(this, Mplex);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Mplex).call(this));\n\n    if (typeof opts === 'boolean') {\n      opts = {\n        initiator: opts\n      };\n    }\n\n    opts = _objectSpread({\n      initiator: true,\n      onChan: null,\n      maxChannels: 10000,\n      maxMsgSize: MAX_MSG_SIZE,\n      lazy: false\n    }, opts);\n    _this._maxChannels = opts.maxChannels;\n    _this._maxMsgSize = opts.maxMsgSize;\n    _this._lazy = opts.lazy;\n    _this._initiator = Boolean(opts.initiator);\n    _this._chanId = 0;\n    _this._inChannels = new Array(_this._maxChannels / 2);\n    _this._outChannels = new Array(_this._maxChannels / 2);\n    _this._endedRemote = false; // remote stream ended\n\n    _this._endedLocal = false; // local stream ended\n\n    _this._chandata = pushable(function (err) {\n      _this._log('mplex ended');\n\n      _this._endedRemote = true;\n\n      _this.close(err);\n    });\n\n    if (opts.onChan) {\n      _this.on('stream', function (chan) {\n        return opts.onChan(chan, chan.id);\n      });\n    }\n\n    _this.source = pull(_this._chandata, coder.encode());\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this));\n\n    _this.sink = pull(through(function (data) {\n      // ensure data is within our max size requirement\n      if (data && data.length >= self._maxMsgSize) {\n        nextTick(emitError, self, new Error('message too large!'));\n        return this.queue(null);\n      }\n\n      this.queue(data);\n    }), coder.decode(), function (read) {\n      var next = looper(function () {\n        read(null, function (end, data) {\n          if (self._endedLocal) {\n            return;\n          }\n\n          if (end === true) {\n            return self.close();\n          }\n\n          if (end) {\n            return self.destroy(end);\n          }\n\n          self._handle(data);\n\n          next();\n        });\n      });\n      next();\n    });\n    return _this;\n  }\n  /**\n   * A convenience wrapper for the log that adds useful metadata to logs\n   * @private\n   * @param {string} name The name of the operation being logged\n   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n   */\n\n\n  _createClass(Mplex, [{\n    key: \"_log\",\n    value: function _log(name, data) {\n      log({\n        op: name,\n        initiator: this._initiator,\n        endedLocal: this._endedLocal,\n        endedRemote: this._endedRemote,\n        data: data && data.toString() || ''\n      });\n    }\n  }, {\n    key: \"close\",\n\n    /**\n     * Closes all open channels\n     * @param {Error} err Optional error\n     */\n    value: function close(err) {\n      this._log('close', err);\n\n      if (this.destroyed) {\n        return;\n      }\n\n      if (err) {\n        nextTick(emitError, this, err);\n      }\n\n      err = err || 'Underlying stream has been closed';\n      this._endedLocal = true; // propagate close to channels\n\n      var chans = Array.prototype.concat(this._outChannels, this._inChannels);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = chans[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var chan = _step.value;\n\n          if (chan) {\n            chan.close(err);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.emit('close');\n    }\n  }, {\n    key: \"destroy\",\n\n    /**\n     * Destroys the parent stream and closes Mplex\n     * @param {Error} err\n     */\n    value: function destroy(err) {\n      err = err || new Error('Underlying stream has been closed');\n\n      this._chandata.end(err);\n\n      this.close(err);\n    }\n    /**\n     * Pushes data to the stream\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      if (data.data && Buffer.byteLength(data.data) > this._maxMsgSize) {\n        this._chandata.end(new Error('message too large!'));\n      }\n\n      this._chandata.push(data);\n    }\n    /**\n     * Creates a new Channel (stream). If Mplex was created with `opts.lazy` set to true,\n     * the channel will not automatically be opened.\n     *\n     * @param {string} name The name of the channel/stream to create\n     * @returns {Channel}\n     */\n\n  }, {\n    key: \"createStream\",\n    value: function createStream(name) {\n      if (typeof name === 'number') {\n        name = name.toString();\n      }\n\n      var chan = this._newStream(null, true, false, name, this._outChannels);\n\n      if (!this._lazy) {\n        chan.openChan(name);\n      }\n\n      return chan;\n    }\n    /**\n     * Attempts to create a channel if it doesn't already exist.\n     * If a channel already exists for `id`, `Mplex#error` will be emitted.\n     *\n     * @private\n     * @param {number} id The id of the channel. If `null` it will be auto incremented from `Mplex._chanId`\n     * @param {boolean} initiator Is the channel creating the connection\n     * @param {boolean} open Should the channel be opened when created\n     * @param {string} name The name of the channel\n     * @param {Array} list The channel list to add the channel to\n     * @returns {Channel}\n     */\n\n  }, {\n    key: \"_newStream\",\n    value: function _newStream(id, initiator, open, name, list) {\n      if (this.chanSize >= this._maxChannels) {\n        this.emit('error', new Error('max channels exceeded'));\n        return;\n      }\n\n      if (typeof initiator === 'string') {\n        name = initiator;\n        initiator = false;\n        open = false;\n      }\n\n      if (typeof open === 'string') {\n        name = open;\n        open = false;\n      }\n\n      id = typeof id === 'number' ? id : this._chanId++;\n\n      if (list[id]) {\n        this.emit('error', new Error(\"channel with id \".concat(id, \" already exist!\")));\n        return;\n      }\n\n      var chan = new Channel({\n        id: id,\n        name: name,\n        plex: this,\n        initiator: initiator,\n        open: open || false\n      });\n      return this._addChan(id, chan, list);\n    }\n    /**\n     * A convenience method for setting the `chan` up to be tracked.\n     * @private\n     * @param {number} id The id of the channel\n     * @param {Channel} chan The channel to track\n     * @param {Array} list The channel list to add the channel to\n     * @returns {Channel} `chan`\n     */\n\n  }, {\n    key: \"_addChan\",\n    value: function _addChan(id, chan, list) {\n      chan.once('close', function () {\n        list[id] = null;\n      });\n      chan.once('error', function (err) {\n        log.err('channel error', err);\n      });\n      list[id] = chan;\n      return chan;\n    }\n  }, {\n    key: \"_handle\",\n\n    /**\n     * Takes the appropriate course of action based on `msg.type`.\n     * If `msg.type` is not recognized `Mplex#error` will be emitted.\n     * @param {Message} msg\n     */\n    value: function _handle(msg) {\n      this._log('_handle', msg);\n\n      var id = msg.id,\n          type = msg.type,\n          data = msg.data;\n\n      switch (type) {\n        // Create a new stream\n        case Types.NEW:\n          {\n            var chan = this._newStream(id, false, true, data.toString(), this._inChannels);\n\n            nextTick(emitStream, this, chan, id);\n            break;\n          }\n        // Push the data into the channel with the matching id if it exists\n\n        case Types.OUT_MESSAGE:\n        case Types.IN_MESSAGE:\n          {\n            var list = type & 1 ? this._outChannels : this._inChannels;\n            var _chan = list[id];\n\n            if (_chan) {\n              _chan.push(data);\n            }\n\n            break;\n          }\n        // Close the channel with the matching id\n\n        case Types.OUT_CLOSE:\n        case Types.IN_CLOSE:\n          {\n            var _list = type & 1 ? this._outChannels : this._inChannels;\n\n            var _chan2 = _list[id];\n\n            if (_chan2) {\n              _chan2.close();\n            }\n\n            break;\n          }\n        // Destroys the channel with the matching id\n\n        case Types.OUT_RESET:\n        case Types.IN_RESET:\n          {\n            var _list2 = type & 1 ? this._outChannels : this._inChannels;\n\n            var _chan3 = _list2[id];\n\n            if (_chan3) {\n              _chan3.destroy();\n            }\n\n            break;\n          }\n\n        default:\n          nextTick(emitError, this, new Error('Invalid message type'));\n      }\n    }\n  }, {\n    key: \"initiator\",\n    get: function get() {\n      return this._initiator;\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this._endedRemote && this._endedLocal;\n    }\n  }, {\n    key: \"chanSize\",\n    get: function get() {\n      return this._inChannels.size + this._outChannels.size;\n    }\n  }]);\n\n  return Mplex;\n}(EE);\n\nmodule.exports = Mplex;","map":null,"metadata":{},"sourceType":"script"}