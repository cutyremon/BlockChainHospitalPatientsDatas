{"ast":null,"code":"'use strict';\n\nvar _toArray = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/toArray\");\n\nvar promisify = require('promisify-es6');\n\nvar map = require('async/map');\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\n\nfunction parseIpfsPath(ipfsPath) {\n  var invalidPathErr = new Error('invalid ipfs ref path');\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '');\n  var matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/);\n\n  if (!matched) {\n    throw invalidPathErr;\n  }\n\n  var _matched$1$split = matched[1].split('/'),\n      _matched$1$split2 = _toArray(_matched$1$split),\n      hash = _matched$1$split2[0],\n      links = _matched$1$split2.slice(1); // check that a CID can be constructed with the hash\n\n\n  if (isIpfs.cid(hash)) {\n    return {\n      hash: hash,\n      links: links\n    };\n  } else {\n    throw invalidPathErr;\n  }\n}\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n * If the received string is not a valid ipfs path, an error will be returned\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\n\nvar normalizePath = function normalizePath(pathStr) {\n  if (isIpfs.cid(pathStr)) {\n    return \"/ipfs/\".concat(pathStr);\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw Object.assign(new Error(\"invalid \".concat(pathStr, \" path\")), {\n      code: ERR_BAD_PATH\n    });\n  }\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param  {IPFS}               objectAPI The IPFS object api\n * @param  {Described above}    ipfsPaths A single or collection of ipfs-paths\n * @param  {Function<err, res>} callback res is Array<Buffer(hash)>\n *                              if no callback is passed, returns a Promise\n * @return {Promise|void}\n */\n\n\nvar resolvePath = promisify(function (objectAPI, ipfsPaths, callback) {\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths];\n  }\n\n  map(ipfsPaths, function (path, cb) {\n    if (typeof path !== 'string') {\n      var cid;\n\n      try {\n        cid = new CID(path);\n      } catch (err) {\n        return cb(err);\n      }\n\n      return cb(null, cid.buffer);\n    }\n\n    var parsedPath;\n\n    try {\n      parsedPath = exports.parseIpfsPath(path);\n    } catch (err) {\n      return cb(err);\n    }\n\n    var rootHash = new CID(parsedPath.hash);\n    var rootLinks = parsedPath.links;\n\n    if (!rootLinks.length) {\n      return cb(null, rootHash.buffer);\n    }\n\n    objectAPI.get(rootHash, follow.bind(null, rootHash, rootLinks)); // recursively follow named links to the target node\n\n    function follow(cid, links, err, obj) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (!links.length) {\n        // done tracing, obj is the target node\n        return cb(null, cid.buffer);\n      }\n\n      var linkName = links[0];\n      var nextObj = obj.Links.find(function (link) {\n        return link.Name === linkName;\n      });\n\n      if (!nextObj) {\n        return cb(new Error(\"no link named \\\"\".concat(linkName, \"\\\" under \").concat(cid)));\n      }\n\n      objectAPI.get(nextObj.Hash, follow.bind(null, nextObj.Hash, links.slice(1)));\n    }\n  }, callback);\n});\nexports.normalizePath = normalizePath;\nexports.parseIpfsPath = parseIpfsPath;\nexports.resolvePath = resolvePath;","map":null,"metadata":{},"sourceType":"script"}