{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar pushable = require('pull-pushable');\n\nvar looper = require('looper');\n\nvar nextTick = require('async/nextTick');\n\nvar EE = require('events');\n\nvar debug = require('debug');\n\nvar _require = require('./consts'),\n    Types = _require.Types;\n\nvar _require2 = require('./util'),\n    emitError = _require2.emitError;\n\nvar log = debug('pull-plex:chan');\nlog.err = debug('pull-plex:chan:err');\n/**\n * Creates a pull-stream sink for the given Channel\n * @private\n * @param {Channel} channel\n * @returns {function} The sink function\n */\n\nfunction channelSink(channel) {\n  return function (read) {\n    var next = looper(function () {\n      read(null, function (end, data) {\n        // stream already ended\n        if (channel._endedLocal) {\n          return;\n        }\n\n        channel._endedLocal = end || false; // source ended, close the stream\n\n        if (end === true) {\n          return channel.endChan();\n        } // source errored, destroy stream\n\n\n        if (end || channel._destroy) {\n          channel.destroyChan();\n          channel.emit('error', end || channel._destroy);\n          channel.destroy();\n          return;\n        } // just send\n\n\n        channel.sendMsg(data);\n        next();\n      });\n    });\n    next();\n  };\n}\n/**\n * @fires Channel#close\n * @fires Channel#error\n */\n\n\nvar Channel =\n/*#__PURE__*/\nfunction (_EE) {\n  _inherits(Channel, _EE);\n\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {number} opts.id\n   * @param {boolean} opts.initiator\n   * @param {string} opts.name\n   * @param {boolean} opts.open\n   * @param {Mplex} opts.plex\n   */\n  function Channel(opts) {\n    var _this;\n\n    _classCallCheck(this, Channel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Channel).call(this));\n    opts = _objectSpread({\n      initiator: false\n    }, opts);\n    _this._id = opts.id;\n    _this._name = opts.name;\n    _this._plex = opts.plex;\n    _this._open = opts.open;\n    _this._initiator = opts.initiator;\n    _this._endedRemote = false; // remote stream ended\n\n    _this._endedLocal = false; // local stream ended\n\n    _this._destroy = false;\n    _this.MSG = _this._initiator ? Types.OUT_MESSAGE : Types.IN_MESSAGE;\n    _this.END = _this._initiator ? Types.OUT_CLOSE : Types.IN_CLOSE;\n    _this.RESET = _this._initiator ? Types.OUT_RESET : Types.IN_RESET;\n\n    _this._log('new channel', _this._name);\n\n    _this._msgs = pushable(function (err) {\n      _this._log('source closed', err);\n\n      if (err && typeof err !== 'boolean') {\n        nextTick(emitError, _assertThisInitialized(_assertThisInitialized(_this)), err);\n      } // this.endChan() // Do not uncomment this, it will end the channel too early\n\n    });\n    _this._source = _this._msgs;\n    _this.sink = channelSink(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Channel, [{\n    key: \"_log\",\n\n    /**\n     * A convenience wrapper for the log that adds useful metadata to logs\n     * @private\n     * @param {string} name The name of the operation being logged\n     * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n     */\n    value: function _log(name, data) {\n      if (!log.enabled) return;\n      log({\n        op: name,\n        name: this._name,\n        id: this._id,\n        endedLocal: this._endedLocal,\n        endedRemote: this._endedRemote,\n        initiator: this._initiator,\n        data: data && data.toString() || ''\n      });\n    }\n    /**\n     * Pushes `data` into the channel\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      this._log('push');\n\n      this._msgs.push(data);\n    }\n    /**\n     * Closes the channel for writing\n     * @param {Error} err\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(err) {\n      this._log('close', err);\n\n      if (!this._endedRemote) {\n        this._endedRemote = err || true;\n\n        this._msgs.end(this._endedRemote);\n\n        this.emit('close', err);\n        this.plex = null;\n      }\n    }\n    /**\n     * Closes the channel with the given error\n     * @param {Error} err Default: `'channel destroyed!'`\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(err) {\n      this._log('destroy', err);\n\n      this._destroy = err || 'channel destroyed!';\n      this.close(this._destroy);\n    }\n    /**\n     * Opens the channel if it's not already open. Attempting\n     * to open an already opened channel is ignored.\n     * @param {string} name\n     */\n\n  }, {\n    key: \"openChan\",\n    value: function openChan(name) {\n      if (this.open) {\n        return;\n      } // chan already open\n\n\n      this.open = true;\n\n      this._plex.push([this._id, Types.NEW, name !== this._id.toString() ? name : this._id.toString()]);\n    }\n    /**\n     * Pushes `data` wrapped in a `Message` into the channel.\n     * If the channel is not open, it will be opened automatically.\n     *\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"sendMsg\",\n    value: function sendMsg(data) {\n      this._log('sendMsg', data);\n\n      if (!this.open) {\n        this.openChan(this.name);\n      }\n\n      this._plex.push([this._id, this.MSG, data]);\n    }\n    /**\n     * Ends the channel by sending an END `Message`.\n     * If the channel is not open, no action will be taken.\n     */\n\n  }, {\n    key: \"endChan\",\n    value: function endChan() {\n      this._log('endChan');\n\n      if (!this.open) {\n        return;\n      }\n\n      this._plex.push([this._id, this.END]);\n    }\n    /**\n     * Destroys the channel by sending a RESET `Message`.\n     * If the channel is not open, no action will be taken.\n     */\n\n  }, {\n    key: \"destroyChan\",\n    value: function destroyChan() {\n      this._log('destroyChan');\n\n      if (!this.open) {\n        return;\n      }\n\n      this._plex.push([this._id, this.RESET]);\n    }\n  }, {\n    key: \"source\",\n    get: function get() {\n      return this._source;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: \"open\",\n    get: function get() {\n      return this._open;\n    },\n    set: function set(open) {\n      this._open = open;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._name;\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this._endedRemote && this._endedLocal;\n    }\n  }]);\n\n  return Channel;\n}(EE);\n\nmodule.exports = Channel;","map":null,"metadata":{},"sourceType":"script"}