{"ast":null,"code":"'use strict';\n\nvar CID = require('cids');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('../../../utils/cid'),\n    cidToString = _require2.cidToString;\n\nvar toPullStream = require('async-iterator-to-pull-stream');\n\nvar normalizePath = function normalizePath(path) {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Parses chunker string into options used by DAGBuilder in ipfs-unixfs-engine\n *\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                    \"size-{size}\"\n *                    \"rabin\"\n *                    \"rabin-{avg}\"\n *                    \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   Chunker options for DAGBuilder\n */\n\n\nvar parseChunkerString = function parseChunkerString(chunker) {\n  if (!chunker) {\n    return {\n      chunker: 'fixed'\n    };\n  } else if (chunker.startsWith('size-')) {\n    var sizeStr = chunker.split('-')[1];\n    var size = parseInt(sizeStr);\n\n    if (isNaN(size)) {\n      throw new Error('Chunker parameter size must be an integer');\n    }\n\n    return {\n      chunker: 'fixed',\n      chunkerOptions: {\n        maxChunkSize: size\n      }\n    };\n  } else if (chunker.startsWith('rabin')) {\n    return {\n      chunker: 'rabin',\n      chunkerOptions: parseRabinString(chunker)\n    };\n  } else {\n    throw new Error(\"Unrecognized chunker option: \".concat(chunker));\n  }\n};\n/**\n * Parses rabin chunker string\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                            \"rabin\"\n *                            \"rabin-{avg}\"\n *                            \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   rabin chunker options\n */\n\n\nvar parseRabinString = function parseRabinString(chunker) {\n  var options = {};\n  var parts = chunker.split('-');\n\n  switch (parts.length) {\n    case 1:\n      options.avgChunkSize = 262144;\n      break;\n\n    case 2:\n      options.avgChunkSize = parseChunkSize(parts[1], 'avg');\n      break;\n\n    case 4:\n      options.minChunkSize = parseChunkSize(parts[1], 'min');\n      options.avgChunkSize = parseChunkSize(parts[2], 'avg');\n      options.maxChunkSize = parseChunkSize(parts[3], 'max');\n      break;\n\n    default:\n      throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"');\n  }\n\n  return options;\n};\n\nvar parseChunkSize = function parseChunkSize(str, name) {\n  var size = parseInt(str);\n\n  if (isNaN(size)) {\n    throw new Error(\"Chunker parameter \".concat(name, \" must be an integer\"));\n  }\n\n  return size;\n};\n\nvar mapFile = function mapFile() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (file) {\n    var size = 0;\n    var type = 'dir';\n\n    if (file.unixfs && file.unixfs.type === 'file') {\n      size = file.unixfs.fileSize();\n      type = 'file';\n    }\n\n    var output = {\n      hash: cidToString(file.cid, {\n        base: options.cidBase\n      }),\n      path: file.path,\n      name: file.name,\n      depth: file.path.split('/').length,\n      size: size,\n      type: type\n    };\n\n    if (options.includeContent && file.unixfs && file.unixfs.type === 'file') {\n      output.content = toPullStream.source(file.content());\n    }\n\n    return output;\n  };\n};\n\nmodule.exports = {\n  normalizePath: normalizePath,\n  parseChunkSize: parseChunkSize,\n  parseRabinString: parseRabinString,\n  parseChunkerString: parseChunkerString,\n  mapFile: mapFile\n};","map":null,"metadata":{},"sourceType":"script"}