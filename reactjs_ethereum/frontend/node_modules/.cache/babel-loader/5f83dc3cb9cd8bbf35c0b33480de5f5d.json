{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:resolver');\nlog.error = debug('ipfs:ipns:resolver:error');\nvar defaultMaximumRecursiveDepth = 32;\n\nvar IpnsResolver =\n/*#__PURE__*/\nfunction () {\n  function IpnsResolver(routing) {\n    _classCallCheck(this, IpnsResolver);\n\n    this._routing = routing;\n  }\n\n  _createClass(IpnsResolver, [{\n    key: \"resolve\",\n    value: function resolve(name, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (typeof name !== 'string') {\n        var errMsg = \"one or more of the provided parameters are not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PARAMETER'));\n      }\n\n      options = options || {};\n      var recursive = options.recursive && options.recursive.toString() === 'true';\n      var nameSegments = name.split('/');\n\n      if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n        var _errMsg = \"invalid name syntax for \".concat(name);\n\n        log.error(_errMsg);\n        return callback(errcode(new Error(_errMsg), 'ERR_INVALID_NAME_SYNTAX'));\n      }\n\n      var key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n      var depth;\n\n      if (recursive) {\n        depth = defaultMaximumRecursiveDepth;\n      }\n\n      this.resolver(key, depth, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        log(\"\".concat(name, \" was locally resolved correctly\"));\n        callback(null, res);\n      });\n    } // Recursive resolver according to the specified depth\n\n  }, {\n    key: \"resolver\",\n    value: function resolver(name, depth, callback) {\n      var _this = this;\n\n      // Exceeded recursive maximum depth\n      if (depth === 0) {\n        var errMsg = \"could not resolve name (recursion limit of \".concat(defaultMaximumRecursiveDepth, \" exceeded)\");\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT'));\n      }\n\n      this._resolveName(name, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        var nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n        if (nameSegments[1] === 'ipfs' || !depth) {\n          return callback(null, res);\n        } // continue recursively until depth equals 0\n\n\n        _this.resolver(nameSegments[2], depth - 1, callback);\n      });\n    } // resolve ipns entries from the provided routing\n\n  }, {\n    key: \"_resolveName\",\n    value: function _resolveName(name, callback) {\n      var _this2 = this;\n\n      var peerId;\n\n      try {\n        peerId = PeerId.createFromB58String(name);\n      } catch (err) {\n        return callback(err);\n      }\n\n      var _ipns$getIdKeys = ipns.getIdKeys(peerId.toBytes()),\n          routingKey = _ipns$getIdKeys.routingKey,\n          routingPubKey = _ipns$getIdKeys.routingPubKey;\n\n      this._routing.get(routingKey.toBuffer(), function (err, record) {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg2 = \"unexpected error getting the ipns record \".concat(peerId.id);\n\n            log.error(_errMsg2);\n            return callback(errcode(new Error(_errMsg2), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD'));\n          }\n\n          var errMsg = \"record requested was not found for \".concat(name, \" (\").concat(routingKey, \") in the network\");\n          log.error(errMsg);\n          return callback(errcode(new Error(errMsg), 'ERR_NO_RECORD_FOUND'));\n        } // IPNS entry\n\n\n        var ipnsEntry;\n\n        try {\n          ipnsEntry = ipns.unmarshal(record);\n        } catch (err) {\n          var _errMsg3 = \"found ipns record that we couldn't convert to a value\";\n          log.error(_errMsg3);\n          return callback(errcode(new Error(_errMsg3), 'ERR_INVALID_RECORD_RECEIVED'));\n        } // if the record has a public key validate it\n\n\n        if (ipnsEntry.pubKey) {\n          return _this2._validateRecord(peerId, ipnsEntry, callback);\n        } // Otherwise, try to get the public key from routing\n\n\n        _this2._routing.get(routingKey.toBuffer(), function (err, pubKey) {\n          if (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n              var _errMsg5 = \"unexpected error getting the public key for the ipns record \".concat(peerId.id);\n\n              log.error(_errMsg5);\n              return callback(errcode(new Error(_errMsg5), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY'));\n            }\n\n            var _errMsg4 = \"public key requested was not found for \".concat(name, \" (\").concat(routingPubKey, \") in the network\");\n\n            log.error(_errMsg4);\n            return callback(errcode(new Error(_errMsg4), 'ERR_NO_RECORD_FOUND'));\n          }\n\n          try {\n            // Insert it into the peer id, in order to be validated by IPNS validator\n            peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey);\n          } catch (err) {\n            var _errMsg6 = \"found public key record that we couldn't convert to a value\";\n            log.error(_errMsg6);\n            return callback(errcode(new Error(_errMsg6), 'ERR_INVALID_PUB_KEY_RECEIVED'));\n          }\n\n          _this2._validateRecord(peerId, ipnsEntry, callback);\n        });\n      });\n    } // validate a resolved record\n\n  }, {\n    key: \"_validateRecord\",\n    value: function _validateRecord(peerId, ipnsEntry, callback) {\n      ipns.extractPublicKey(peerId, ipnsEntry, function (err, pubKey) {\n        if (err) {\n          return callback(err);\n        } // IPNS entry validation\n\n\n        ipns.validate(pubKey, ipnsEntry, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, ipnsEntry.value.toString());\n        });\n      });\n    }\n  }]);\n\n  return IpnsResolver;\n}();\n\nexports = module.exports = IpnsResolver;","map":null,"metadata":{},"sourceType":"script"}