{"ast":null,"code":"'use strict';\n\nvar waterfall = require('async/waterfall');\n\nvar parallel = require('async/parallel');\n\nvar setImmediate = require('async/setImmediate');\n\nvar promisify = require('promisify-es6');\n\nvar dagPB = require('ipld-dag-pb');\n\nvar DAGNode = dagPB.DAGNode;\nvar DAGLink = dagPB.DAGLink;\n\nvar CID = require('cids');\n\nvar mh = require('multihashes');\n\nvar multicodec = require('multicodec');\n\nvar Unixfs = require('ipfs-unixfs');\n\nvar errCode = require('err-code');\n\nfunction normalizeMultihash(multihash, enc) {\n  if (typeof multihash === 'string') {\n    if (enc === 'base58' || !enc) {\n      return multihash;\n    }\n\n    return Buffer.from(multihash, enc);\n  } else if (Buffer.isBuffer(multihash)) {\n    return multihash;\n  } else if (CID.isCID(multihash)) {\n    return multihash.buffer;\n  } else {\n    throw new Error('unsupported multihash');\n  }\n}\n\nfunction parseBuffer(buf, encoding, callback) {\n  switch (encoding) {\n    case 'json':\n      return parseJSONBuffer(buf, callback);\n\n    case 'protobuf':\n      return parseProtoBuffer(buf, callback);\n\n    default:\n      callback(new Error(\"unkown encoding: \".concat(encoding)));\n  }\n}\n\nfunction parseJSONBuffer(buf, callback) {\n  var data;\n  var links;\n\n  try {\n    var parsed = JSON.parse(buf.toString());\n    links = (parsed.Links || []).map(function (link) {\n      return new DAGLink(link.Name || link.name, link.Size || link.size, mh.fromB58String(link.Hash || link.hash || link.multihash));\n    });\n    data = Buffer.from(parsed.Data);\n  } catch (err) {\n    return callback(new Error('failed to parse JSON: ' + err));\n  }\n\n  try {\n    callback(null, DAGNode.create(data, links));\n  } catch (err) {\n    callback(err);\n  }\n}\n\nfunction parseProtoBuffer(buf, callback) {\n  var obj;\n\n  try {\n    obj = dagPB.util.deserialize(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  callback(null, obj);\n}\n\nfunction findLinks(node) {\n  var links = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  for (var key in node) {\n    var val = node[key];\n\n    if (key === '/' && Object.keys(node).length === 1) {\n      try {\n        links.push(new DAGLink('', 0, new CID(val)));\n        continue;\n      } catch (_) {// not a CID\n      }\n    }\n\n    if (CID.isCID(val)) {\n      links.push(new DAGLink('', 0, val));\n      continue;\n    }\n\n    if (Array.isArray(val)) {\n      findLinks(val, links);\n    }\n\n    if (typeof val === 'object' && !(val instanceof String)) {\n      findLinks(val, links);\n    }\n  }\n\n  return links;\n}\n\nmodule.exports = function object(self) {\n  function editAndSave(edit) {\n    return function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      waterfall([function (cb) {\n        self.object.get(multihash, options, cb);\n      }, function (node, cb) {\n        // edit applies the edit func passed to\n        // editAndSave\n        edit(node, function (err, node) {\n          if (err) {\n            return cb(err);\n          }\n\n          self._ipld.put(node, multicodec.DAG_PB, {\n            cidVersion: 0,\n            hashAlg: multicodec.SHA2_256\n          }).then(function (cid) {\n            if (options.preload !== false) {\n              self._preload(cid);\n            }\n\n            cb(null, cid);\n          }, function (error) {\n            return cb(error);\n          });\n        });\n      }], callback);\n    };\n  }\n\n  return {\n    new: promisify(function (template, options, callback) {\n      if (typeof template === 'function') {\n        callback = template;\n        template = undefined;\n        options = {};\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var data;\n\n      if (template) {\n        if (template !== 'unixfs-dir') {\n          return setImmediate(function () {\n            return callback(new Error('unknown template'));\n          });\n        }\n\n        data = new Unixfs('directory').marshal();\n      } else {\n        data = Buffer.alloc(0);\n      }\n\n      var node;\n\n      try {\n        node = DAGNode.create(data);\n      } catch (err) {\n        return callback(err);\n      }\n\n      self._ipld.put(node, multicodec.DAG_PB, {\n        cidVersion: 0,\n        hashAlg: multicodec.SHA2_256\n      }).then(function (cid) {\n        if (options.preload !== false) {\n          self._preload(cid);\n        }\n\n        callback(null, cid);\n      }, function (error) {\n        return callback(error);\n      });\n    }),\n    put: promisify(function (obj, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var encoding = options.enc;\n      var node;\n\n      if (Buffer.isBuffer(obj)) {\n        if (encoding) {\n          parseBuffer(obj, encoding, function (err, _node) {\n            if (err) {\n              return callback(err);\n            }\n\n            node = _node;\n            next();\n          });\n        } else {\n          try {\n            node = DAGNode.create(obj);\n          } catch (err) {\n            return callback(err);\n          }\n\n          next();\n        }\n      } else if (DAGNode.isDAGNode(obj)) {\n        // already a dag node\n        node = obj;\n        next();\n      } else if (typeof obj === 'object') {\n        try {\n          node = DAGNode.create(obj.Data, obj.Links);\n        } catch (err) {\n          return callback(err);\n        }\n\n        next();\n      } else {\n        return callback(new Error('obj not recognized'));\n      }\n\n      function next() {\n        self._ipld.put(node, multicodec.DAG_PB, {\n          cidVersion: 0,\n          hashAlg: multicodec.SHA2_256\n        }).then(function (cid) {\n          if (options.preload !== false) {\n            self._preload(cid);\n          }\n\n          callback(null, cid);\n        }, function (error) {\n          return callback(error);\n        });\n      }\n    }),\n    get: promisify(function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var mh, cid;\n\n      try {\n        mh = normalizeMultihash(multihash, options.enc);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_MULTIHASH'));\n        });\n      }\n\n      try {\n        cid = new CID(mh);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_CID'));\n        });\n      }\n\n      if (options.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      self._ipld.get(cid).then(function (node) {\n        return callback(null, node);\n      }, function (error) {\n        return callback(error);\n      });\n    }),\n    data: promisify(function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      self.object.get(multihash, options, function (err, node) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, node.Data);\n      });\n    }),\n    links: promisify(function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      var cid = new CID(multihash);\n      self.dag.get(cid, options, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (cid.codec === 'raw') {\n          return callback(null, []);\n        }\n\n        if (cid.codec === 'dag-pb') {\n          return callback(null, result.value.Links);\n        }\n\n        if (cid.codec === 'dag-cbor') {\n          var links = findLinks(result);\n          callback(null, links);\n        }\n\n        callback(new Error(\"Cannot resolve links from codec \".concat(cid.codec)));\n      });\n    }),\n    stat: promisify(function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      waterfall([function (cb) {\n        return self.object.get(multihash, options, cb);\n      }, function (node, cb) {\n        cb(null, {\n          node: node,\n          serialized: dagPB.util.serialize(node)\n        });\n      }, function (_ref, cb) {\n        var _node2 = _ref.node,\n            _serialized = _ref.serialized;\n        parallel({\n          serialized: function serialized(next) {\n            return next(null, _serialized);\n          },\n          cid: function cid(next) {\n            return dagPB.util.cid(_serialized, {\n              cidVersion: 0\n            }).then(function (cid) {\n              return next(null, cid);\n            }, next);\n          },\n          node: function node(next) {\n            return next(null, _node2);\n          }\n        }, cb);\n      }], function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        var blockSize = result.serialized.length;\n        var linkLength = result.node.Links.reduce(function (a, l) {\n          return a + l.Tsize;\n        }, 0);\n        callback(null, {\n          Hash: result.cid.toBaseEncodedString(),\n          NumLinks: result.node.Links.length,\n          BlockSize: blockSize,\n          LinksSize: blockSize - result.node.Data.length,\n          DataSize: result.node.Data.length,\n          CumulativeSize: blockSize + linkLength\n        });\n      });\n    }),\n    patch: promisify({\n      addLink: function addLink(multihash, link, options, callback) {\n        editAndSave(function (node, cb) {\n          DAGNode.addLink(node, link).then(function (node) {\n            cb(null, node);\n          }, cb);\n        })(multihash, options, callback);\n      },\n      rmLink: function rmLink(multihash, linkRef, options, callback) {\n        editAndSave(function (node, cb) {\n          linkRef = linkRef.Name || linkRef.name;\n\n          try {\n            node = DAGNode.rmLink(node, linkRef);\n          } catch (err) {\n            return cb(err);\n          }\n\n          cb(null, node);\n        })(multihash, options, callback);\n      },\n      appendData: function appendData(multihash, data, options, callback) {\n        editAndSave(function (node, cb) {\n          var newData = Buffer.concat([node.Data, data]);\n\n          try {\n            node = DAGNode.create(newData, node.Links);\n          } catch (err) {\n            return cb(err);\n          }\n\n          cb(null, node);\n        })(multihash, options, callback);\n      },\n      setData: function setData(multihash, data, options, callback) {\n        editAndSave(function (node, cb) {\n          try {\n            node = DAGNode.create(data, node.Links);\n          } catch (err) {\n            return cb(err);\n          }\n\n          cb(null, node);\n        })(multihash, options, callback);\n      }\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}