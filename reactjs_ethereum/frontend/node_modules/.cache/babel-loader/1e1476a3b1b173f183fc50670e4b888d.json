{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar FSM = require('fsm-event');\n\nvar Circuit = require('libp2p-circuit');\n\nvar multistream = require('multistream-select');\n\nvar withIs = require('class-is');\n\nvar BaseConnection = require('./base');\n\nvar parallel = require('async/parallel');\n\nvar nextTick = require('async/nextTick');\n\nvar identify = require('libp2p-identify');\n\nvar errCode = require('err-code');\n\nvar _require = require('../utils'),\n    msHandle = _require.msHandle,\n    msSelect = _require.msSelect,\n    identifyDialer = _require.identifyDialer;\n\nvar observeConnection = require('../observe-connection');\n\nvar _require2 = require('../errors'),\n    CONNECTION_FAILED = _require2.CONNECTION_FAILED,\n    DIAL_SELF = _require2.DIAL_SELF,\n    INVALID_STATE_TRANSITION = _require2.INVALID_STATE_TRANSITION,\n    NO_TRANSPORTS_REGISTERED = _require2.NO_TRANSPORTS_REGISTERED,\n    maybeUnexpectedEnd = _require2.maybeUnexpectedEnd;\n/**\n * @typedef {Object} ConnectionOptions\n * @property {Switch} _switch Our switch instance\n * @property {PeerInfo} peerInfo The PeerInfo of the peer to dial\n * @property {Muxer} muxer Optional - A muxed connection\n * @property {Connection} conn Optional - The base connection\n * @property {string} type Optional - identify the connection as incoming or outgoing. Defaults to out.\n */\n\n/**\n * ConnectionFSM handles the complex logic of managing a connection\n * between peers. ConnectionFSM is internally composed of a state machine\n * to help improve the usability and debuggability of connections. The\n * state machine also helps to improve the ability to handle dial backoff,\n * coalescing dials and dial locks.\n */\n\n\nvar ConnectionFSM =\n/*#__PURE__*/\nfunction (_BaseConnection) {\n  _inherits(ConnectionFSM, _BaseConnection);\n\n  /**\n   * @param {ConnectionOptions} connectionOptions\n   * @constructor\n   */\n  function ConnectionFSM(_ref) {\n    var _this;\n\n    var _switch = _ref._switch,\n        peerInfo = _ref.peerInfo,\n        muxer = _ref.muxer,\n        conn = _ref.conn,\n        _ref$type = _ref.type,\n        type = _ref$type === void 0 ? 'out' : _ref$type;\n\n    _classCallCheck(this, ConnectionFSM);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionFSM).call(this, {\n      _switch: _switch,\n      name: \"\".concat(type, \":\").concat(_switch._peerInfo.id.toB58String().slice(0, 8))\n    }));\n    _this.theirPeerInfo = peerInfo;\n    _this.theirB58Id = _this.theirPeerInfo.id.toB58String();\n    _this.conn = conn; // The base connection\n\n    _this.muxer = muxer; // The upgraded/muxed connection\n\n    var startState = 'DISCONNECTED';\n\n    if (_this.muxer) {\n      startState = 'MUXED';\n    }\n\n    _this._state = FSM(startState, {\n      DISCONNECTED: {\n        // No active connections exist for the peer\n        dial: 'DIALING',\n        disconnect: 'DISCONNECTED',\n        done: 'DISCONNECTED'\n      },\n      DIALING: {\n        // Creating an initial connection\n        abort: 'ABORTED',\n        // emit events for different transport dials?\n        done: 'DIALED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      DIALED: {\n        // Base connection to peer established\n        encrypt: 'ENCRYPTING',\n        privatize: 'PRIVATIZING'\n      },\n      PRIVATIZING: {\n        // Protecting the base connection\n        done: 'PRIVATIZED',\n        abort: 'ABORTED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: {\n        // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: {\n        // Encrypting the base connection\n        done: 'ENCRYPTED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: {\n        // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: {\n        // Attempting to upgrade the connection with muxers\n        stop: 'CONNECTED',\n        // If we cannot mux, stop upgrading\n        done: 'MUXED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      CONNECTED: {\n        // A non muxed connection is established\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: {\n        // Shutting down the connection\n        done: 'DISCONNECTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ABORTED: {},\n      // A severe event occurred\n      ERRORED: {\n        // An error occurred, but future dials may be allowed\n        disconnect: 'DISCONNECTING' // There could be multiple options here, but this is a likely action\n\n      }\n    });\n\n    _this._state.on('DISCONNECTED', function () {\n      return _this._onDisconnected();\n    });\n\n    _this._state.on('DIALING', function () {\n      return _this._onDialing();\n    });\n\n    _this._state.on('DIALED', function () {\n      return _this._onDialed();\n    });\n\n    _this._state.on('PRIVATIZING', function () {\n      return _this._onPrivatizing();\n    });\n\n    _this._state.on('PRIVATIZED', function () {\n      return _this._onPrivatized();\n    });\n\n    _this._state.on('ENCRYPTING', function () {\n      return _this._onEncrypting();\n    });\n\n    _this._state.on('ENCRYPTED', function () {\n      _this.log('successfully encrypted connection to %s', _this.theirB58Id);\n\n      _this.emit('encrypted', _this.conn);\n    });\n\n    _this._state.on('UPGRADING', function () {\n      return _this._onUpgrading();\n    });\n\n    _this._state.on('MUXED', function () {\n      _this.log('successfully muxed connection to %s', _this.theirB58Id);\n\n      delete _this.switch.conns[_this.theirB58Id];\n\n      _this.emit('muxed', _this.muxer);\n    });\n\n    _this._state.on('CONNECTED', function () {\n      _this.log('unmuxed connection opened to %s', _this.theirB58Id);\n\n      _this.emit('unmuxed', _this.conn);\n    });\n\n    _this._state.on('DISCONNECTING', function () {\n      return _this._onDisconnecting();\n    });\n\n    _this._state.on('ABORTED', function () {\n      return _this._onAborted();\n    });\n\n    _this._state.on('ERRORED', function () {\n      return _this._onErrored();\n    });\n\n    _this._state.on('error', function (err) {\n      return _this._onStateError(err);\n    });\n\n    return _this;\n  }\n  /**\n   * Puts the state into dialing mode\n   *\n   * @fires ConnectionFSM#Error May emit a DIAL_SELF error\n   * @returns {void}\n   */\n\n\n  _createClass(ConnectionFSM, [{\n    key: \"dial\",\n    value: function dial() {\n      if (this.theirB58Id === this.ourPeerInfo.id.toB58String()) {\n        return this.emit('error', DIAL_SELF());\n      } else if (this.getState() === 'DIALING') {\n        return this.log('attempted to dial while already dialing, ignoring');\n      }\n\n      this._state('dial');\n    }\n    /**\n     * Initiates a handshake for the given protocol\n     *\n     * @param {string} protocol The protocol to negotiate\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"shake\",\n    value: function shake(protocol, callback) {\n      var _this2 = this;\n\n      // If there is no protocol set yet, don't perform the handshake\n      if (!protocol) {\n        return callback(null, null);\n      }\n\n      if (this.muxer && this.muxer.newStream) {\n        return this.muxer.newStream(function (err, stream) {\n          if (err) {\n            return callback(err, null);\n          }\n\n          _this2.log('created new stream to %s', _this2.theirB58Id);\n\n          _this2._protocolHandshake(protocol, stream, callback);\n        });\n      }\n\n      this._protocolHandshake(protocol, this.conn, callback);\n    }\n    /**\n     * Puts the state into muxing mode\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"upgrade\",\n    value: function upgrade() {\n      this._state('upgrade');\n    }\n    /**\n     * Event handler for dialing. Transitions state when successful.\n     *\n     * @private\n     * @fires ConnectionFSM#error\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onDialing\",\n    value: function _onDialing() {\n      var _this3 = this;\n\n      this.log('dialing %s', this.theirB58Id);\n\n      if (!this.switch.hasTransports()) {\n        return this.close(NO_TRANSPORTS_REGISTERED());\n      }\n\n      var tKeys = this.switch.availableTransports(this.theirPeerInfo);\n      var circuitEnabled = Boolean(this.switch.transports[Circuit.tag]);\n\n      if (circuitEnabled && !tKeys.includes(Circuit.tag)) {\n        tKeys.push(Circuit.tag);\n      }\n\n      var nextTransport = function nextTransport(key) {\n        var transport = key;\n\n        if (!transport) {\n          if (!circuitEnabled) {\n            return _this3.close(CONNECTION_FAILED(\"Circuit not enabled and all transports failed to dial peer \".concat(_this3.theirB58Id, \"!\")));\n          }\n\n          return _this3.close(CONNECTION_FAILED(\"No available transports to dial peer \".concat(_this3.theirB58Id, \"!\")));\n        }\n\n        if (transport === Circuit.tag) {\n          _this3.theirPeerInfo.multiaddrs.add(\"/p2p-circuit/p2p/\".concat(_this3.theirB58Id));\n        }\n\n        _this3.log('dialing transport %s', transport);\n\n        _this3.switch.transport.dial(transport, _this3.theirPeerInfo, function (errors, _conn) {\n          if (errors) {\n            _this3.emit('error:connection_attempt_failed', errors);\n\n            _this3.log(errors);\n\n            return nextTransport(tKeys.shift());\n          }\n\n          _this3.conn = observeConnection(transport, null, _conn, _this3.switch.observer);\n\n          _this3._state('done');\n        });\n      };\n\n      nextTransport(tKeys.shift());\n    }\n    /**\n     * Once a connection has been successfully dialed, the connection\n     * will be privatized or encrypted depending on the presence of the\n     * Switch.protector.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onDialed\",\n    value: function _onDialed() {\n      this.log('successfully dialed %s', this.theirB58Id);\n      this.emit('connected', this.conn);\n    }\n    /**\n     * Event handler for disconnecting. Handles any needed cleanup\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onDisconnecting\",\n    value: function _onDisconnecting() {\n      var _this4 = this;\n\n      this.log('disconnecting from %s', this.theirB58Id, Boolean(this.muxer));\n      delete this.switch.conns[this.theirB58Id];\n      var tasks = []; // Clean up stored connections\n\n      if (this.muxer) {\n        tasks.push(function (cb) {\n          _this4.muxer.end(function () {\n            delete _this4.muxer;\n            cb();\n          });\n        });\n      } // If we have the base connection, abort it\n      // Ignore abort errors, since we're closing\n\n\n      if (this.conn) {\n        try {\n          this.conn.source.abort();\n        } catch (_) {}\n\n        delete this.conn;\n      }\n\n      parallel(tasks, function () {\n        _this4._state('done');\n      });\n    }\n    /**\n     * Attempts to encrypt `this.conn` with the Switch's crypto.\n     *\n     * @private\n     * @fires ConnectionFSM#error\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onEncrypting\",\n    value: function _onEncrypting() {\n      var _this5 = this;\n\n      var msDialer = new multistream.Dialer();\n      msDialer.handle(this.conn, function (err) {\n        if (err) {\n          return _this5.close(maybeUnexpectedEnd(err));\n        }\n\n        _this5.log('selecting crypto %s to %s', _this5.switch.crypto.tag, _this5.theirB58Id);\n\n        msDialer.select(_this5.switch.crypto.tag, function (err, _conn) {\n          if (err) {\n            return _this5.close(maybeUnexpectedEnd(err));\n          }\n\n          var observedConn = observeConnection(null, _this5.switch.crypto.tag, _conn, _this5.switch.observer);\n\n          var encryptedConn = _this5.switch.crypto.encrypt(_this5.ourPeerInfo.id, observedConn, _this5.theirPeerInfo.id, function (err) {\n            if (err) {\n              return _this5.close(err);\n            }\n\n            _this5.conn = encryptedConn;\n\n            _this5.conn.setPeerInfo(_this5.theirPeerInfo);\n\n            _this5._state('done');\n          });\n        });\n      });\n    }\n    /**\n     * Iterates over each Muxer on the Switch and attempts to upgrade\n     * the given `connection`. Successful muxed connections will be stored\n     * on the Switch.muxedConns with `b58Id` as their key for future reference.\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onUpgrading\",\n    value: function _onUpgrading() {\n      var _this6 = this;\n\n      var muxers = Object.keys(this.switch.muxers);\n      this.log('upgrading connection to %s', this.theirB58Id);\n\n      if (muxers.length === 0) {\n        return this._state('stop');\n      }\n\n      var msDialer = new multistream.Dialer();\n      msDialer.handle(this.conn, function (err) {\n        if (err) {\n          return _this6._didUpgrade(err);\n        } // 1. try to handshake in one of the muxers available\n        // 2. if succeeds\n        //  - add the muxedConn to the list of muxedConns\n        //  - add incomming new streams to connHandler\n\n\n        var nextMuxer = function nextMuxer(key) {\n          _this6.log('selecting %s', key);\n\n          msDialer.select(key, function (err, _conn) {\n            if (err) {\n              if (muxers.length === 0) {\n                return _this6._didUpgrade(err);\n              }\n\n              return nextMuxer(muxers.shift());\n            } // observe muxed connections\n\n\n            var conn = observeConnection(null, key, _conn, _this6.switch.observer);\n            _this6.muxer = _this6.switch.muxers[key].dialer(conn);\n\n            _this6.muxer.once('close', function () {\n              _this6.close();\n            }); // For incoming streams, in case identify is on\n\n\n            _this6.muxer.on('stream', function (conn) {\n              _this6.log('new stream created via muxer to %s', _this6.theirB58Id);\n\n              conn.setPeerInfo(_this6.theirPeerInfo);\n\n              _this6.switch.protocolMuxer(null)(conn);\n            });\n\n            _this6._didUpgrade(null); // Run identify on the connection\n\n\n            if (_this6.switch.identify) {\n              _this6._identify(function (err, results) {\n                if (err) {\n                  return _this6.close(err);\n                }\n\n                _this6.theirPeerInfo = _this6.switch._peerBook.put(results.peerInfo);\n              });\n            }\n          });\n        };\n\n        nextMuxer(muxers.shift());\n      });\n    }\n    /**\n     * Runs the identify protocol on the connection\n     * @private\n     * @param {function(error, { PeerInfo })} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_identify\",\n    value: function _identify(callback) {\n      var _this7 = this;\n\n      if (!this.muxer) {\n        return nextTick(callback, errCode('The connection was already closed', 'ERR_CONNECTION_CLOSED'));\n      }\n\n      this.muxer.newStream(\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee(err, conn) {\n          var ms, results, msConn;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (!err) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\", callback(err));\n\n                case 2:\n                  ms = new multistream.Dialer();\n                  _context.prev = 3;\n                  _context.next = 6;\n                  return msHandle(ms, conn);\n\n                case 6:\n                  _context.next = 8;\n                  return msSelect(ms, identify.multicodec);\n\n                case 8:\n                  msConn = _context.sent;\n                  _context.next = 11;\n                  return identifyDialer(msConn, _this7.theirPeerInfo);\n\n                case 11:\n                  results = _context.sent;\n                  _context.next = 17;\n                  break;\n\n                case 14:\n                  _context.prev = 14;\n                  _context.t0 = _context[\"catch\"](3);\n                  return _context.abrupt(\"return\", callback(_context.t0));\n\n                case 17:\n                  callback(null, results);\n\n                case 18:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[3, 14]]);\n        }));\n\n        return function (_x, _x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }\n    /**\n     * Analyses the given error, if it exists, to determine where the state machine\n     * needs to go.\n     *\n     * @param {Error} err\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_didUpgrade\",\n    value: function _didUpgrade(err) {\n      if (err) {\n        this.log('Error upgrading connection:', err);\n        this.switch.conns[this.theirB58Id] = this;\n        this.emit('error:upgrade_failed', err); // Cant upgrade, hold the encrypted connection\n\n        return this._state('stop');\n      } // move the state machine forward\n\n\n      this._state('done');\n    }\n    /**\n     * Performs the protocol handshake for the given protocol\n     * over the given connection. The resulting error or connection\n     * will be returned via the callback.\n     *\n     * @private\n     * @param {string} protocol\n     * @param {Connection} connection\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_protocolHandshake\",\n    value: function _protocolHandshake(protocol, connection, callback) {\n      var _this8 = this;\n\n      var msDialer = new multistream.Dialer();\n      msDialer.handle(connection, function (err) {\n        if (err) {\n          return callback(err, null);\n        }\n\n        msDialer.select(protocol, function (err, _conn) {\n          if (err) {\n            _this8.log('could not perform protocol handshake:', err);\n\n            return callback(err, null);\n          }\n\n          var conn = observeConnection(null, protocol, _conn, _this8.switch.observer);\n\n          _this8.log('successfully performed handshake of %s to %s', protocol, _this8.theirB58Id);\n\n          _this8.emit('connection', conn);\n\n          callback(null, conn);\n        });\n      });\n    }\n    /**\n     * Event handler for state transition errors\n     *\n     * @param {Error} err\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onStateError\",\n    value: function _onStateError(err) {\n      this.emit('error', INVALID_STATE_TRANSITION(err));\n      this.log(err);\n    }\n  }]);\n\n  return ConnectionFSM;\n}(BaseConnection);\n\nmodule.exports = withIs(ConnectionFSM, {\n  className: 'ConnectionFSM',\n  symbolName: 'libp2p-switch/ConnectionFSM'\n});","map":null,"metadata":{},"sourceType":"script"}