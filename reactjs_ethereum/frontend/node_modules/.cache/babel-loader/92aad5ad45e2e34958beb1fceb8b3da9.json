{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Connection = require('interface-connection').Connection;\n\nvar nextTick = require('async/nextTick');\n\nvar debug = require('debug');\n\nvar MULTIPLEX_CODEC = require('./codec');\n\nvar log = debug('libp2p-mplex:muxer');\nlog.err = debug('libp2p-mplex:muxer:error');\n\nfunction noop() {}\n\nvar MultiplexMuxer =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(MultiplexMuxer, _EventEmitter);\n\n  /**\n   * @constructor\n   * @param {Connection} conn\n   * @param {Mplex} multiplex\n   */\n  function MultiplexMuxer(conn, multiplex) {\n    var _this;\n\n    _classCallCheck(this, MultiplexMuxer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MultiplexMuxer).call(this));\n    _this.conn = conn;\n    _this.multiplex = multiplex;\n    _this.multicodec = MULTIPLEX_CODEC;\n    multiplex.on('close', function () {\n      return _this.emit('close');\n    });\n    multiplex.on('error', function (err) {\n      return _this.emit('error', err);\n    });\n    multiplex.on('stream', function (stream) {\n      // install default error handler so that it doesn't throw\n      stream.on('error', function (err) {\n        log.err('receiver stream errored', err);\n      });\n\n      _this.emit('stream', new Connection(stream, _this.conn));\n    });\n    return _this;\n  }\n  /**\n   * Creates a new stream from the `Connection` used in creating the muxer\n   * @param {function(Error, Connection)} callback\n   * @returns {Connection}\n   */\n\n\n  _createClass(MultiplexMuxer, [{\n    key: \"newStream\",\n    value: function newStream(callback) {\n      callback = callback || noop;\n      var stream = this.multiplex.createStream(); // install default error handler so that it doesn't throw\n\n      stream.on('error', function (err) {\n        log.err('initiator stream errored', err);\n      });\n      var conn = new Connection(stream, this.conn);\n      nextTick(callback, null, conn);\n      return conn;\n    }\n    /**\n     * Ends the connection and all of its streams\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"end\",\n    value: function end(callback) {\n      callback = callback || noop;\n\n      if (this.multiplex.destroyed) {\n        return nextTick(callback);\n      }\n\n      this.multiplex.once('close', callback);\n      this.multiplex.close();\n    }\n  }]);\n\n  return MultiplexMuxer;\n}(EventEmitter);\n\nmodule.exports = MultiplexMuxer;","map":null,"metadata":{},"sourceType":"script"}