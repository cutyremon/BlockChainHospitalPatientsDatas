{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar CID = require('cids');\n\nvar log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar _require2 = require('./hamt-utils'),\n    generatePath = _require2.generatePath,\n    updateHamtDirectory = _require2.updateHamtDirectory;\n\nvar errCode = require('err-code');\n\nvar mc = require('multicodec');\n\nvar mh = require('multihashes');\n\nvar removeLink =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(context, options) {\n    var meta;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(!options.parentCid && !options.parent)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n\n          case 2:\n            if (!(options.parentCid && !CID.isCID(options.parentCid))) {\n              _context.next = 4;\n              break;\n            }\n\n            throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n\n          case 4:\n            if (options.parent) {\n              _context.next = 9;\n              break;\n            }\n\n            log(\"Loading parent node \".concat(options.parentCid));\n            _context.next = 8;\n            return context.ipld.get(options.parentCid);\n\n          case 8:\n            options.parent = _context.sent;\n\n          case 9:\n            if (options.name) {\n              _context.next = 11;\n              break;\n            }\n\n            throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n\n          case 11:\n            meta = UnixFS.unmarshal(options.parent.Data);\n\n            if (!(meta.type === 'hamt-sharded-directory')) {\n              _context.next = 15;\n              break;\n            }\n\n            log(\"Removing \".concat(options.name, \" from sharded directory\"));\n            return _context.abrupt(\"return\", removeFromShardedDirectory(context, options));\n\n          case 15:\n            log(\"Removing link \".concat(options.name, \" regular directory\"));\n            return _context.abrupt(\"return\", removeFromDirectory(context, options));\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function removeLink(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar removeFromDirectory =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(context, options) {\n    var format, hashAlg, newParentNode, cid;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            format = mc[options.format.toUpperCase().replace(/-/g, '_')];\n            hashAlg = mh.names[options.hashAlg];\n            _context2.next = 4;\n            return DAGNode.rmLink(options.parent, options.name);\n\n          case 4:\n            newParentNode = _context2.sent;\n            _context2.next = 7;\n            return context.ipld.put(newParentNode, format, {\n              cidVersion: options.cidVersion,\n              hashAlg: hashAlg\n            });\n\n          case 7:\n            cid = _context2.sent;\n            log(\"Updated regular directory \".concat(cid));\n            return _context2.abrupt(\"return\", {\n              node: newParentNode,\n              cid: cid\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function removeFromDirectory(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar removeFromShardedDirectory =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(context, options) {\n    var _ref4, rootBucket, path, _ref5, node;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return generatePath(context, options.name, options.parent);\n\n          case 2:\n            _ref4 = _context3.sent;\n            rootBucket = _ref4.rootBucket;\n            path = _ref4.path;\n            _context3.next = 7;\n            return rootBucket.del(options.name);\n\n          case 7:\n            _context3.next = 9;\n            return updateShard(context, path, {\n              name: options.name,\n              cid: options.cid,\n              size: options.size,\n              hashAlg: options.hashAlg,\n              format: options.format,\n              cidVersion: options.cidVersion,\n              flush: options.flush\n            }, options);\n\n          case 9:\n            _ref5 = _context3.sent;\n            node = _ref5.node;\n            return _context3.abrupt(\"return\", updateHamtDirectory(context, node.Links, rootBucket, options));\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function removeFromShardedDirectory(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar updateShard =\n/*#__PURE__*/\nfunction () {\n  var _ref6 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(context, positions, child, options) {\n    var _positions$pop, bucket, prefix, node, link, newNode, result, newName, size;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _positions$pop = positions.pop(), bucket = _positions$pop.bucket, prefix = _positions$pop.prefix, node = _positions$pop.node;\n            link = node.Links.find(function (link) {\n              return link.Name.substring(0, 2) === prefix;\n            });\n\n            if (link) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw errCode(new Error(\"No link found with prefix \".concat(prefix, \" for file \").concat(child.name)), 'ERR_NOT_FOUND');\n\n          case 4:\n            if (!(link.Name === \"\".concat(prefix).concat(child.name))) {\n              _context4.next = 12;\n              break;\n            }\n\n            log(\"Removing existing link \".concat(link.Name));\n            _context4.next = 8;\n            return DAGNode.rmLink(node, link.Name);\n\n          case 8:\n            newNode = _context4.sent;\n            _context4.next = 11;\n            return bucket.del(child.name);\n\n          case 11:\n            return _context4.abrupt(\"return\", updateHamtDirectory(context, newNode.Links, bucket, options));\n\n          case 12:\n            log(\"Descending into sub-shard \".concat(link.Name, \" for \").concat(prefix).concat(child.name));\n            _context4.next = 15;\n            return updateShard(context, positions, child, options);\n\n          case 15:\n            result = _context4.sent;\n            newName = prefix;\n\n            if (result.node.Links.length === 1) {\n              log(\"Removing subshard for \".concat(prefix)); // convert shard back to normal dir\n\n              result.cid = result.node.Links[0].Hash;\n              result.node = result.node.Links[0];\n              newName = \"\".concat(prefix).concat(result.node.Name.substring(2));\n            }\n\n            log(\"Updating shard \".concat(prefix, \" with name \").concat(newName));\n            size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;\n            return _context4.abrupt(\"return\", updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options));\n\n          case 21:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateShard(_x7, _x8, _x9, _x10) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar updateShardParent =\n/*#__PURE__*/\nfunction () {\n  var _ref7 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5(context, bucket, parent, oldName, newName, size, cid, options) {\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return DAGNode.rmLink(parent, oldName);\n\n          case 2:\n            parent = _context5.sent;\n            _context5.next = 5;\n            return DAGNode.addLink(parent, new DAGLink(newName, size, cid));\n\n          case 5:\n            parent = _context5.sent;\n            return _context5.abrupt(\"return\", updateHamtDirectory(context, parent.Links, bucket, options));\n\n          case 7:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function updateShardParent(_x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nmodule.exports = removeLink;","map":null,"metadata":{},"sourceType":"script"}