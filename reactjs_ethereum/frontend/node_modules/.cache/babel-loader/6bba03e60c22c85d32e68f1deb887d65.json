{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar PeerDistanceList = require('../peer-distance-list');\n\nvar EventEmitter = require('events');\n\nvar each = require('async/each');\n\nvar Path = require('./path');\n\nvar WorkerQueue = require('./workerQueue');\n\nvar utils = require('../utils');\n/**\n * Manages a single run of the query.\n */\n\n\nvar Run =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Run, _EventEmitter);\n\n  /**\n   * Creates a Run.\n   *\n   * @param {Query} query\n   */\n  function Run(query) {\n    var _this;\n\n    _classCallCheck(this, Run);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Run).call(this));\n    _this.query = query;\n    _this.running = false;\n    _this.workers = []; // The peers that have been queried (including error responses)\n\n    _this.peersSeen = new Set(); // The errors received when querying peers\n\n    _this.errors = []; // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n\n    _this.peersQueried = null;\n    return _this;\n  }\n  /**\n   * Stop all the workers\n   */\n\n\n  _createClass(Run, [{\n    key: \"stop\",\n    value: function stop() {\n      if (!this.running) {\n        return;\n      }\n\n      this.running = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.workers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var worker = _step.value;\n          worker.stop();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Execute the run with the given initial set of peers.\n     *\n     * @param {Array<PeerId>} peers\n     * @param {function(Error, Object)} callback\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(peers, callback) {\n      var _this2 = this;\n\n      var paths = []; // array of states per disjoint path\n      // Create disjoint paths\n\n      var numPaths = Math.min(this.query.dht.disjointPaths, peers.length);\n\n      for (var i = 0; i < numPaths; i++) {\n        paths.push(new Path(this, this.query.makePath(i, numPaths)));\n      } // Assign peers to paths round-robin style\n\n\n      peers.forEach(function (peer, i) {\n        paths[i % numPaths].addInitialPeer(peer);\n      }); // Execute the query along each disjoint path\n\n      this.executePaths(paths, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        var res = {\n          // The closest K peers we were able to query successfully\n          finalSet: new Set(_this2.peersQueried.peers),\n          paths: [] // Collect the results from each completed path\n\n        };\n        var _arr = paths;\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var path = _arr[_i];\n\n          if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n            path.res.success = true;\n            res.paths.push(path.res);\n          }\n        }\n\n        callback(err, res);\n      });\n    }\n    /**\n     * Execute all paths through the DHT.\n     *\n     * @param {Array<Path>} paths\n     * @param {function(Error)} callback\n     */\n\n  }, {\n    key: \"executePaths\",\n    value: function executePaths(paths, callback) {\n      var _this3 = this;\n\n      this.running = true;\n      this.emit('start');\n      each(paths, function (path, cb) {\n        return path.execute(cb);\n      }, function (err) {\n        // Ensure all workers are stopped\n        _this3.stop(); // Completed the Run\n\n\n        _this3.emit('complete');\n\n        if (err) {\n          return callback(err);\n        } // If all queries errored out, something is seriously wrong, so callback\n        // with an error\n\n\n        if (_this3.errors.length === _this3.peersSeen.size) {\n          return callback(_this3.errors[0]);\n        }\n\n        callback();\n      });\n    }\n    /**\n     * Initialize the list of queried peers, then start a worker queue for the\n     * given path.\n     *\n     * @param {Path} path\n     * @param {function(Error)} callback\n     */\n\n  }, {\n    key: \"workerQueue\",\n    value: function workerQueue(path, callback) {\n      var _this4 = this;\n\n      this.init(function () {\n        return _this4.startWorker(path, callback);\n      });\n    }\n    /**\n     * Create and start a worker queue for a particular path.\n     *\n     * @param {Path} path\n     * @param {function(Error)} callback\n     */\n\n  }, {\n    key: \"startWorker\",\n    value: function startWorker(path, callback) {\n      var worker = new WorkerQueue(this.query.dht, this, path, this.query._log);\n      this.workers.push(worker);\n      worker.execute(callback);\n    }\n    /**\n     * Initialize the list of closest peers we've queried - this is shared by all\n     * paths in the run.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(callback) {\n      var _this5 = this;\n\n      if (this.peersQueried) {\n        return callback();\n      } // We only want to initialize it once for the run, and then inform each\n      // path worker that it's ready\n\n\n      if (this.awaitingKey) {\n        this.awaitingKey.push(callback);\n        return;\n      }\n\n      this.awaitingKey = [callback]; // Convert the key into a DHT key by hashing it\n\n      utils.convertBuffer(this.query.key, function (err, dhtKey) {\n        _this5.peersQueried = new PeerDistanceList(dhtKey, _this5.query.dht.kBucketSize);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = _this5.awaitingKey[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var cb = _step2.value;\n            cb(err);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        _this5.awaitingKey = undefined;\n      });\n    }\n    /**\n     * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n     * are all further from the key than the peers we've already queried, then we should\n     * stop querying on that `worker`.\n     *\n     * @param {WorkerQueue} worker\n     * @param {function(Error, boolean)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"continueQuerying\",\n    value: function continueQuerying(worker, callback) {\n      // If we haven't queried K peers yet, keep going\n      if (this.peersQueried.length < this.peersQueried.capacity) {\n        return callback(null, true);\n      } // Get all the peers that are currently being queried.\n      // Note that this function gets called right after a peer has been popped\n      // off the head of the closest peers queue so it will include that peer.\n\n\n      var running = worker.queue.workersList().map(function (i) {\n        return i.data;\n      }); // Check if any of the peers that are currently being queried are closer\n      // to the key than the peers we've already queried\n\n      this.peersQueried.anyCloser(running, function (err, someCloser) {\n        if (err) {\n          return callback(err);\n        } // Some are closer, the worker should keep going\n\n\n        if (someCloser) {\n          return callback(null, true);\n        } // None are closer, the worker can stop\n\n\n        callback(null, false);\n      });\n    }\n  }]);\n\n  return Run;\n}(EventEmitter);\n\nmodule.exports = Run;","map":null,"metadata":{},"sourceType":"script"}