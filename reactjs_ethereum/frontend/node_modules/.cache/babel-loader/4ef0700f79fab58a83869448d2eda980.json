{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar mfs = require('ipfs-mfs/core');\n\nvar isPullStream = require('is-pull-stream');\n\nvar toPullStream = require('async-iterator-to-pull-stream');\n\nvar toReadableStream = require('async-iterator-to-stream');\n\nvar pullStreamToAsyncIterator = require('pull-stream-to-async-iterator');\n\nvar all = require('async-iterator-all');\n\nvar callbackify = require('callbackify');\n\nvar PassThrough = require('stream').PassThrough;\n\nvar pull = require('pull-stream/pull');\n\nvar map = require('pull-stream/throughs/map');\n\nvar mapLsFile = function mapLsFile() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var long = options.long || options.l;\n  return function (file) {\n    return {\n      hash: long ? file.cid.toBaseEncodedString(options.cidBase) : '',\n      name: file.name,\n      type: long ? file.type : 0,\n      size: long ? file.size || 0 : 0\n    };\n  };\n};\n\nmodule.exports = function (self) {\n  var methods = mfs({\n    ipld: self._ipld,\n    blocks: self._blockService,\n    datastore: self._repo.root,\n    repoOwner: self._options.repoOwner\n  });\n  return {\n    cp: callbackify.variadic(methods.cp),\n    flush: callbackify.variadic(methods.flush),\n    ls: callbackify.variadic(\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(path) {\n        var options,\n            files,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                _context.next = 3;\n                return all(methods.ls(path, options));\n\n              case 3:\n                files = _context.sent;\n                return _context.abrupt(\"return\", files.map(mapLsFile(options)));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()),\n    lsReadableStream: function lsReadableStream(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var stream = toReadableStream.obj(methods.ls(path, options));\n      var through = new PassThrough({\n        objectMode: true\n      });\n      stream.on('data', function (file) {\n        through.write(mapLsFile(options)(file));\n      });\n      stream.on('error', function (err) {\n        through.destroy(err);\n      });\n      stream.on('end', function (file, enc, cb) {\n        if (file) {\n          file = mapLsFile(options)(file);\n        }\n\n        through.end(file, enc, cb);\n      });\n      return through;\n    },\n    lsPullStream: function lsPullStream(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return pull(toPullStream.source(methods.ls(path, options)), map(mapLsFile(options)));\n    },\n    mkdir: callbackify.variadic(methods.mkdir),\n    mv: callbackify.variadic(methods.mv),\n    read: callbackify(\n    /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(path) {\n        var options,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                _context2.t0 = Buffer;\n                _context2.next = 4;\n                return all(methods.read(path, options));\n\n              case 4:\n                _context2.t1 = _context2.sent;\n                return _context2.abrupt(\"return\", _context2.t0.concat.call(_context2.t0, _context2.t1));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }()),\n    readPullStream: function readPullStream(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return toPullStream.source(methods.read(path, options));\n    },\n    readReadableStream: function readReadableStream(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return toReadableStream(methods.read(path, options));\n    },\n    rm: callbackify.variadic(methods.rm),\n    stat: callbackify(\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(path) {\n        var options,\n            stats,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                _context3.next = 3;\n                return methods.stat(path, options);\n\n              case 3:\n                stats = _context3.sent;\n                stats.hash = stats.cid.toBaseEncodedString(options && options.cidBase);\n                delete stats.cid;\n                return _context3.abrupt(\"return\", stats);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }()),\n    write: callbackify.variadic(\n    /*#__PURE__*/\n    function () {\n      var _ref4 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(path, content) {\n        var options,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n\n                if (isPullStream.isSource(content)) {\n                  content = pullStreamToAsyncIterator(content);\n                }\n\n                _context4.next = 4;\n                return methods.write(path, content, options);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x4, _x5) {\n        return _ref4.apply(this, arguments);\n      };\n    }())\n  };\n};","map":null,"metadata":{},"sourceType":"script"}