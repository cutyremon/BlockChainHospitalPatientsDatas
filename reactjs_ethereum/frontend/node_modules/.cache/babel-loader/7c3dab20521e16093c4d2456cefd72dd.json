{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar log = require('debug')('ipfs:mfs:stat');\n\nvar errCode = require('err-code');\n\nvar defaultOptions = {\n  withLocal: false\n};\n\nmodule.exports = function (context) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _mfsStat = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(path, options) {\n        var _ref, type, cid, mfsPath, exportPath, file;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = applyDefaultOptions(options, defaultOptions);\n                log(\"Fetching stats for \".concat(path));\n                _context.next = 4;\n                return toMfsPath(context, path);\n\n              case 4:\n                _ref = _context.sent;\n                type = _ref.type;\n                cid = _ref.cid;\n                mfsPath = _ref.mfsPath;\n                exportPath = type === 'ipfs' && cid ? cid : mfsPath;\n                _context.prev = 9;\n                _context.next = 12;\n                return exporter(exportPath, context.ipld);\n\n              case 12:\n                file = _context.sent;\n                _context.next = 20;\n                break;\n\n              case 15:\n                _context.prev = 15;\n                _context.t0 = _context[\"catch\"](9);\n\n                if (!(_context.t0.code === 'ERR_NOT_FOUND')) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw errCode(new Error(\"\".concat(path, \" does not exist\")), 'ERR_NOT_FOUND');\n\n              case 19:\n                throw _context.t0;\n\n              case 20:\n                if (statters[file.cid.codec]) {\n                  _context.next = 22;\n                  break;\n                }\n\n                throw new Error(\"Cannot stat codec \".concat(file.cid.codec));\n\n              case 22:\n                return _context.abrupt(\"return\", statters[file.cid.codec](file, options));\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[9, 15]]);\n      }));\n\n      function mfsStat(_x, _x2) {\n        return _mfsStat.apply(this, arguments);\n      }\n\n      return mfsStat;\n    }()\n  );\n};\n\nvar statters = {\n  raw: function raw(file) {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  'dag-pb': function dagPb(file) {\n    var blocks = file.node.Links.length;\n    var size = file.node.size;\n    var cumulativeSize = file.node.size;\n    var nodeType = null;\n\n    if (file.unixfs) {\n      size = file.unixfs.fileSize();\n      nodeType = file.unixfs.type;\n\n      if (nodeType.includes('directory')) {\n        size = 0;\n        cumulativeSize = file.node.size;\n      }\n\n      if (nodeType === 'file') {\n        blocks = file.unixfs.blockSizes.length;\n      }\n    }\n\n    return {\n      cid: file.cid,\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      type: nodeType,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"script"}