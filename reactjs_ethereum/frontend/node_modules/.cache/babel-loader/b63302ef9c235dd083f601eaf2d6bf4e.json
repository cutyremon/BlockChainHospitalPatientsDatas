{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar FSM = require('fsm-event');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar debug = require('debug');\n\nvar log = debug('libp2p');\nlog.error = debug('libp2p:error');\n\nvar errCode = require('err-code');\n\nvar each = require('async/each');\n\nvar series = require('async/series');\n\nvar parallel = require('async/parallel');\n\nvar PeerBook = require('peer-book');\n\nvar Switch = require('libp2p-switch');\n\nvar Ping = require('libp2p-ping');\n\nvar WebSockets = require('libp2p-websockets');\n\nvar ConnectionManager = require('libp2p-connection-manager');\n\nvar _require = require('./util'),\n    emitFirst = _require.emitFirst;\n\nvar peerRouting = require('./peer-routing');\n\nvar contentRouting = require('./content-routing');\n\nvar dht = require('./dht');\n\nvar pubsub = require('./pubsub');\n\nvar getPeerInfo = require('./get-peer-info');\n\nvar validateConfig = require('./config').validate;\n\nvar _require2 = require('./errors'),\n    codes = _require2.codes;\n\nvar notStarted = function notStarted(action, state) {\n  return errCode(new Error(\"libp2p cannot \".concat(action, \" when not started; state is \").concat(state)), codes.ERR_NODE_NOT_STARTED);\n};\n/**\n * @fires Node#error Emitted when an error occurs\n * @fires Node#peer:connect Emitted when a peer is connected to this node\n * @fires Node#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Node#peer:discovery Emitted when a peer is discovered\n * @fires Node#start Emitted when the node and its services has started\n * @fires Node#stop Emitted when the node and its services has stopped\n */\n\n\nvar Node =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Node, _EventEmitter);\n\n  function Node(_options) {\n    var _this;\n\n    _classCallCheck(this, Node);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this)); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    _this._options = validateConfig(_options);\n    _this.datastore = _this._options.datastore;\n    _this.peerInfo = _this._options.peerInfo;\n    _this.peerBook = _this._options.peerBook || new PeerBook();\n    _this._modules = _this._options.modules;\n    _this._config = _this._options.config;\n    _this._transport = []; // Transport instances/references\n\n    _this._discovery = []; // Discovery service instances/references\n    // create the switch, and listen for errors\n\n    _this._switch = new Switch(_this.peerInfo, _this.peerBook, _this._options.switch);\n\n    _this._switch.on('error', function () {\n      var _this2;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_this2 = _this).emit.apply(_this2, ['error'].concat(args));\n    });\n\n    _this.stats = _this._switch.stats;\n    _this.connectionManager = new ConnectionManager(_assertThisInitialized(_assertThisInitialized(_this)), _this._options.connectionManager); // Attach stream multiplexers\n\n    if (_this._modules.streamMuxer) {\n      var muxers = _this._modules.streamMuxer;\n      muxers.forEach(function (muxer) {\n        return _this._switch.connection.addStreamMuxer(muxer);\n      }); // If muxer exists\n      //   we can use Identify\n\n      _this._switch.connection.reuse(); //   we can use Relay for listening/dialing\n\n\n      _this._switch.connection.enableCircuitRelay(_this._config.relay); // Received incomming dial and muxer upgrade happened,\n      // reuse this muxed connection\n\n\n      _this._switch.on('peer-mux-established', function (peerInfo) {\n        _this.emit('peer:connect', peerInfo);\n      });\n\n      _this._switch.on('peer-mux-closed', function (peerInfo) {\n        _this.emit('peer:disconnect', peerInfo);\n      });\n    } // Events for anytime connections are created/removed\n\n\n    _this._switch.on('connection:start', function (peerInfo) {\n      _this.emit('connection:start', peerInfo);\n    });\n\n    _this._switch.on('connection:end', function (peerInfo) {\n      _this.emit('connection:end', peerInfo);\n    }); // Attach crypto channels\n\n\n    if (_this._modules.connEncryption) {\n      var cryptos = _this._modules.connEncryption;\n      cryptos.forEach(function (crypto) {\n        _this._switch.connection.crypto(crypto.tag, crypto.encrypt);\n      });\n    } // Attach private network protector\n\n\n    if (_this._modules.connProtector) {\n      _this._switch.protector = _this._modules.connProtector;\n    } else if (process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (_this._config.dht.enabled) {\n      var DHT = _this._modules.dht;\n      _this._dht = new DHT(_this._switch, _objectSpread({\n        datastore: _this.datastore\n      }, _this._config.dht));\n    } // enable/disable pubsub\n\n\n    if (_this._config.EXPERIMENTAL.pubsub) {\n      _this.pubsub = pubsub(_assertThisInitialized(_assertThisInitialized(_this)));\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    _this.peerRouting = peerRouting(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.contentRouting = contentRouting(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dht = dht(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._getPeerInfo = getPeerInfo(_assertThisInitialized(_assertThisInitialized(_this))); // Mount default protocols\n\n    Ping.mount(_this._switch);\n    _this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPED'\n      },\n      STARTING: {\n        done: 'STARTED',\n        abort: 'STOPPED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    });\n\n    _this.state.on('STARTING', function () {\n      log('libp2p is starting');\n\n      _this._onStarting();\n    });\n\n    _this.state.on('STOPPING', function () {\n      log('libp2p is stopping');\n\n      _this._onStopping();\n    });\n\n    _this.state.on('STARTED', function () {\n      log('libp2p has started');\n\n      _this.emit('start');\n    });\n\n    _this.state.on('STOPPED', function () {\n      log('libp2p has stopped');\n\n      _this.emit('stop');\n    });\n\n    _this.state.on('error', function (err) {\n      log.error(err);\n\n      _this.emit('error', err);\n    }); // Once we start, emit and dial any peers we may have already discovered\n\n\n    _this.state.on('STARTED', function () {\n      _this.peerBook.getAllArray().forEach(function (peerInfo) {\n        _this.emit('peer:discovery', peerInfo);\n\n        _this._maybeConnect(peerInfo);\n      });\n    });\n\n    _this._peerDiscovered = _this._peerDiscovered.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  _createClass(Node, [{\n    key: \"emit\",\n    value: function emit(eventName) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      if (eventName === 'error' && !this._events.error) {\n        log.error.apply(log, args);\n      } else {\n        var _get2;\n\n        (_get2 = _get(_getPrototypeOf(Node.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n    /**\n     * Starts the libp2p node and all sub services\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      emitFirst(this, ['error', 'start'], callback);\n      this.state('start');\n    }\n    /**\n     * Stop the libp2p node by closing its listeners and open connections\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      emitFirst(this, ['error', 'stop'], callback);\n      this.state('stop');\n    }\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.state ? this.state._state === 'STARTED' : false;\n    }\n    /**\n     * Dials to the provided peer. If successful, the `PeerInfo` of the\n     * peer will be added to the nodes `PeerBook`\n     *\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(peer, callback) {\n      this.dialProtocol(peer, null, callback);\n    }\n    /**\n     * Dials to the provided peer and handshakes with the given protocol.\n     * If successful, the `PeerInfo` of the peer will be added to the nodes `PeerBook`,\n     * and the `Connection` will be sent in the callback\n     *\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n     * @param {string} protocol\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dialProtocol\",\n    value: function dialProtocol(peer, protocol, callback) {\n      var _this3 = this;\n\n      if (!this.isStarted()) {\n        return callback(notStarted('dial', this.state._state));\n      }\n\n      if (typeof protocol === 'function') {\n        callback = protocol;\n        protocol = undefined;\n      }\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3._switch.dial(peerInfo, protocol, callback);\n      });\n    }\n    /**\n     * Similar to `dial` and `dialProtocol`, but the callback will contain a\n     * Connection State Machine.\n     *\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n     * @param {string} protocol\n     * @param {function(Error, ConnectionFSM)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dialFSM\",\n    value: function dialFSM(peer, protocol, callback) {\n      var _this4 = this;\n\n      if (!this.isStarted()) {\n        return callback(notStarted('dial', this.state._state));\n      }\n\n      if (typeof protocol === 'function') {\n        callback = protocol;\n        protocol = undefined;\n      }\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this4._switch.dialFSM(peerInfo, protocol, callback);\n      });\n    }\n  }, {\n    key: \"hangUp\",\n    value: function hangUp(peer, callback) {\n      var _this5 = this;\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this5._switch.hangUp(peerInfo, callback);\n      });\n    }\n  }, {\n    key: \"ping\",\n    value: function ping(peer, callback) {\n      var _this6 = this;\n\n      if (!this.isStarted()) {\n        return callback(notStarted('ping', this.state._state));\n      }\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, new Ping(_this6._switch, peerInfo));\n      });\n    }\n  }, {\n    key: \"handle\",\n    value: function handle(protocol, handlerFunc, matchFunc) {\n      this._switch.handle(protocol, handlerFunc, matchFunc);\n    }\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocol) {\n      this._switch.unhandle(protocol);\n    }\n  }, {\n    key: \"_onStarting\",\n    value: function _onStarting() {\n      var _this7 = this;\n\n      if (!this._modules.transport) {\n        this.emit('error', new Error('no transports were present'));\n        return this.state('abort');\n      }\n\n      var ws; // so that we can have webrtc-star addrs without adding manually the id\n\n      var maOld = [];\n      var maNew = [];\n      this.peerInfo.multiaddrs.toArray().forEach(function (ma) {\n        if (!ma.getPeerId()) {\n          maOld.push(ma);\n          maNew.push(ma.encapsulate('/p2p/' + _this7.peerInfo.id.toB58String()));\n        }\n      });\n      this.peerInfo.multiaddrs.replace(maOld, maNew);\n      var multiaddrs = this.peerInfo.multiaddrs.toArray();\n\n      this._modules.transport.forEach(function (Transport) {\n        var t;\n\n        if (typeof Transport === 'function') {\n          t = new Transport();\n        } else {\n          t = Transport;\n        }\n\n        if (t.filter(multiaddrs).length > 0) {\n          _this7._switch.transport.add(t.tag || t[Symbol.toStringTag], t);\n        } else if (WebSockets.isWebSockets(t)) {\n          // TODO find a cleaner way to signal that a transport is always used\n          // for dialing, even if no listener\n          ws = t;\n        }\n\n        _this7._transport.push(t);\n      });\n\n      series([function (cb) {\n        _this7.connectionManager.start();\n\n        _this7._switch.start(cb);\n      }, function (cb) {\n        if (ws) {\n          // always add dialing on websockets\n          _this7._switch.transport.add(ws.tag || ws.constructor.name, ws);\n        } // detect which multiaddrs we don't have a transport for and remove them\n\n\n        var multiaddrs = _this7.peerInfo.multiaddrs.toArray();\n\n        multiaddrs.forEach(function (multiaddr) {\n          if (!multiaddr.toString().match(/\\/p2p-circuit($|\\/)/) && !_this7._transport.find(function (transport) {\n            return transport.filter(multiaddr).length > 0;\n          })) {\n            _this7.peerInfo.multiaddrs.delete(multiaddr);\n          }\n        });\n        cb();\n      }, function (cb) {\n        if (_this7._dht) {\n          _this7._dht.start(function () {\n            _this7._dht.on('peer', _this7._peerDiscovered);\n\n            cb();\n          });\n        } else {\n          cb();\n        }\n      }, function (cb) {\n        if (_this7._floodSub) {\n          return _this7._floodSub.start(cb);\n        }\n\n        cb();\n      }, // Peer Discovery\n      function (cb) {\n        if (_this7._modules.peerDiscovery) {\n          _this7._setupPeerDiscovery(cb);\n        } else {\n          cb();\n        }\n      }], function (err) {\n        if (err) {\n          log.error(err);\n\n          _this7.emit('error', err);\n\n          return _this7.state('stop');\n        }\n\n        _this7.state('done');\n      });\n    }\n  }, {\n    key: \"_onStopping\",\n    value: function _onStopping() {\n      var _this8 = this;\n\n      series([function (cb) {\n        // stop all discoveries before continuing with shutdown\n        parallel(_this8._discovery.map(function (d) {\n          d.removeListener('peer', _this8._peerDiscovered);\n          return function (_cb) {\n            return d.stop(function (err) {\n              log.error('an error occurred stopping the discovery service', err);\n\n              _cb();\n            });\n          };\n        }), cb);\n      }, function (cb) {\n        if (_this8._floodSub) {\n          return _this8._floodSub.stop(cb);\n        }\n\n        cb();\n      }, function (cb) {\n        if (_this8._dht) {\n          _this8._dht.removeListener('peer', _this8._peerDiscovered);\n\n          return _this8._dht.stop(cb);\n        }\n\n        cb();\n      }, function (cb) {\n        _this8.connectionManager.stop();\n\n        _this8._switch.stop(cb);\n      }, function (cb) {\n        // Ensures idempotent restarts, ignore any errors\n        // from removeAll, they're not useful at this point\n        _this8._switch.transport.removeAll(function () {\n          return cb();\n        });\n      }], function (err) {\n        if (err) {\n          log.error(err);\n\n          _this8.emit('error', err);\n        }\n\n        _this8.state('done');\n      });\n    }\n    /**\n     * Handles discovered peers. Each discovered peer will be emitted via\n     * the `peer:discovery` event. If auto dial is enabled for libp2p\n     * and the current connection count is under the low watermark, the\n     * peer will be dialed.\n     *\n     * TODO: If `peerBook.put` becomes centralized, https://github.com/libp2p/js-libp2p/issues/345,\n     * it would be ideal if only new peers were emitted. Currently, with\n     * other modules adding peers to the `PeerBook` we have no way of knowing\n     * if a peer is new or not, so it has to be emitted.\n     *\n     * @private\n     * @param {PeerInfo} peerInfo\n     */\n\n  }, {\n    key: \"_peerDiscovered\",\n    value: function _peerDiscovered(peerInfo) {\n      if (peerInfo.id.toB58String() === this.peerInfo.id.toB58String()) {\n        log.error(new Error(codes.ERR_DISCOVERED_SELF));\n        return;\n      }\n\n      peerInfo = this.peerBook.put(peerInfo);\n      if (!this.isStarted()) return;\n      this.emit('peer:discovery', peerInfo);\n\n      this._maybeConnect(peerInfo);\n    }\n    /**\n     * Will dial to the given `peerInfo` if the current number of\n     * connected peers is less than the configured `ConnectionManager`\n     * minPeers.\n     * @private\n     * @param {PeerInfo} peerInfo\n     */\n\n  }, {\n    key: \"_maybeConnect\",\n    value: function _maybeConnect(peerInfo) {\n      // If auto dialing is on, check if we should dial\n      if (this._config.peerDiscovery.autoDial === true && !peerInfo.isConnected()) {\n        var minPeers = this._options.connectionManager.minPeers || 0;\n\n        if (minPeers > Object.keys(this._switch.connection.connections).length) {\n          log('connecting to discovered peer');\n\n          this._switch.dialer.connect(peerInfo, function (err) {\n            err && log.error('could not connect to discovered peer', err);\n          });\n        }\n      }\n    }\n    /**\n     * Initializes and starts peer discovery services\n     *\n     * @private\n     * @param {function(Error)} callback\n     */\n\n  }, {\n    key: \"_setupPeerDiscovery\",\n    value: function _setupPeerDiscovery(callback) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._modules.peerDiscovery[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var DiscoveryService = _step.value;\n          var config = {\n            enabled: true // on by default\n\n          };\n\n          if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {\n            config = _objectSpread({}, config, this._config.peerDiscovery[DiscoveryService.tag]);\n          }\n\n          if (config.enabled) {\n            var discoveryService = void 0;\n\n            if (typeof DiscoveryService === 'function') {\n              discoveryService = new DiscoveryService(Object.assign({}, config, {\n                peerInfo: this.peerInfo\n              }));\n            } else {\n              discoveryService = DiscoveryService;\n            }\n\n            discoveryService.on('peer', this._peerDiscovered);\n\n            this._discovery.push(discoveryService);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      each(this._discovery, function (d, cb) {\n        d.start(cb);\n      }, callback);\n    }\n  }]);\n\n  return Node;\n}(EventEmitter);\n\nmodule.exports = Node;","map":null,"metadata":{},"sourceType":"script"}