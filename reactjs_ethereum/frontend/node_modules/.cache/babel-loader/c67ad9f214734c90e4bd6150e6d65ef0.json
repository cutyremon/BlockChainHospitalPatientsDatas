{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ConnectionFSM = require('../connection');\n\nvar _require = require('../errors'),\n    DIAL_ABORTED = _require.DIAL_ABORTED,\n    ERR_BLACKLISTED = _require.ERR_BLACKLISTED;\n\nvar nextTick = require('async/nextTick');\n\nvar once = require('once');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:dial');\nlog.error = debug('libp2p:switch:dial:error');\n/**\n * Components required to execute a dial\n * @typedef {Object} DialRequest\n * @property {PeerInfo} peerInfo - The peer to dial to\n * @property {string} [protocol] - The protocol to create a stream for\n * @property {object} options\n * @property {boolean} options.useFSM - If `callback` should return a ConnectionFSM\n * @property {number} options.priority - The priority of the dial\n * @property {function(Error, Connection|ConnectionFSM)} callback\n */\n\n/**\n * @typedef {Object} NewConnection\n * @property {ConnectionFSM} connectionFSM\n * @property {boolean} didCreate\n */\n\n/**\n * Attempts to create a new connection or stream (when muxed),\n * via negotiation of the given `protocol`. If no `protocol` is\n * provided, no action will be taken and `callback` will be called\n * immediately with no error or values.\n *\n * @param {object} options\n * @param {string} options.protocol\n * @param {ConnectionFSM} options.connection\n * @param {function(Error, Connection)} options.callback\n * @returns {void}\n */\n\nfunction createConnectionWithProtocol(_ref) {\n  var protocol = _ref.protocol,\n      connection = _ref.connection,\n      callback = _ref.callback;\n\n  if (!protocol) {\n    return callback();\n  }\n\n  connection.shake(protocol, function (err, conn) {\n    if (!conn) {\n      return callback(err);\n    }\n\n    conn.setPeerInfo(connection.theirPeerInfo);\n    callback(null, conn);\n  });\n}\n/**\n * A convenience array wrapper for controlling\n * a per peer queue\n *\n * @returns {Queue}\n */\n\n\nvar Queue =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {string} peerId\n   * @param {Switch} _switch\n   * @param {function(string)} onStopped Called when the queue stops\n   */\n  function Queue(peerId, _switch, onStopped) {\n    _classCallCheck(this, Queue);\n\n    this.id = peerId;\n    this.switch = _switch;\n    this._queue = [];\n    this.blackListed = null;\n    this.blackListCount = 0;\n    this.isRunning = false;\n    this.onStopped = onStopped;\n  }\n\n  _createClass(Queue, [{\n    key: \"add\",\n\n    /**\n     * Adds the dial request to the queue. The queue is not automatically started\n     * @param {string} protocol\n     * @param {boolean} useFSM If callback should use a ConnectionFSM instead\n     * @param {function(Error, Connection)} callback\n     */\n    value: function add(protocol, useFSM, callback) {\n      if (!this.isDialAllowed()) {\n        nextTick(callback, ERR_BLACKLISTED());\n      }\n\n      this._queue.push({\n        protocol: protocol,\n        useFSM: useFSM,\n        callback: callback\n      });\n    }\n    /**\n     * Determines whether or not dialing is currently allowed\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isDialAllowed\",\n    value: function isDialAllowed() {\n      if (this.blackListed) {\n        // If the blacklist ttl has passed, reset it\n        if (Date.now() > this.blackListed) {\n          this.blackListed = null;\n          return true;\n        } // Dial is not allowed\n\n\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Starts the queue. If the queue was started `true` will be returned.\n     * If the queue was already running `false` is returned.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (!this.isRunning) {\n        log('starting dial queue to %s', this.id);\n        this.isRunning = true;\n\n        this._run();\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Stops the queue\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.isRunning) {\n        log('stopping dial queue to %s', this.id);\n        this.isRunning = false;\n        this.onStopped(this.id);\n      }\n    }\n    /**\n     * Stops the queue and errors the callback for each dial request\n     */\n\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      while (this.length > 0) {\n        var dial = this._queue.shift();\n\n        dial.callback(DIAL_ABORTED());\n      }\n\n      this.stop();\n    }\n    /**\n     * Marks the queue as blacklisted. The queue will be immediately aborted.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"blacklist\",\n    value: function blacklist() {\n      this.blackListCount++;\n\n      if (this.blackListCount >= this.switch.dialer.BLACK_LIST_ATTEMPTS) {\n        this.blackListed = Infinity;\n        return;\n      }\n\n      var ttl = this.switch.dialer.BLACK_LIST_TTL * Math.pow(this.blackListCount, 3);\n      var minTTL = ttl * 0.9;\n      var maxTTL = ttl * 1.1; // Add a random jitter of 20% to the ttl\n\n      ttl = Math.floor(Math.random() * (maxTTL - minTTL) + minTTL);\n      this.blackListed = Date.now() + ttl;\n      this.abort();\n    }\n    /**\n     * Attempts to find a muxed connection for the given peer. If one\n     * isn't found, a new one will be created.\n     *\n     * Returns an array containing two items. The ConnectionFSM and wether\n     * or not the ConnectionFSM was just created. The latter can be used\n     * to determine dialing needs.\n     *\n     * @private\n     * @param {PeerInfo} peerInfo\n     * @returns {NewConnection}\n     */\n\n  }, {\n    key: \"_getOrCreateConnection\",\n    value: function _getOrCreateConnection(peerInfo) {\n      var connectionFSM = this.switch.connection.getOne(this.id);\n      var didCreate = false;\n\n      if (!connectionFSM) {\n        connectionFSM = new ConnectionFSM({\n          _switch: this.switch,\n          peerInfo: peerInfo,\n          muxer: null,\n          conn: null\n        });\n        this.switch.connection.add(connectionFSM); // Add control events and start the dialer\n\n        connectionFSM.once('connected', function () {\n          return connectionFSM.protect();\n        });\n        connectionFSM.once('private', function () {\n          return connectionFSM.encrypt();\n        });\n        connectionFSM.once('encrypted', function () {\n          return connectionFSM.upgrade();\n        });\n        didCreate = true;\n      }\n\n      return {\n        connectionFSM: connectionFSM,\n        didCreate: didCreate\n      };\n    }\n    /**\n     * Executes the next dial in the queue for the given peer\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_run\",\n    value: function _run() {\n      var _this = this;\n\n      // If we have no items in the queue or we're stopped, exit\n      if (this.length < 1 || !this.isRunning) {\n        log('stopping the queue for %s', this.id);\n        return this.stop();\n      }\n\n      var next = once(function () {\n        log('starting next dial to %s', _this.id);\n\n        _this._run();\n      });\n\n      var peerInfo = this.switch._peerBook.get(this.id);\n\n      var queuedDial = this._queue.shift();\n\n      var _this$_getOrCreateCon = this._getOrCreateConnection(peerInfo),\n          connectionFSM = _this$_getOrCreateCon.connectionFSM,\n          didCreate = _this$_getOrCreateCon.didCreate; // If the dial expects a ConnectionFSM, we can provide that back now\n\n\n      if (queuedDial.useFSM) {\n        nextTick(queuedDial.callback, null, connectionFSM);\n      } // If we can handshake protocols, get a new stream and call run again\n\n\n      if (['MUXED', 'CONNECTED'].includes(connectionFSM.getState())) {\n        queuedDial.connection = connectionFSM;\n        createConnectionWithProtocol(queuedDial);\n        next();\n        return;\n      } // If we error, error the queued dial\n      // In the future, it may be desired to error the other queued dials,\n      // depending on the error.\n\n\n      connectionFSM.once('error', function (err) {\n        queuedDial.callback(err); // Dont blacklist peers we have identified and that we are connected to\n\n        if (peerInfo.protocols.size > 0 && peerInfo.isConnected()) {\n          return;\n        }\n\n        _this.blacklist();\n      });\n      connectionFSM.once('close', function () {\n        next();\n      }); // If we're not muxed yet, add listeners\n\n      connectionFSM.once('muxed', function () {\n        _this.blackListCount = 0; // reset blacklisting on good connections\n\n        queuedDial.connection = connectionFSM;\n        createConnectionWithProtocol(queuedDial);\n        next();\n      });\n      connectionFSM.once('unmuxed', function () {\n        _this.blackListCount = 0;\n        queuedDial.connection = connectionFSM;\n        createConnectionWithProtocol(queuedDial);\n        next();\n      }); // If we have a new connection, start dialing\n\n      if (didCreate) {\n        connectionFSM.dial();\n      }\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._queue.length;\n    }\n  }]);\n\n  return Queue;\n}();\n\nmodule.exports = Queue;","map":null,"metadata":{},"sourceType":"script"}