{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PeerId = require('peer-id');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar series = require('async/series');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:publisher');\nlog.error = debug('ipfs:ipns:publisher:error');\n\nvar ipns = require('ipns');\n\nvar defaultRecordTtl = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nvar IpnsPublisher =\n/*#__PURE__*/\nfunction () {\n  function IpnsPublisher(routing, datastore) {\n    _classCallCheck(this, IpnsPublisher);\n\n    this._routing = routing;\n    this._datastore = datastore;\n  } // publish record with a eol\n\n\n  _createClass(IpnsPublisher, [{\n    key: \"publishWithEOL\",\n    value: function publishWithEOL(privKey, value, lifetime, callback) {\n      var _this = this;\n\n      if (!privKey || !privKey.bytes) {\n        var errMsg = \"one or more of the provided parameters are not defined\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'));\n      }\n\n      PeerId.createFromPrivKey(privKey.bytes, function (err, peerId) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this._updateOrCreateRecord(privKey, value, lifetime, peerId, function (err, record) {\n          if (err) {\n            return callback(err);\n          }\n\n          _this._putRecordToRouting(record, peerId, callback);\n        });\n      });\n    } // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n\n  }, {\n    key: \"publish\",\n    value: function publish(privKey, value, callback) {\n      this.publishWithEOL(privKey, value, defaultRecordTtl, callback);\n    }\n  }, {\n    key: \"_putRecordToRouting\",\n    value: function _putRecordToRouting(record, peerId, callback) {\n      var _this2 = this;\n\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      var publicKey = peerId._pubKey;\n      ipns.embedPublicKey(publicKey, record, function (err, embedPublicKeyRecord) {\n        if (err) {\n          return callback(err);\n        }\n\n        var keys;\n\n        try {\n          keys = ipns.getIdKeys(peerId.toBytes());\n        } catch (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        series([function (cb) {\n          return _this2._publishEntry(keys.routingKey, embedPublicKeyRecord || record, peerId, cb);\n        }, // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n        // We will be able to deprecate this part in the future, since the public keys will be only\n        // in IPNS record and the peerId.\n        function (cb) {\n          return _this2._publishPublicKey(keys.routingPubKey, publicKey, peerId, cb);\n        }], function (err) {\n          if (err) {\n            log.error(err);\n            return callback(err);\n          }\n\n          callback(null, embedPublicKeyRecord || record);\n        });\n      });\n    }\n  }, {\n    key: \"_publishEntry\",\n    value: function _publishEntry(key, entry, peerId, callback) {\n      if (!Key.isKey(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      var entryData;\n\n      try {\n        // Marshal record\n        entryData = ipns.marshal(entry);\n      } catch (err) {\n        log.error(err);\n        return callback(err);\n      } // Add record to routing (buffer key)\n\n\n      this._routing.put(key.toBuffer(), entryData, function (err, res) {\n        if (err) {\n          var _errMsg = \"ipns record for \".concat(key.toString(), \" could not be stored in the routing\");\n\n          log.error(_errMsg);\n          return callback(errcode(new Error(_errMsg), 'ERR_PUTTING_TO_ROUTING'));\n        }\n\n        log(\"ipns record for \".concat(key.toString(), \" was stored in the routing\"));\n        callback(null, res);\n      });\n    }\n  }, {\n    key: \"_publishPublicKey\",\n    value: function _publishPublicKey(key, publicKey, peerId, callback) {\n      if (!Key.isKey(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      if (!publicKey || !publicKey.bytes) {\n        var _errMsg2 = \"one or more of the provided parameters are not defined\";\n        log.error(_errMsg2);\n        return callback(errcode(new Error(_errMsg2), 'ERR_UNDEFINED_PARAMETER'));\n      } // Add public key to routing (buffer key)\n\n\n      this._routing.put(key.toBuffer(), publicKey.bytes, function (err, res) {\n        if (err) {\n          var _errMsg3 = \"public key for \".concat(key.toString(), \" could not be stored in the routing\");\n\n          log.error(_errMsg3);\n          return callback(errcode(new Error(_errMsg3), 'ERR_PUTTING_TO_ROUTING'));\n        }\n\n        log(\"public key for \".concat(key.toString(), \" was stored in the routing\"));\n        callback(null, res);\n      });\n    } // Returns the record this node has published corresponding to the given peer ID.\n    // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n\n  }, {\n    key: \"_getPublished\",\n    value: function _getPublished(peerId, options, callback) {\n      var _this3 = this;\n\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      options = options || {};\n      var checkRouting = options.checkRouting !== false;\n\n      this._datastore.get(ipns.getLocalKey(peerId.id), function (err, dsVal) {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg4 = \"unexpected error getting the ipns record \".concat(peerId.id, \" from datastore\");\n\n            log.error(_errMsg4);\n            return callback(errcode(new Error(_errMsg4), 'ERR_UNEXPECTED_DATASTORE_RESPONSE'));\n          }\n\n          if (!checkRouting) {\n            return callback(errcode(err));\n          } // Try to get from routing\n\n\n          var keys;\n\n          try {\n            keys = ipns.getIdKeys(peerId.toBytes());\n          } catch (err) {\n            log.error(err);\n            return callback(err);\n          }\n\n          _this3._routing.get(keys.routingKey.toBuffer(), function (err, res) {\n            if (err) {\n              return callback(err);\n            } // unmarshal data\n\n\n            _this3._unmarshalData(res, callback);\n          });\n        } else {\n          // unmarshal data\n          _this3._unmarshalData(dsVal, callback);\n        }\n      });\n    }\n  }, {\n    key: \"_unmarshalData\",\n    value: function _unmarshalData(data, callback) {\n      var result;\n\n      try {\n        result = ipns.unmarshal(data);\n      } catch (err) {\n        log.error(err);\n        return callback(errcode(err, 'ERR_INVALID_RECORD_DATA'));\n      }\n\n      callback(null, result);\n    }\n  }, {\n    key: \"_updateOrCreateRecord\",\n    value: function _updateOrCreateRecord(privKey, value, validity, peerId, callback) {\n      var _this4 = this;\n\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      var getPublishedOptions = {\n        checkRouting: true\n      };\n\n      this._getPublished(peerId, getPublishedOptions, function (err, record) {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg5 = \"unexpected error when determining the last published IPNS record for \".concat(peerId.id);\n\n            log.error(_errMsg5);\n            return callback(errcode(new Error(_errMsg5), 'ERR_DETERMINING_PUBLISHED_RECORD'));\n          }\n        } // Determinate the record sequence number\n\n\n        var seqNumber = 0;\n\n        if (record && record.sequence !== undefined) {\n          seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence;\n        } // Create record\n\n\n        ipns.create(privKey, value, seqNumber, validity, function (err, entryData) {\n          if (err) {\n            var _errMsg6 = \"ipns record for \".concat(value, \" could not be created\");\n\n            log.error(_errMsg6);\n            return callback(errcode(new Error(_errMsg6), 'ERR_CREATING_IPNS_RECORD'));\n          } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n          // Marshal record\n\n\n          var data = ipns.marshal(entryData); // Store the new record\n\n          _this4._datastore.put(ipns.getLocalKey(peerId.id), data, function (err, res) {\n            if (err) {\n              var _errMsg7 = \"ipns record for \".concat(value, \" could not be stored in the datastore\");\n\n              log.error(_errMsg7);\n              return callback(errcode(new Error(_errMsg7), 'ERR_STORING_IN_DATASTORE'));\n            }\n\n            log(\"ipns record for \".concat(value, \" was stored in the datastore\"));\n            callback(null, entryData);\n          });\n        });\n      });\n    }\n  }]);\n\n  return IpnsPublisher;\n}();\n\nexports = module.exports = IpnsPublisher;","map":null,"metadata":{},"sourceType":"script"}