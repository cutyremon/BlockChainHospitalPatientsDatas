{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:websocket-star:multi');\n\nvar once = require('once');\n\nvar EE = require('events').EventEmitter;\n\nvar map = require('async/map');\n\nvar parallel = require('async/parallel');\n\nvar multiaddr = require('multiaddr');\n\nvar mafmt = require('mafmt');\n\nvar WSStar = require('libp2p-websocket-star');\n\nvar WebsocketStarMulti =\n/*#__PURE__*/\nfunction () {\n  // listen on multiple websocket star servers without having to worry about one being down.\n  // NOTE: if no servers are reachable or provided an error is thrown\n  function WebsocketStarMulti(opt) {\n    _classCallCheck(this, WebsocketStarMulti);\n\n    this.opt = opt || {};\n    this.servers = opt.servers || [];\n    this.ws = new WSStar(this.opt);\n    this.discovery = this.ws.discovery;\n  }\n\n  _createClass(WebsocketStarMulti, [{\n    key: \"dial\",\n    value: function dial(ma, opt, cb) {\n      log('dial', ma);\n      return this.ws.dial(ma, opt, cb);\n    }\n  }, {\n    key: \"createListener\",\n    value: function createListener(options, handler) {\n      var _this = this;\n\n      if (typeof options === 'function') {\n        handler = options;\n        options = {};\n      }\n\n      var listener = new EE();\n      listener.servers = {};\n      listener.online = [];\n      this.servers.forEach(function (ser) {\n        var s = _this.ws.createListener(options, handler);\n\n        s.once('error', function () {});\n        s.url = ser;\n        listener.servers[ser] = s;\n      });\n\n      listener.listen = function (ma, cb) {\n        var id = ma.toString().split('ipfs/').pop();\n        log('listen on %s server(s) with id %s', _this.servers.length, id);\n        parallel(_this.servers.map(function (url) {\n          return listener.servers[url];\n        }).map(function (server) {\n          return function (cb) {\n            log('listen %s', server.url);\n            var next = once(function (err) {\n              log('listen %s ok %s', server.url, !err);\n              if (err) return cb(log(err));\n              listener.online.push(server);\n              return cb();\n            });\n            setTimeout(next, _this.opt.timeout || 5000, new Error('Timeout'));\n            server.listen(multiaddr(server.url).encapsulate('/ipfs/' + id), next);\n          };\n        }), function () {\n          if (!listener.online.length && !_this.opt.ignore_no_online) {\n            var e = new Error(\"Couldn't listen on any of the servers\");\n            listener.emit('error', e);\n            cb(e);\n          } else {\n            listener.emit('listening');\n            cb();\n          }\n        });\n      };\n\n      listener.close = function (cb) {\n        return parallel(listener.online.map(function (s) {\n          return function (cb) {\n            return s.close(cb);\n          };\n        }), function (err) {\n          return cb(err, listener.online = []);\n        });\n      };\n\n      listener.getAddrs = function (cb) {\n        return map(listener.online, function (s, n) {\n          return s.getAddrs(n);\n        }, function (err, res) {\n          if (err) return cb(err);\n          return cb(null, res.reduce(function (a, b) {\n            return a.concat(b);\n          }, []));\n        });\n      };\n\n      return listener;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(ma) {\n      if (!Array.isArray(ma)) ma = [ma];\n      return ma.filter(function (ma) {\n        return ma.toString().startsWith('/p2p-websocket-star') || mafmt.WebSocketStar.matches(ma);\n      });\n    }\n  }]);\n\n  return WebsocketStarMulti;\n}();\n\nmodule.exports = WebsocketStarMulti;","map":null,"metadata":{},"sourceType":"script"}