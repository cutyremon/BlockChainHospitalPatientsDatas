{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar FSM = require('fsm-event');\n\nvar multistream = require('multistream-select');\n\nvar withIs = require('class-is');\n\nvar BaseConnection = require('./base');\n\nvar IncomingConnectionFSM =\n/*#__PURE__*/\nfunction (_BaseConnection) {\n  _inherits(IncomingConnectionFSM, _BaseConnection);\n\n  function IncomingConnectionFSM(_ref) {\n    var _this;\n\n    var connection = _ref.connection,\n        _switch = _ref._switch,\n        transportKey = _ref.transportKey,\n        peerInfo = _ref.peerInfo;\n\n    _classCallCheck(this, IncomingConnectionFSM);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(IncomingConnectionFSM).call(this, {\n      _switch: _switch,\n      name: \"inc:\".concat(_switch._peerInfo.id.toB58String().slice(0, 8))\n    }));\n    _this.conn = connection;\n    _this.theirPeerInfo = peerInfo || null;\n    _this.theirB58Id = _this.theirPeerInfo ? _this.theirPeerInfo.id.toB58String() : null;\n    _this.ourPeerInfo = _this.switch._peerInfo;\n    _this.transportKey = transportKey;\n    _this.protocolMuxer = _this.switch.protocolMuxer(_this.transportKey);\n    _this.msListener = new multistream.Listener();\n    _this._state = FSM('DIALED', {\n      DISCONNECTED: {\n        disconnect: 'DISCONNECTED'\n      },\n      DIALED: {\n        // Base connection to peer established\n        privatize: 'PRIVATIZING',\n        encrypt: 'ENCRYPTING'\n      },\n      PRIVATIZING: {\n        // Protecting the base connection\n        done: 'PRIVATIZED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: {\n        // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: {\n        // Encrypting the base connection\n        done: 'ENCRYPTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: {\n        // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: {\n        // Attempting to upgrade the connection with muxers\n        done: 'MUXED'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: {\n        // Shutting down the connection\n        done: 'DISCONNECTED'\n      }\n    });\n\n    _this._state.on('DISCONNECTED', function () {\n      return _this._onDisconnected();\n    });\n\n    _this._state.on('PRIVATIZING', function () {\n      return _this._onPrivatizing();\n    });\n\n    _this._state.on('PRIVATIZED', function () {\n      return _this._onPrivatized();\n    });\n\n    _this._state.on('ENCRYPTING', function () {\n      return _this._onEncrypting();\n    });\n\n    _this._state.on('ENCRYPTED', function () {\n      _this.log('successfully encrypted connection to %s', _this.theirB58Id || 'unknown peer');\n\n      _this.emit('encrypted', _this.conn);\n    });\n\n    _this._state.on('UPGRADING', function () {\n      return _this._onUpgrading();\n    });\n\n    _this._state.on('MUXED', function () {\n      _this.log('successfully muxed connection to %s', _this.theirB58Id || 'unknown peer');\n\n      _this.emit('muxed', _this.conn);\n    });\n\n    _this._state.on('DISCONNECTING', function () {\n      _this._state('done');\n    });\n\n    return _this;\n  }\n  /**\n   * Attempts to encrypt `this.conn` with the Switch's crypto.\n   *\n   * @private\n   * @fires IncomingConnectionFSM#error\n   * @returns {void}\n   */\n\n\n  _createClass(IncomingConnectionFSM, [{\n    key: \"_onEncrypting\",\n    value: function _onEncrypting() {\n      var _this2 = this;\n\n      this.log('encrypting connection via %s', this.switch.crypto.tag);\n      this.msListener.addHandler(this.switch.crypto.tag, function (protocol, _conn) {\n        _this2.conn = _this2.switch.crypto.encrypt(_this2.ourPeerInfo.id, _conn, undefined, function (err) {\n          if (err) {\n            return _this2.close(err);\n          }\n\n          _this2.conn.getPeerInfo(function (_, peerInfo) {\n            _this2.theirPeerInfo = peerInfo;\n\n            _this2._state('done');\n          });\n        });\n      }, null); // Start handling the connection\n\n      this.msListener.handle(this.conn, function (err) {\n        if (err) {\n          _this2.emit('crypto handshaking failed', err);\n        }\n      });\n    }\n  }, {\n    key: \"_onUpgrading\",\n    value: function _onUpgrading() {\n      this.log('adding the protocol muxer to the connection');\n      this.protocolMuxer(this.conn, this.msListener);\n\n      this._state('done');\n    }\n  }]);\n\n  return IncomingConnectionFSM;\n}(BaseConnection);\n\nmodule.exports = withIs(IncomingConnectionFSM, {\n  className: 'IncomingConnectionFSM',\n  symbolName: 'libp2p-switch/IncomingConnectionFSM'\n});","map":null,"metadata":{},"sourceType":"script"}