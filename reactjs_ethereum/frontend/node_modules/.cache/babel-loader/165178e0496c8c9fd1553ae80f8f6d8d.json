{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar libp2pRecord = require('libp2p-record');\n\nvar MemoryStore = require('interface-datastore').MemoryDatastore;\n\nvar waterfall = require('async/waterfall');\n\nvar each = require('async/each');\n\nvar filter = require('async/filter');\n\nvar timeout = require('async/timeout');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar crypto = require('libp2p-crypto');\n\nvar errcode = require('err-code');\n\nvar RoutingTable = require('./routing');\n\nvar utils = require('./utils');\n\nvar c = require('./constants');\n\nvar Query = require('./query');\n\nvar Network = require('./network');\n\nvar privateApi = require('./private');\n\nvar Providers = require('./providers');\n\nvar Message = require('./message');\n\nvar RandomWalk = require('./random-walk');\n\nvar QueryManager = require('./query-manager');\n\nvar assert = require('assert');\n/**\n * A DHT implementation modeled after Kademlia with S/Kademlia modifications.\n *\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\n\n\nvar KadDHT =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(KadDHT, _EventEmitter);\n\n  /**\n   * Random walk options\n   *\n   * @typedef {Object} randomWalkOptions\n   * @property {boolean} enabled discovery enabled (default: true)\n   * @property {number} queriesPerPeriod how many queries to run per period (default: 1)\n   * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)\n   * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)\n   * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)\n   */\n\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {Switch} sw libp2p-switch instance\n   * @param {object} options DHT options\n   * @param {number} options.kBucketSize k-bucket size (default 20)\n   * @param {number} options.concurrency alpha concurrency of queries (default 3)\n   * @param {Datastore} options.datastore datastore (default MemoryDatastore)\n   * @param {object} options.validators validators object with namespace as keys and function(key, record, callback)\n   * @param {object} options.selectors selectors object with namespace as keys and function(key, records)\n   * @param {randomWalkOptions} options.randomWalk randomWalk options\n   */\n  function KadDHT(sw, options) {\n    var _this;\n\n    _classCallCheck(this, KadDHT);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(KadDHT).call(this));\n    assert(sw, 'libp2p-kad-dht requires a instance of Switch');\n    options = options || {};\n    options.validators = options.validators || {};\n    options.selectors = options.selectors || {};\n    /**\n     * Local reference to the libp2p-switch instance\n     *\n     * @type {Switch}\n     */\n\n    _this.switch = sw;\n    /**\n     * k-bucket size, defaults to 20\n     *\n     * @type {number}\n     */\n\n    _this.kBucketSize = options.kBucketSize || c.K;\n    /**\n     * ALPHA concurrency at which each query path with run, defaults to 3\n     * @type {number}\n     */\n\n    _this.concurrency = options.concurrency || c.ALPHA;\n    /**\n     * Number of disjoint query paths to use\n     * This is set to `kBucketSize`/2 per the S/Kademlia paper\n     * @type {number}\n     */\n\n    _this.disjointPaths = Math.ceil(_this.kBucketSize / 2);\n    /**\n     * The routing table.\n     *\n     * @type {RoutingTable}\n     */\n\n    _this.routingTable = new RoutingTable(_this.peerInfo.id, _this.kBucketSize);\n    /**\n     * Reference to the datastore, uses an in-memory store if none given.\n     *\n     * @type {Datastore}\n     */\n\n    _this.datastore = options.datastore || new MemoryStore();\n    /**\n     * Provider management\n     *\n     * @type {Providers}\n     */\n\n    _this.providers = new Providers(_this.datastore, _this.peerInfo.id);\n    _this.validators = _objectSpread({\n      pk: libp2pRecord.validator.validators.pk\n    }, options.validators);\n    _this.selectors = _objectSpread({\n      pk: libp2pRecord.selection.selectors.pk\n    }, options.selectors);\n    _this.network = new Network(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._log = utils.logger(_this.peerInfo.id); // Inject private apis so we don't clutter up this file\n\n    var pa = privateApi(_assertThisInitialized(_assertThisInitialized(_this)));\n    Object.keys(pa).forEach(function (name) {\n      _this[name] = pa[name];\n    });\n    /**\n     * Random walk management\n     *\n     * @type {RandomWalk}\n     */\n\n    _this.randomWalk = new RandomWalk(_assertThisInitialized(_assertThisInitialized(_this)), options.randomWalk);\n    /**\n     * Keeps track of running queries\n     *\n     * @type {QueryManager}\n     */\n\n    _this._queryManager = new QueryManager();\n    return _this;\n  }\n  /**\n   * Is this DHT running.\n   *\n   * @type {bool}\n   */\n\n\n  _createClass(KadDHT, [{\n    key: \"start\",\n\n    /**\n     * Start listening to incoming connections.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    value: function start(callback) {\n      var _this2 = this;\n\n      this._running = true;\n\n      this._queryManager.start();\n\n      this.network.start(function (err) {\n        if (err) {\n          return callback(err);\n        } // Start random walk, it will not run if it's disabled\n\n\n        _this2.randomWalk.start();\n\n        callback();\n      });\n    }\n    /**\n     * Stop accepting incoming connections and sending outgoing\n     * messages.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      this._running = false;\n      this.randomWalk.stop();\n      this.providers.stop();\n\n      this._queryManager.stop();\n\n      this.network.stop(callback);\n    }\n    /**\n     * Local peer (yourself)\n     *\n     * @type {PeerInfo}\n     */\n\n  }, {\n    key: \"put\",\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} options - get options\n     * @param {number} options.minPeers - minimum peers that must be put to to consider this a successful operation\n     * (default: closestPeers.length)\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    value: function put(key, value, options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      this._log('PutValue %b', key);\n\n      waterfall([function (cb) {\n        return utils.createPutRecord(key, value, cb);\n      }, function (rec, cb) {\n        return waterfall([function (cb) {\n          return _this3._putLocal(key, rec, cb);\n        }, function (cb) {\n          return _this3.getClosestPeers(key, {\n            shallow: true\n          }, cb);\n        }, function (peers, cb) {\n          // Ensure we have a default `minPeers`\n          options.minPeers = options.minPeers || peers.length; // filter out the successful puts\n\n          filter(peers, function (peer, cb) {\n            _this3._putValueToPeer(key, rec, peer, function (err) {\n              if (err) {\n                _this3._log.error('Failed to put to peer (%b): %s', peer.id, err);\n\n                return cb(null, false);\n              }\n\n              cb(null, true);\n            });\n          }, function (err, results) {\n            if (err) return cb(err); // Did we put to enough peers?\n\n            if (options.minPeers > results.length) {\n              var error = errcode(new Error('Failed to put value to enough peers'), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n              _this3._log.error(error);\n\n              return cb(error);\n            }\n\n            cb();\n          });\n        }], cb);\n      }], callback);\n    }\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout (default: 60000)\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      if (!options.maxTimeout && !options.timeout) {\n        options.timeout = c.minute; // default\n      } else if (options.maxTimeout && !options.timeout) {\n        // TODO this will be deprecated in a next release\n        options.timeout = options.maxTimeout;\n      }\n\n      this._get(key, options, callback);\n    }\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Buffer} key\n     * @param {number} nvals\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout (default: 60000)\n     * @param {function(Error, Array<{from: PeerId, val: Buffer}>)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(key, nvals, options, callback) {\n      var _this4 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      if (!options.maxTimeout && !options.timeout) {\n        options.timeout = c.minute; // default\n      } else if (options.maxTimeout && !options.timeout) {\n        // TODO this will be deprecated in a next release\n        options.timeout = options.maxTimeout;\n      }\n\n      this._log('getMany %b (%s)', key, nvals);\n\n      var vals = [];\n\n      this._getLocal(key, function (err, localRec) {\n        if (err && nvals === 0) {\n          return callback(err);\n        }\n\n        if (err == null) {\n          vals.push({\n            val: localRec.value,\n            from: _this4.peerInfo.id\n          });\n        }\n\n        if (vals.length >= nvals) {\n          return callback(null, vals);\n        }\n\n        var paths = [];\n        waterfall([function (cb) {\n          return utils.convertBuffer(key, cb);\n        }, function (id, cb) {\n          var rtp = _this4.routingTable.closestPeers(id, _this4.kBucketSize);\n\n          _this4._log('peers in rt: %d', rtp.length);\n\n          if (rtp.length === 0) {\n            var errMsg = 'Failed to lookup key! No peers from routing table!';\n\n            _this4._log.error(errMsg);\n\n            return cb(errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE'));\n          } // we have peers, lets do the actual query to them\n\n\n          var query = new Query(_this4, key, function (pathIndex, numPaths) {\n            // This function body runs once per disjoint path\n            var pathSize = utils.pathSize(nvals - vals.length, numPaths);\n            var pathVals = [];\n            paths.push(pathVals); // Here we return the query function to use on this particular disjoint path\n\n            return function (peer, cb) {\n              _this4._getValueOrPeers(peer, key, function (err, rec, peers) {\n                if (err) {\n                  // If we have an invalid record we just want to continue and fetch a new one.\n                  if (!(err.code === 'ERR_INVALID_RECORD')) {\n                    return cb(err);\n                  }\n                }\n\n                var res = {\n                  closerPeers: peers\n                };\n\n                if (rec && rec.value || err && err.code === 'ERR_INVALID_RECORD') {\n                  pathVals.push({\n                    val: rec && rec.value,\n                    from: peer\n                  });\n                } // enough is enough\n\n\n                if (pathVals.length >= pathSize) {\n                  res.pathComplete = true;\n                }\n\n                cb(null, res);\n              });\n            };\n          }); // run our query\n\n          timeout(function (_cb) {\n            query.run(rtp, _cb);\n          }, options.timeout)(function (err, res) {\n            query.stop();\n            cb(err, res);\n          });\n        }], function (err) {\n          // combine vals from each path\n          vals = [].concat.apply(vals, paths).slice(0, nvals);\n\n          if (err && vals.length === 0) {\n            return callback(err);\n          }\n\n          callback(null, vals);\n        });\n      });\n    }\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Buffer} key\n     * @param {Object} options\n     * @param {boolean} options.shallow shallow query\n     * @param {function(Error, Array<PeerId>)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getClosestPeers\",\n    value: function getClosestPeers(key, options, callback) {\n      var _this5 = this;\n\n      this._log('getClosestPeers to %b', key);\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {\n          shallow: false\n        };\n      }\n\n      utils.convertBuffer(key, function (err, id) {\n        if (err) {\n          return callback(err);\n        }\n\n        var tablePeers = _this5.routingTable.closestPeers(id, _this5.kBucketSize);\n\n        var q = new Query(_this5, key, function () {\n          // There is no distinction between the disjoint paths,\n          // so there are no per-path variables in this scope.\n          // Just return the actual query function.\n          return function (peer, callback) {\n            waterfall([function (cb) {\n              return _this5._closerPeersSingle(key, peer, cb);\n            }, function (closer, cb) {\n              cb(null, {\n                closerPeers: closer,\n                pathComplete: options.shallow ? true : undefined\n              });\n            }], callback);\n          };\n        });\n        q.run(tablePeers, function (err, res) {\n          if (err) {\n            return callback(err);\n          }\n\n          if (!res || !res.finalSet) {\n            return callback(null, []);\n          }\n\n          waterfall([function (cb) {\n            return utils.sortClosestPeers(Array.from(res.finalSet), id, cb);\n          }, function (sorted, cb) {\n            return cb(null, sorted.slice(0, _this5.kBucketSize));\n          }], callback);\n        });\n      });\n    }\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error, PubKey)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getPublicKey\",\n    value: function getPublicKey(peer, callback) {\n      var _this6 = this;\n\n      this._log('getPublicKey %s', peer.toB58String()); // local check\n\n\n      var info;\n\n      if (this.peerBook.has(peer)) {\n        info = this.peerBook.get(peer);\n\n        if (info && info.id.pubKey) {\n          this._log('getPublicKey: found local copy');\n\n          return callback(null, info.id.pubKey);\n        }\n      } else {\n        info = this.peerBook.put(new PeerInfo(peer));\n      } // try the node directly\n\n\n      this._getPublicKeyFromNode(peer, function (err, pk) {\n        if (!err) {\n          info.id = new PeerId(peer.id, null, pk);\n\n          _this6.peerBook.put(info);\n\n          return callback(null, pk);\n        } // dht directly\n\n\n        var pkKey = utils.keyForPublicKey(peer);\n\n        _this6.get(pkKey, function (err, value) {\n          if (err) {\n            return callback(err);\n          }\n\n          var pk = crypto.unmarshalPublicKey(value);\n          info.id = new PeerId(peer, null, pk);\n\n          _this6.peerBook.put(info);\n\n          callback(null, pk);\n        });\n      });\n    }\n    /**\n     * Look if we are connected to a peer with the given id.\n     * Returns the `PeerInfo` for it, if found, otherwise `undefined`.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error, PeerInfo)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"findPeerLocal\",\n    value: function findPeerLocal(peer, callback) {\n      var _this7 = this;\n\n      this._log('findPeerLocal %s', peer.toB58String());\n\n      this.routingTable.find(peer, function (err, p) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!p || !_this7.peerBook.has(p)) {\n          return callback();\n        }\n\n        callback(null, _this7.peerBook.get(p));\n      });\n    } // ----------- Content Routing\n\n    /**\n     * Announce to the network that we can provide given key's value.\n     *\n     * @param {CID} key\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"provide\",\n    value: function provide(key, callback) {\n      var _this8 = this;\n\n      this._log('provide: %s', key.toBaseEncodedString());\n\n      var errors = [];\n      waterfall([function (cb) {\n        return _this8.providers.addProvider(key, _this8.peerInfo.id, cb);\n      }, function (cb) {\n        return _this8.getClosestPeers(key.buffer, cb);\n      }, function (peers, cb) {\n        var msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0);\n        msg.providerPeers = peers.map(function (p) {\n          return new PeerInfo(p);\n        });\n        each(peers, function (peer, cb) {\n          _this8._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String());\n\n          _this8.network.sendMessage(peer, msg, function (err) {\n            if (err) errors.push(err);\n            cb();\n          });\n        }, cb);\n      }], function (err) {\n        if (errors.length) {\n          // This should be infrequent. This means a peer we previously connected\n          // to failed to exchange the provide message. If getClosestPeers was an\n          // iterator, we could continue to pull until we announce to kBucketSize peers.\n          err = errcode(\"Failed to provide to \".concat(errors.length, \" of \").concat(_this8.kBucketSize, \" peers\"), 'ERR_SOME_PROVIDES_FAILED', {\n            errors: errors\n          });\n        }\n\n        callback(err);\n      });\n    }\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     *\n     * @param {CID} key\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"findProviders\",\n    value: function findProviders(key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      if (!options.maxTimeout && !options.timeout) {\n        options.timeout = c.minute; // default\n      } else if (options.maxTimeout && !options.timeout) {\n        // TODO this will be deprecated in a next release\n        options.timeout = options.maxTimeout;\n      }\n\n      options.maxNumProviders = options.maxNumProviders || c.K;\n\n      this._log('findProviders %s', key.toBaseEncodedString());\n\n      this._findNProviders(key, options.timeout, options.maxNumProviders, callback);\n    } // ----------- Peer Routing\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} options - findPeer options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {function(Error, PeerInfo)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"findPeer\",\n    value: function findPeer(id, options, callback) {\n      var _this9 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      if (!options.maxTimeout && !options.timeout) {\n        options.timeout = c.minute; // default\n      } else if (options.maxTimeout && !options.timeout) {\n        // TODO this will be deprecated in a next release\n        options.timeout = options.maxTimeout;\n      }\n\n      this._log('findPeer %s', id.toB58String());\n\n      this.findPeerLocal(id, function (err, pi) {\n        if (err) {\n          return callback(err);\n        } // already got it\n\n\n        if (pi != null) {\n          _this9._log('found local');\n\n          return callback(null, pi);\n        }\n\n        waterfall([function (cb) {\n          return utils.convertPeerId(id, cb);\n        }, function (key, cb) {\n          var peers = _this9.routingTable.closestPeers(key, _this9.kBucketSize);\n\n          if (peers.length === 0) {\n            return cb(errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED'));\n          } // sanity check\n\n\n          var match = peers.find(function (p) {\n            return p.isEqual(id);\n          });\n\n          if (match && _this9.peerBook.has(id)) {\n            _this9._log('found in peerbook');\n\n            return cb(null, _this9.peerBook.get(id));\n          } // query the network\n\n\n          var query = new Query(_this9, id.id, function () {\n            // There is no distinction between the disjoint paths,\n            // so there are no per-path variables in this scope.\n            // Just return the actual query function.\n            return function (peer, cb) {\n              waterfall([function (cb) {\n                return _this9._findPeerSingle(peer, id, cb);\n              }, function (msg, cb) {\n                var match = msg.closerPeers.find(function (p) {\n                  return p.id.isEqual(id);\n                }); // found it\n\n                if (match) {\n                  return cb(null, {\n                    peer: match,\n                    queryComplete: true\n                  });\n                }\n\n                cb(null, {\n                  closerPeers: msg.closerPeers\n                });\n              }], cb);\n            };\n          });\n          timeout(function (_cb) {\n            query.run(peers, _cb);\n          }, options.timeout)(function (err, res) {\n            query.stop();\n            cb(err, res);\n          });\n        }, function (result, cb) {\n          var success = false;\n          result.paths.forEach(function (result) {\n            if (result.success) {\n              success = true;\n\n              _this9.peerBook.put(result.peer);\n            }\n          });\n\n          _this9._log('findPeer %s: %s', id.toB58String(), success);\n\n          if (!success) {\n            return cb(errcode(new Error('No peer found'), 'ERR_NOT_FOUND'));\n          }\n\n          cb(null, _this9.peerBook.get(id));\n        }], callback);\n      });\n    }\n  }, {\n    key: \"_peerDiscovered\",\n    value: function _peerDiscovered(peerInfo) {\n      this.emit('peer', peerInfo);\n    }\n  }, {\n    key: \"isStarted\",\n    get: function get() {\n      return this._running;\n    }\n  }, {\n    key: \"peerInfo\",\n    get: function get() {\n      return this.switch._peerInfo;\n    }\n  }, {\n    key: \"peerBook\",\n    get: function get() {\n      return this.switch._peerBook;\n    }\n  }]);\n\n  return KadDHT;\n}(EventEmitter);\n\nmodule.exports = KadDHT;","map":null,"metadata":{},"sourceType":"script"}