{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar every = require('async/every');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar CID = require('cids');\n\nvar each = require('async/each');\n\nvar nextTick = require('async/nextTick');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:dht');\nlog.error = debug('ipfs:dht:error');\n\nmodule.exports = function (self) {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    get: promisify(function (key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          log.error(err);\n          return nextTick(function () {\n            return callback(errcode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      self.libp2p.dht.get(key, options, callback);\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    put: promisify(function (key, value, callback) {\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          log.error(err);\n          return nextTick(function () {\n            return callback(errcode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      self.libp2p.dht.put(key, value, callback);\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findProvs: promisify(function (key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key);\n        } catch (err) {\n          log.error(err);\n          return nextTick(function () {\n            return callback(errcode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      self.libp2p.contentRouting.findProviders(key, options, callback);\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peer - The id of the peer to search for.\n     * @param {function(Error, PeerInfo)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findPeer: promisify(function (peer, callback) {\n      if (typeof peer === 'string') {\n        peer = PeerId.createFromB58String(peer);\n      }\n\n      self.libp2p.peerRouting.findPeer(peer, callback);\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|Array<CID>} keys - The keys that should be announced.\n     * @param {Object} options - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    provide: promisify(function (keys, options, callback) {\n      if (!Array.isArray(keys)) {\n        keys = [keys];\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {}; // ensure blocks are actually local\n\n      every(keys, function (key, cb) {\n        self._repo.blocks.has(key, cb);\n      }, function (err, has) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!has) {\n          var errMsg = 'block(s) not found locally, cannot provide';\n          log.error(errMsg);\n          return callback(errcode(errMsg, 'ERR_BLOCK_NOT_FOUND'));\n        }\n\n        if (options.recursive) {\n          // TODO: Implement recursive providing\n          return callback(errcode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET'));\n        } else {\n          each(keys, function (cid, cb) {\n            self.libp2p.contentRouting.provide(cid, cb);\n          }, callback);\n        }\n      });\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {PeerId} peer - The `PeerId` to run the query agains.\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<Array<PeerInfo>>|void}\n     */\n    query: promisify(function (peerId, callback) {\n      if (typeof peerId === 'string') {\n        try {\n          peerId = PeerId.createFromB58String(peerId);\n        } catch (err) {\n          log.error(err);\n          return callback(err);\n        }\n      } // TODO expose this method in peerRouting\n\n\n      self.libp2p._dht.getClosestPeers(peerId.toBytes(), function (err, peerIds) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        callback(null, peerIds.map(function (id) {\n          return new PeerInfo(id);\n        }));\n      });\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}