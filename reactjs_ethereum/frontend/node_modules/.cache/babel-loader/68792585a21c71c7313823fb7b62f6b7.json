{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar promisify = require('promisify-es6');\n\nvar createLock = require('./utils/create-lock'); // These operations are read-locked at the function level and will execute simultaneously\n\n\nvar readOperations = {\n  stat: require('./stat') // These operations are locked at the function level and will execute in series\n\n};\nvar writeOperations = {\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm') // These operations are asynchronous and manage their own locking\n\n};\nvar unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n\nvar wrap = function wrap(_ref) {\n  var options = _ref.options,\n      mfs = _ref.mfs,\n      operations = _ref.operations,\n      lock = _ref.lock;\n  Object.keys(operations).forEach(function (key) {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nvar defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n};\n\nmodule.exports = function (options) {\n  var _Object$assign = Object.assign({}, defaultOptions || {}, options),\n      repoOwner = _Object$assign.repoOwner;\n\n  assert(options.ipld, 'MFS requires an IPLD instance');\n  assert(options.blocks, 'MFS requires an BlockStore instance');\n  assert(options.datastore, 'MFS requires a DataStore instance'); // should be able to remove this when async/await PRs are in for datastore, blockstore & repo\n\n  options.repo = {\n    blocks: {\n      get: promisify(options.blocks.get, {\n        context: options.blocks\n      })\n    },\n    datastore: {\n      open: promisify(options.datastore.open, {\n        context: options.datastore\n      }),\n      get: promisify(options.datastore.get, {\n        context: options.datastore\n      }),\n      put: promisify(options.datastore.put, {\n        context: options.datastore\n      })\n    }\n  };\n  var lock = createLock(repoOwner);\n\n  var readLock = function readLock(operation) {\n    return lock.readLock(operation);\n  };\n\n  var writeLock = function writeLock(operation) {\n    return lock.writeLock(operation);\n  };\n\n  var mfs = {};\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(function (key) {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n};","map":null,"metadata":{},"sourceType":"script"}