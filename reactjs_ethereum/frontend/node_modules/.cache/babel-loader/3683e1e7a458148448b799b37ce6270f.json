{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar CID = require('cids');\n\nvar pull = require('pull-stream');\n\nvar iterToPull = require('async-iterator-to-pull-stream');\n\nvar mapAsync = require('async/map');\n\nvar setImmediate = require('async/setImmediate');\n\nvar flattenDeep = require('just-flatten-it');\n\nvar errCode = require('err-code');\n\nvar multicodec = require('multicodec');\n\nmodule.exports = function dag(self) {\n  return {\n    put: promisify(function (dagNode, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (options.cid && (options.format || options.hashAlg)) {\n        return callback(new Error('Can\\'t put dag node. Please provide either `cid` OR `format` and `hashAlg` options.'));\n      } else if (options.format && !options.hashAlg || !options.format && options.hashAlg) {\n        return callback(new Error('Can\\'t put dag node. Please provide `format` AND `hashAlg` options.'));\n      }\n\n      var optionDefaults = {\n        format: multicodec.DAG_CBOR,\n        hashAlg: multicodec.SHA2_256 // The IPLD expects the format and hashAlg as constants\n\n      };\n\n      if (options.format && typeof options.format === 'string') {\n        var constantName = options.format.toUpperCase().replace(/-/g, '_');\n        options.format = multicodec[constantName];\n      }\n\n      if (options.hashAlg && typeof options.hashAlg === 'string') {\n        var _constantName = options.hashAlg.toUpperCase().replace(/-/g, '_');\n\n        options.hashAlg = multicodec[_constantName];\n      }\n\n      options = options.cid ? options : Object.assign({}, optionDefaults, options); // js-ipld defaults to verion 1 CIDs. Hence set version 0 explicitly for\n      // dag-pb nodes\n\n      if (options.version === undefined) {\n        if (options.format === multicodec.DAG_PB && options.hashAlg === multicodec.SHA2_256) {\n          options.version = 0;\n        } else {\n          options.version = 1;\n        }\n      }\n\n      self._ipld.put(dagNode, options.format, {\n        hashAlg: options.hashAlg,\n        cidVersion: options.version\n      }).then(function (cid) {\n        if (options.preload !== false) {\n          self._preload(cid);\n        }\n\n        return callback(null, cid);\n      }, function (error) {\n        return callback(error);\n      });\n    }),\n    get: promisify(function (cid, path, options, callback) {\n      if (typeof path === 'function') {\n        callback = path;\n        path = undefined;\n      }\n\n      if (typeof options === 'function') {\n        callback = options; // Allow options in path position\n\n        if (typeof path !== 'string') {\n          options = path;\n          path = undefined;\n        } else {\n          options = {};\n        }\n      }\n\n      options = options || {};\n\n      if (typeof cid === 'string') {\n        var split = cid.split('/');\n\n        try {\n          cid = new CID(split[0]);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n\n        split.shift();\n\n        if (split.length > 0) {\n          path = split.join('/');\n        } else {\n          path = '/';\n        }\n      } else if (Buffer.isBuffer(cid)) {\n        try {\n          cid = new CID(cid);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      if (path === undefined || path === '/') {\n        self._ipld.get(cid).then(function (value) {\n          callback(null, {\n            value: value,\n            remainderPath: ''\n          });\n        }, function (error) {\n          return callback(error);\n        });\n      } else {\n        var result = self._ipld.resolve(cid, path);\n\n        var promisedValue = options.localResolve ? result.first() : result.last();\n        promisedValue.then(function (value) {\n          return callback(null, value);\n        }, function (error) {\n          return callback(error);\n        });\n      }\n    }),\n    tree: promisify(function (cid, path, options, callback) {\n      if (typeof path === 'object') {\n        callback = options;\n        options = path;\n        path = undefined;\n      }\n\n      if (typeof path === 'function') {\n        callback = path;\n        path = undefined;\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (typeof cid === 'string') {\n        var split = cid.split('/');\n\n        try {\n          cid = new CID(split[0]);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n\n        split.shift();\n\n        if (split.length > 0) {\n          path = split.join('/');\n        } else {\n          path = undefined;\n        }\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      pull(iterToPull(self._ipld.tree(cid, path, options)), pull.collect(callback));\n    }),\n    // TODO - use IPLD selectors once they are implemented\n    _getRecursive: promisify(function (multihash, options, callback) {\n      // gets flat array of all DAGNodes in tree given by multihash\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var cid;\n\n      try {\n        cid = new CID(multihash);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_CID'));\n        });\n      }\n\n      self.dag.get(cid, '', options, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        mapAsync(res.value.Links, function (link, cb) {\n          self.dag._getRecursive(link.Hash, options, cb);\n        }, function (err, nodes) {\n          // console.log('nodes:', nodes)\n          if (err) return callback(err);\n          callback(null, flattenDeep([res.value, nodes]));\n        });\n      });\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}