{"ast":null,"code":"'use strict';\n\nvar debug = require('debug');\n\nvar IncomingConnection = require('./incoming');\n\nvar observeConn = require('../observe-connection');\n\nfunction listener(_switch) {\n  var log = debug(\"libp2p:switch:listener\");\n  /**\n   * Takes a transport key and returns a connection handler function\n   *\n   * @param {string} transportKey The key of the transport to handle connections for\n   * @param {function} handler A custom handler to use\n   * @returns {function(Connection)} A connection handler function\n   */\n\n  return function (transportKey, handler) {\n    /**\n     * Takes a base connection and manages listening behavior\n     *\n     * @param {Connection} conn The connection to manage\n     * @returns {void}\n     */\n    return function (conn) {\n      log('received incoming connection for transport %s', transportKey);\n      conn.getPeerInfo(function (_, peerInfo) {\n        // Add a transport level observer, if needed\n        var connection = transportKey ? observeConn(transportKey, null, conn, _switch.observer) : conn;\n        var connFSM = new IncomingConnection({\n          connection: connection,\n          _switch: _switch,\n          transportKey: transportKey,\n          peerInfo: peerInfo\n        });\n        connFSM.once('error', function (err) {\n          return log(err);\n        });\n        connFSM.once('private', function (_conn) {\n          // Use the custom handler, if it was provided\n          if (handler) {\n            return handler(_conn);\n          }\n\n          connFSM.encrypt();\n        });\n        connFSM.once('encrypted', function () {\n          return connFSM.upgrade();\n        });\n        connFSM.protect();\n      });\n    };\n  };\n}\n\nmodule.exports = listener;","map":null,"metadata":{},"sourceType":"script"}