{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('./utils'),\n    encodeBase32 = _require2.encodeBase32,\n    keyToTopic = _require2.keyToTopic,\n    topicToKey = _require2.topicToKey;\n\nvar errcode = require('err-code');\n\nvar assert = require('assert');\n\nvar debug = require('debug');\n\nvar log = debug('datastore-pubsub:publisher');\nlog.error = debug('datastore-pubsub:publisher:error'); // DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nvar DatastorePubsub =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  function DatastorePubsub(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    _classCallCheck(this, DatastorePubsub);\n\n    assert.strictEqual(typeof validator, 'object', 'missing validator');\n    assert.strictEqual(typeof validator.validate, 'function', 'missing validate function');\n    assert.strictEqual(typeof validator.select, 'function', 'missing select function');\n    subscriptionKeyFn && assert.strictEqual(typeof subscriptionKeyFn, 'function', 'invalid subscriptionKeyFn received');\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(DatastorePubsub, [{\n    key: \"put\",\n    value: function put(key, val, callback) {\n      if (!Buffer.isBuffer(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      if (!Buffer.isBuffer(val)) {\n        var _errMsg = \"received value is not a buffer\";\n        log.error(_errMsg);\n        return callback(errcode(new Error(_errMsg), 'ERR_INVALID_VALUE_RECEIVED'));\n      }\n\n      var stringifiedTopic = keyToTopic(key);\n      log(\"publish value for topic \".concat(stringifiedTopic)); // Publish record to pubsub\n\n      this._pubsub.publish(stringifiedTopic, val, callback);\n    }\n    /**\n     * Try to subscribe a topic with Pubsub and returns the local value if available.\n     * @param {Buffer} key identifier of the value to be subscribed.\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, callback) {\n      var _this = this;\n\n      if (!Buffer.isBuffer(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      var stringifiedTopic = keyToTopic(key);\n\n      this._pubsub.ls(function (err, res) {\n        if (err) {\n          return callback(err);\n        } // If already subscribed, just try to get it\n\n\n        if (res && Array.isArray(res) && res.indexOf(stringifiedTopic) > -1) {\n          return _this._getLocal(key, callback);\n        } // Subscribe\n\n\n        _this._pubsub.subscribe(stringifiedTopic, _this._onMessage, function (err) {\n          if (err) {\n            var _errMsg2 = \"cannot subscribe topic \".concat(stringifiedTopic);\n\n            log.error(_errMsg2);\n            return callback(errcode(new Error(_errMsg2), 'ERR_SUBSCRIBING_TOPIC'));\n          }\n\n          log(\"subscribed values for key \".concat(stringifiedTopic));\n\n          _this._getLocal(key, callback);\n        });\n      });\n    }\n    /**\n     * Unsubscribe topic.\n     * @param {Buffer} key identifier of the value to unsubscribe.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(key) {\n      var stringifiedTopic = keyToTopic(key);\n\n      this._pubsub.unsubscribe(stringifiedTopic, this._onMessage);\n    } // Get record from local datastore\n\n  }, {\n    key: \"_getLocal\",\n    value: function _getLocal(key, callback) {\n      // encode key - base32(/ipns/{cid})\n      var routingKey = new Key('/' + encodeBase32(key), false);\n\n      this._datastore.get(routingKey, function (err, dsVal) {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg3 = \"unexpected error getting the ipns record for \".concat(routingKey.toString());\n\n            log.error(_errMsg3);\n            return callback(errcode(new Error(_errMsg3), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD'));\n          }\n\n          var errMsg = \"local record requested was not found for \".concat(routingKey.toString());\n          log.error(errMsg);\n          return callback(errcode(new Error(errMsg), 'ERR_NOT_FOUND'));\n        }\n\n        if (!Buffer.isBuffer(dsVal)) {\n          var _errMsg4 = \"found record that we couldn't convert to a value\";\n          log.error(_errMsg4);\n          return callback(errcode(new Error(_errMsg4), 'ERR_INVALID_RECORD_RECEIVED'));\n        }\n\n        callback(null, dsVal);\n      });\n    } // handles pubsub subscription messages\n\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(msg) {\n      var _this2 = this;\n\n      var data = msg.data,\n          from = msg.from,\n          topicIDs = msg.topicIDs;\n      var key;\n\n      try {\n        key = topicToKey(topicIDs[0]);\n      } catch (err) {\n        log.error(err);\n        return;\n      }\n\n      log(\"message received for \".concat(key, \" topic\")); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n      if (from === this._peerId.toB58String()) {\n        log(\"message discarded as it is from the same peer\");\n        return;\n      }\n\n      if (this._handleSubscriptionKeyFn) {\n        this._handleSubscriptionKeyFn(key, function (err, res) {\n          if (err) {\n            log.error('message discarded by the subscriptionKeyFn');\n            return;\n          }\n\n          _this2._storeIfSubscriptionIsBetter(res, data);\n        });\n      } else {\n        this._storeIfSubscriptionIsBetter(key, data);\n      }\n    } // Store the received record if it is better than the current stored\n\n  }, {\n    key: \"_storeIfSubscriptionIsBetter\",\n    value: function _storeIfSubscriptionIsBetter(key, data) {\n      var _this3 = this;\n\n      this._isBetter(key, data, function (err, res) {\n        if (!err && res) {\n          _this3._storeRecord(Buffer.from(key), data);\n        }\n      });\n    } // Validate record according to the received validation function\n\n  }, {\n    key: \"_validateRecord\",\n    value: function _validateRecord(value, peerId, callback) {\n      this._validator.validate(value, peerId, callback);\n    } // Select the best record according to the received select function.\n\n  }, {\n    key: \"_selectRecord\",\n    value: function _selectRecord(receivedRecord, currentRecord, callback) {\n      this._validator.select(receivedRecord, currentRecord, function (err, res) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        } // If the selected was the first (0), it should be stored (true)\n\n\n        callback(null, res === 0);\n      });\n    } // Verify if the record received through pubsub is valid and better than the one currently stored\n\n  }, {\n    key: \"_isBetter\",\n    value: function _isBetter(key, val, callback) {\n      var _this4 = this;\n\n      // validate received record\n      this._validateRecord(val, key, function (err, valid) {\n        // If not valid, it is not better than the one currently available\n        if (err || !valid) {\n          var errMsg = 'record received through pubsub is not valid';\n          log.error(errMsg);\n          return callback(errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD'));\n        } // Get Local record\n\n\n        var dsKey = new Key(key);\n\n        _this4._getLocal(dsKey.toBuffer(), function (err, currentRecord) {\n          // if the old one is invalid, the new one is *always* better\n          if (err) {\n            return callback(null, true);\n          } // if the same record, do not need to store\n\n\n          if (currentRecord.equals(val)) {\n            return callback(null, false);\n          } // verify if the received record should replace the current one\n\n\n          _this4._selectRecord(val, currentRecord, callback);\n        });\n      });\n    } // add record to datastore\n\n  }, {\n    key: \"_storeRecord\",\n    value: function _storeRecord(key, data) {\n      // encode key - base32(/ipns/{cid})\n      var routingKey = new Key('/' + encodeBase32(key), false);\n\n      this._datastore.put(routingKey, data, function (err) {\n        if (err) {\n          log.error(\"record for \".concat(key.toString(), \" could not be stored in the routing\"));\n          return;\n        }\n\n        log(\"record for \".concat(key.toString(), \" was stored in the datastore\"));\n      });\n    }\n  }, {\n    key: \"open\",\n    value: function open(callback) {\n      var errMsg = \"open function was not implemented yet\";\n      log.error(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'));\n    }\n  }, {\n    key: \"has\",\n    value: function has(key, callback) {\n      var errMsg = \"has function was not implemented yet\";\n      log.error(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'));\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key, callback) {\n      var errMsg = \"delete function was not implemented yet\";\n      log.error(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'));\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      var errMsg = \"close function was not implemented yet\";\n      log.error(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'));\n    }\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var errMsg = \"batch function was not implemented yet\";\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }, {\n    key: \"query\",\n    value: function query() {\n      var errMsg = \"query function was not implemented yet\";\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }]);\n\n  return DatastorePubsub;\n}();\n\nexports = module.exports = DatastorePubsub;","map":null,"metadata":{},"sourceType":"script"}