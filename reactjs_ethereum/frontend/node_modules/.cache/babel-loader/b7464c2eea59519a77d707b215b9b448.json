{"ast":null,"code":"'use strict';\n\nvar parallel = require('async/parallel');\n\nvar Record = require('libp2p-record').Record;\n\nvar errcode = require('err-code');\n\nvar Message = require('../../message');\n\nvar utils = require('../../utils');\n\nmodule.exports = function (dht) {\n  var log = utils.logger(dht.peerInfo.id, 'rpc:get-value');\n  /**\n   * Process `GetValue` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n\n  return function getValue(peer, msg, callback) {\n    var key = msg.key;\n    log('key: %b', key);\n\n    if (!key || key.length === 0) {\n      return callback(errcode(new Error('Invalid key'), 'ERR_INVALID_KEY'));\n    }\n\n    var response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel);\n\n    if (utils.isPublicKeyKey(key)) {\n      log('is public key');\n      var id = utils.fromPublicKeyKey(key);\n      var info;\n\n      if (dht._isSelf(id)) {\n        info = dht.peerInfo;\n      } else if (dht.peerBook.has(id)) {\n        info = dht.peerBook.get(id);\n      }\n\n      if (info && info.id.pubKey) {\n        log('returning found public key');\n        response.record = new Record(key, info.id.pubKey.bytes);\n        return callback(null, response);\n      }\n    }\n\n    parallel([function (cb) {\n      return dht._checkLocalDatastore(key, cb);\n    }, function (cb) {\n      return dht._betterPeersToQuery(msg, peer, cb);\n    }], function (err, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      var record = res[0];\n      var closer = res[1];\n\n      if (record) {\n        log('got record');\n        response.record = record;\n      }\n\n      if (closer.length > 0) {\n        log('got closer %s', closer.length);\n        response.closerPeers = closer;\n      }\n\n      callback(null, response);\n    });\n  };\n};","map":null,"metadata":{},"sourceType":"script"}