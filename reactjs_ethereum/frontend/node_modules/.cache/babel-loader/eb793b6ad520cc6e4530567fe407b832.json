{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar DialQueueManager = require('./queueManager');\n\nvar getPeerInfo = require('../get-peer-info');\n\nvar _require = require('../constants'),\n    BLACK_LIST_ATTEMPTS = _require.BLACK_LIST_ATTEMPTS,\n    BLACK_LIST_TTL = _require.BLACK_LIST_TTL,\n    MAX_COLD_CALLS = _require.MAX_COLD_CALLS,\n    MAX_PARALLEL_DIALS = _require.MAX_PARALLEL_DIALS,\n    PRIORITY_HIGH = _require.PRIORITY_HIGH,\n    PRIORITY_LOW = _require.PRIORITY_LOW;\n\nmodule.exports = function (_switch) {\n  var dialQueueManager = new DialQueueManager(_switch);\n\n  _switch.state.on('STARTED:enter', start);\n\n  _switch.state.on('STOPPING:enter', stop);\n  /**\n   * @param {DialRequest} dialRequest\n   * @returns {void}\n   */\n\n\n  function _dial(_ref) {\n    var peerInfo = _ref.peerInfo,\n        protocol = _ref.protocol,\n        options = _ref.options,\n        callback = _ref.callback;\n\n    if (typeof protocol === 'function') {\n      callback = protocol;\n      protocol = null;\n    }\n\n    try {\n      peerInfo = getPeerInfo(peerInfo, _switch._peerBook);\n    } catch (err) {\n      return callback(err);\n    } // Add it to the queue, it will automatically get executed\n\n\n    dialQueueManager.add({\n      peerInfo: peerInfo,\n      protocol: protocol,\n      options: options,\n      callback: callback\n    });\n  }\n  /**\n   * Starts the `DialQueueManager`\n   *\n   * @param {function} callback\n   */\n\n\n  function start(callback) {\n    dialQueueManager.start();\n    callback();\n  }\n  /**\n   * Aborts all dials that are queued. This should\n   * only be used when the Switch is being stopped\n   *\n   * @param {function} callback\n   */\n\n\n  function stop(callback) {\n    dialQueueManager.stop();\n    callback();\n  }\n  /**\n   * Clears the blacklist for a given peer\n   * @param {PeerInfo} peerInfo\n   */\n\n\n  function clearBlacklist(peerInfo) {\n    dialQueueManager.clearBlacklist(peerInfo);\n  }\n  /**\n   * Attempts to establish a connection to the given `peerInfo` at\n   * a lower priority than a standard dial.\n   * @param {PeerInfo} peerInfo\n   * @param {object} options\n   * @param {boolean} options.useFSM Whether or not to return a `ConnectionFSM`. Defaults to false.\n   * @param {number} options.priority Lowest priority goes first. Defaults to 20.\n   * @param {function(Error, Connection)} callback\n   */\n\n\n  function connect(peerInfo, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = null;\n    }\n\n    options = _objectSpread({\n      useFSM: false,\n      priority: PRIORITY_LOW\n    }, options);\n\n    _dial({\n      peerInfo: peerInfo,\n      protocol: null,\n      options: options,\n      callback: callback\n    });\n  }\n  /**\n   * Adds the dial request to the queue for the given `peerInfo`\n   * The request will be added with a high priority (10).\n   * @param {PeerInfo} peerInfo\n   * @param {string} protocol\n   * @param {function(Error, Connection)} callback\n   */\n\n\n  function dial(peerInfo, protocol, callback) {\n    _dial({\n      peerInfo: peerInfo,\n      protocol: protocol,\n      options: {\n        useFSM: false,\n        priority: PRIORITY_HIGH\n      },\n      callback: callback\n    });\n  }\n  /**\n   * Behaves like dial, except it calls back with a ConnectionFSM\n   *\n   * @param {PeerInfo} peerInfo\n   * @param {string} protocol\n   * @param {function(Error, ConnectionFSM)} callback\n   */\n\n\n  function dialFSM(peerInfo, protocol, callback) {\n    _dial({\n      peerInfo: peerInfo,\n      protocol: protocol,\n      options: {\n        useFSM: true,\n        priority: PRIORITY_HIGH\n      },\n      callback: callback\n    });\n  }\n\n  return {\n    connect: connect,\n    dial: dial,\n    dialFSM: dialFSM,\n    clearBlacklist: clearBlacklist,\n    BLACK_LIST_ATTEMPTS: isNaN(_switch._options.blackListAttempts) ? BLACK_LIST_ATTEMPTS : _switch._options.blackListAttempts,\n    BLACK_LIST_TTL: isNaN(_switch._options.blacklistTTL) ? BLACK_LIST_TTL : _switch._options.blacklistTTL,\n    MAX_COLD_CALLS: isNaN(_switch._options.maxColdCalls) ? MAX_COLD_CALLS : _switch._options.maxColdCalls,\n    MAX_PARALLEL_DIALS: isNaN(_switch._options.maxParallelDials) ? MAX_PARALLEL_DIALS : _switch._options.maxParallelDials\n  };\n};","map":null,"metadata":{},"sourceType":"script"}