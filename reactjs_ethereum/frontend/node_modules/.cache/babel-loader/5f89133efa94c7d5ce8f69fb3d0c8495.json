{"ast":null,"code":"'use strict';\n\nvar debug = require('debug');\n\nvar multihashing = require('multihashing-async');\n\nvar mh = require('multihashes');\n\nvar Key = require('interface-datastore').Key;\n\nvar base32 = require('base32.js');\n\nvar distance = require('xor-distance');\n\nvar map = require('async/map');\n\nvar Record = require('libp2p-record').Record;\n\nvar setImmediate = require('async/setImmediate');\n\nvar PeerId = require('peer-id');\n/**\n * Creates a DHT ID by hashing a given buffer.\n *\n * @param {Buffer} buf\n * @param {function(Error, Buffer)} callback\n * @returns {void}\n */\n\n\nexports.convertBuffer = function (buf, callback) {\n  multihashing.digest(buf, 'sha2-256', callback);\n};\n/**\n * Creates a DHT ID by hashing a Peer ID\n *\n * @param {PeerId} peer\n * @param {function(Error, Buffer)} callback\n * @returns {void}\n */\n\n\nexports.convertPeerId = function (peer, callback) {\n  multihashing.digest(peer.id, 'sha2-256', callback);\n};\n/**\n * Convert a buffer to their SHA2-256 hash.\n *\n * @param {Buffer} buf\n * @returns {Key}\n */\n\n\nexports.bufferToKey = function (buf) {\n  return new Key('/' + exports.encodeBase32(buf), false);\n};\n/**\n * Generate the key for a public key.\n *\n * @param {PeerId} peer\n * @returns {Buffer}\n */\n\n\nexports.keyForPublicKey = function (peer) {\n  return Buffer.concat([Buffer.from('/pk/'), peer.id]);\n};\n\nexports.isPublicKeyKey = function (key) {\n  return key.slice(0, 4).toString() === '/pk/';\n};\n\nexports.fromPublicKeyKey = function (key) {\n  return new PeerId(key.slice(4));\n};\n/**\n * Get the current time as timestamp.\n *\n * @returns {number}\n */\n\n\nexports.now = function () {\n  return Date.now();\n};\n/**\n * Encode a given buffer into a base32 string.\n * @param {Buffer} buf\n * @returns {string}\n */\n\n\nexports.encodeBase32 = function (buf) {\n  var enc = new base32.Encoder();\n  return enc.write(buf).finalize();\n};\n/**\n * Decode a given base32 string into a buffer.\n * @param {string} raw\n * @returns {Buffer}\n */\n\n\nexports.decodeBase32 = function (raw) {\n  var dec = new base32.Decoder();\n  return Buffer.from(dec.write(raw).finalize());\n};\n/**\n * Sort peers by distance to the given `target`.\n *\n * @param {Array<PeerId>} peers\n * @param {Buffer} target\n * @param {function(Error, Array<PeerId>)} callback\n * @returns {void}\n */\n\n\nexports.sortClosestPeers = function (peers, target, callback) {\n  map(peers, function (peer, cb) {\n    exports.convertPeerId(peer, function (err, id) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, {\n        peer: peer,\n        distance: distance(id, target)\n      });\n    });\n  }, function (err, distances) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, distances.sort(exports.xorCompare).map(function (d) {\n      return d.peer;\n    }));\n  });\n};\n/**\n * Compare function to sort an array of elements which have a distance property which is the xor distance to a given element.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\n\n\nexports.xorCompare = function (a, b) {\n  return distance.compare(a.distance, b.distance);\n};\n/**\n * Computes how many results to collect on each disjoint path, rounding up.\n * This ensures that we look for at least one result per path.\n *\n * @param {number} resultsWanted\n * @param {number} numPaths - total number of paths\n * @returns {number}\n */\n\n\nexports.pathSize = function (resultsWanted, numPaths) {\n  return Math.ceil(resultsWanted / numPaths);\n};\n/**\n * Create a new put record, encodes and signs it if enabled.\n *\n * @param {Buffer} key\n * @param {Buffer} value\n * @param {function(Error, Buffer)} callback\n * @returns {void}\n */\n\n\nexports.createPutRecord = function (key, value, callback) {\n  var timeReceived = new Date();\n  var rec = new Record(key, value, timeReceived);\n  setImmediate(function () {\n    callback(null, rec.serialize());\n  });\n};\n/**\n * Creates a logger for the given subsystem\n *\n * @param {PeerId} [id]\n * @param {string} [subsystem]\n * @returns {debug}\n *\n * @private\n */\n\n\nexports.logger = function (id, subsystem) {\n  var name = ['libp2p', 'dht'];\n\n  if (subsystem) {\n    name.push(subsystem);\n  }\n\n  if (id) {\n    name.push(\"\".concat(id.toB58String().slice(0, 8)));\n  } // Add a formatter for converting to a base58 string\n\n\n  debug.formatters.b = function (v) {\n    return mh.toB58String(v);\n  };\n\n  var logger = debug(name.join(':'));\n  logger.error = debug(name.concat(['error']).join(':'));\n  return logger;\n};","map":null,"metadata":{},"sourceType":"script"}