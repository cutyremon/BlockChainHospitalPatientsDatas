{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar each = require('async/each');\n\nvar waterfall = require('async/waterfall');\n\nvar log = debug('ipfs:ipns:republisher');\nlog.error = debug('ipfs:ipns:republisher:error');\nvar minute = 60 * 1000;\nvar hour = 60 * minute;\nvar defaultBroadcastInterval = 4 * hour;\nvar defaultRecordLifetime = 24 * hour;\n\nvar IpnsRepublisher =\n/*#__PURE__*/\nfunction () {\n  function IpnsRepublisher(publisher, datastore, peerInfo, keychain, options) {\n    _classCallCheck(this, IpnsRepublisher);\n\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerInfo = peerInfo;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n\n  _createClass(IpnsRepublisher, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      if (this._republishHandle) {\n        var errMsg = 'already running';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_REPUBLISH_ALREADY_RUNNING');\n      } // TODO: this handler should be isolated in another module\n\n\n      var republishHandle = {\n        _onCancel: null,\n        _timeoutId: null,\n        runPeriodically: function runPeriodically(fn, period) {\n          republishHandle._timeoutId = setTimeout(function () {\n            republishHandle._timeoutId = null;\n            fn(function (nextPeriod) {\n              // Was republish cancelled while fn was being called?\n              if (republishHandle._onCancel) {\n                return republishHandle._onCancel();\n              } // Schedule next\n\n\n              republishHandle.runPeriodically(fn, nextPeriod || period);\n            });\n          }, period);\n        },\n        cancel: function cancel(cb) {\n          // Not currently running a republish, can callback immediately\n          if (republishHandle._timeoutId) {\n            clearTimeout(republishHandle._timeoutId);\n            return cb();\n          } // Wait for republish to finish then call callback\n\n\n          republishHandle._onCancel = cb;\n        }\n      };\n      var privKey = this._peerInfo.id.privKey;\n      var pass = this._options.pass;\n      republishHandle.runPeriodically(function (done) {\n        _this._republishEntries(privKey, pass, function () {\n          return done(defaultBroadcastInterval);\n        });\n      }, minute);\n      this._republishHandle = republishHandle;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var republishHandle = this._republishHandle;\n\n      if (!republishHandle) {\n        var errMsg = 'not running';\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_REPUBLISH_NOT_RUNNING'));\n      }\n\n      this._republishHandle = null;\n      republishHandle.cancel(callback);\n    }\n  }, {\n    key: \"_republishEntries\",\n    value: function _republishEntries(privateKey, pass, callback) {\n      var _this2 = this;\n\n      // TODO: Should use list of published entries.\n      // We can't currently *do* that because go uses this method for now.\n      this._republishEntry(privateKey, function (err) {\n        if (err) {\n          var errMsg = 'cannot republish entry for the node\\'s private key';\n          log.error(errMsg);\n          return;\n        } // keychain needs pass to get the cryptographic keys\n\n\n        if (pass) {\n          _this2._keychain.listKeys(function (err, list) {\n            if (err) {\n              log.error(err);\n              return;\n            }\n\n            each(list, function (key, cb) {\n              waterfall([function (cb) {\n                return _this2._keychain.exportKey(key.name, pass, cb);\n              }, function (pem, cb) {\n                return crypto.keys.import(pem, pass, cb);\n              }], function (err, privKey) {\n                if (err) {\n                  log.error(err);\n                  return;\n                }\n\n                _this2._republishEntry(privKey, cb);\n              });\n            }, function (err) {\n              if (err) {\n                log.error(err);\n              }\n\n              callback(null);\n            });\n          });\n        } else {\n          callback(null);\n        }\n      });\n    }\n  }, {\n    key: \"_republishEntry\",\n    value: function _republishEntry(privateKey, callback) {\n      var _this3 = this;\n\n      if (!privateKey || !privateKey.bytes) {\n        var errMsg = \"one or more of the provided parameters are not defined\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'));\n      }\n\n      waterfall([function (cb) {\n        return PeerId.createFromPrivKey(privateKey.bytes, cb);\n      }, function (peerId, cb) {\n        return _this3._getPreviousValue(peerId, cb);\n      }], function (err, value) {\n        if (err) {\n          return callback(err.code === 'ERR_NO_ENTRY_FOUND' ? null : err);\n        }\n\n        _this3._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime, callback);\n      });\n    }\n  }, {\n    key: \"_getPreviousValue\",\n    value: function _getPreviousValue(peerId, callback) {\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      this._datastore.get(ipns.getLocalKey(peerId.id), function (err, dsVal) {\n        // error handling\n        // no need to republish\n        if (err && err.notFound) {\n          var _errMsg = \"no previous entry for record with id: \".concat(peerId.id);\n\n          log.error(_errMsg);\n          return callback(errcode(new Error(_errMsg), 'ERR_NO_ENTRY_FOUND'));\n        } else if (err) {\n          return callback(err);\n        }\n\n        if (!Buffer.isBuffer(dsVal)) {\n          var _errMsg2 = \"found ipns record that we couldn't process\";\n          log.error(_errMsg2);\n          return callback(errcode(new Error(_errMsg2), 'ERR_INVALID_IPNS_RECORD'));\n        } // unmarshal data\n\n\n        var record;\n\n        try {\n          record = ipns.unmarshal(dsVal);\n        } catch (err) {\n          var _errMsg3 = \"found ipns record that we couldn't convert to a value\";\n          log.error(_errMsg3);\n          return callback(errcode(new Error(_errMsg3), 'ERR_INVALID_IPNS_RECORD'));\n        }\n\n        callback(null, record.value);\n      });\n    }\n  }]);\n\n  return IpnsRepublisher;\n}();\n\nexports = module.exports = IpnsRepublisher;","map":null,"metadata":{},"sourceType":"script"}