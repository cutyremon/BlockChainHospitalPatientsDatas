{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cutyremon/blockChain/reactjs_ethereum/frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nvar identify = require('libp2p-identify');\n\nvar multistream = require('multistream-select');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:conn-manager');\n\nvar once = require('once');\n\nvar ConnectionFSM = require('../connection');\n\nvar _require = require('../utils'),\n    msHandle = _require.msHandle,\n    msSelect = _require.msSelect,\n    identifyDialer = _require.identifyDialer;\n\nvar Circuit = require('libp2p-circuit');\n\nvar plaintext = require('../plaintext');\n/**\n * Contains methods for binding handlers to the Switch\n * in order to better manage its connections.\n */\n\n\nvar ConnectionManager =\n/*#__PURE__*/\nfunction () {\n  function ConnectionManager(_switch) {\n    _classCallCheck(this, ConnectionManager);\n\n    this.switch = _switch;\n    this.connections = {};\n  }\n  /**\n   * Adds the connection for tracking if it's not already added\n   * @private\n   * @param {ConnectionFSM} connection\n   * @returns {void}\n   */\n\n\n  _createClass(ConnectionManager, [{\n    key: \"add\",\n    value: function add(connection) {\n      var _this = this;\n\n      this.connections[connection.theirB58Id] = this.connections[connection.theirB58Id] || []; // Only add it if it's not there\n\n      if (!this.get(connection)) {\n        this.connections[connection.theirB58Id].push(connection);\n        this.switch.emit('connection:start', connection.theirPeerInfo);\n\n        if (connection.getState() === 'MUXED') {\n          this.switch.emit('peer-mux-established', connection.theirPeerInfo);\n        } else {\n          connection.once('muxed', function () {\n            return _this.switch.emit('peer-mux-established', connection.theirPeerInfo);\n          });\n        }\n      }\n    }\n    /**\n     * Gets the connection from the list if it exists\n     * @private\n     * @param {ConnectionFSM} connection\n     * @returns {ConnectionFSM|null} The found connection or null\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(connection) {\n      if (!this.connections[connection.theirB58Id]) return null;\n\n      for (var i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n        if (this.connections[connection.theirB58Id][i] === connection) {\n          return this.connections[connection.theirB58Id][i];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a connection associated with the given peer\n     * @private\n     * @param {string} peerId The peers id\n     * @returns {ConnectionFSM|null} The found connection or null\n     */\n\n  }, {\n    key: \"getOne\",\n    value: function getOne(peerId) {\n      if (this.connections[peerId]) {\n        // Only return muxed connections\n        for (var i = 0; i < this.connections[peerId].length; i++) {\n          if (this.connections[peerId][i].getState() === 'MUXED') {\n            return this.connections[peerId][i];\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Removes the connection from tracking\n     * @private\n     * @param {ConnectionFSM} connection The connection to remove\n     * @returns {void}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(connection) {\n      // No record of the peer, disconnect it\n      if (!this.connections[connection.theirB58Id]) {\n        if (connection.theirPeerInfo) {\n          connection.theirPeerInfo.disconnect();\n          this.switch.emit('peer-mux-closed', connection.theirPeerInfo);\n        }\n\n        return;\n      }\n\n      for (var i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n        if (this.connections[connection.theirB58Id][i] === connection) {\n          this.connections[connection.theirB58Id].splice(i, 1);\n          break;\n        }\n      } // The peer is fully disconnected\n\n\n      if (this.connections[connection.theirB58Id].length === 0) {\n        delete this.connections[connection.theirB58Id];\n        connection.theirPeerInfo.disconnect();\n        this.switch.emit('peer-mux-closed', connection.theirPeerInfo);\n      } // A tracked connection was closed, let the world know\n\n\n      this.switch.emit('connection:end', connection.theirPeerInfo);\n    }\n    /**\n     * Returns all connections being tracked\n     * @private\n     * @returns {ConnectionFSM[]}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var connections = [];\n\n      var _arr = Object.values(this.connections);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var conns = _arr[_i];\n        connections = [].concat(_toConsumableArray(connections), _toConsumableArray(conns));\n      }\n\n      return connections;\n    }\n    /**\n     * Returns all connections being tracked for a given peer id\n     * @private\n     * @param {string} peerId Stringified peer id\n     * @returns {ConnectionFSM[]}\n     */\n\n  }, {\n    key: \"getAllById\",\n    value: function getAllById(peerId) {\n      return this.connections[peerId] || [];\n    }\n    /**\n     * Adds a listener for the given `muxer` and creates a handler for it\n     * leveraging the Switch.protocolMuxer handler factory\n     *\n     * @param {Muxer} muxer\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addStreamMuxer\",\n    value: function addStreamMuxer(muxer) {\n      var _this2 = this;\n\n      // for dialing\n      this.switch.muxers[muxer.multicodec] = muxer; // for listening\n\n      this.switch.handle(muxer.multicodec, function (protocol, conn) {\n        var muxedConn = muxer.listener(conn);\n        muxedConn.on('stream', _this2.switch.protocolMuxer(null)); // If identify is enabled\n        //   1. overload getPeerInfo\n        //   2. call getPeerInfo\n        //   3. add this conn to the pool\n\n        if (_this2.switch.identify) {\n          // Get the peer info from the crypto exchange\n          conn.getPeerInfo(function (err, cryptoPI) {\n            if (err || !cryptoPI) {\n              log('crypto peerInfo wasnt found');\n            } // overload peerInfo to use Identify instead\n\n\n            conn.getPeerInfo =\n            /*#__PURE__*/\n            function () {\n              var _ref = _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee(callback) {\n                var conn, ms, results, msConn, _results, peerInfo, observedAddrs, i, addr;\n\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        conn = muxedConn.newStream();\n                        ms = new multistream.Dialer();\n                        callback = once(callback);\n                        _context.prev = 3;\n                        _context.next = 6;\n                        return msHandle(ms, conn);\n\n                      case 6:\n                        _context.next = 8;\n                        return msSelect(ms, identify.multicodec);\n\n                      case 8:\n                        msConn = _context.sent;\n                        _context.next = 11;\n                        return identifyDialer(msConn, cryptoPI);\n\n                      case 11:\n                        results = _context.sent;\n                        _context.next = 17;\n                        break;\n\n                      case 14:\n                        _context.prev = 14;\n                        _context.t0 = _context[\"catch\"](3);\n                        return _context.abrupt(\"return\", muxedConn.end(function () {\n                          callback(_context.t0, null);\n                        }));\n\n                      case 17:\n                        _results = results, peerInfo = _results.peerInfo, observedAddrs = _results.observedAddrs;\n\n                        for (i = 0; i < observedAddrs.length; i++) {\n                          addr = observedAddrs[i];\n\n                          _this2.switch._peerInfo.multiaddrs.addSafe(addr);\n                        }\n\n                        if (peerInfo) {\n                          conn.setPeerInfo(peerInfo);\n                        }\n\n                        callback(null, peerInfo);\n\n                      case 21:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[3, 14]]);\n              }));\n\n              return function (_x) {\n                return _ref.apply(this, arguments);\n              };\n            }();\n\n            conn.getPeerInfo(function (err, peerInfo) {\n              /* eslint no-warning-comments: off */\n              if (err) {\n                return log('identify not successful');\n              }\n\n              var b58Str = peerInfo.id.toB58String();\n              peerInfo = _this2.switch._peerBook.put(peerInfo);\n              var connection = new ConnectionFSM({\n                _switch: _this2.switch,\n                peerInfo: peerInfo,\n                muxer: muxedConn,\n                conn: conn,\n                type: 'inc'\n              });\n\n              _this2.switch.connection.add(connection); // Only update if it's not already connected\n\n\n              if (!peerInfo.isConnected()) {\n                if (peerInfo.multiaddrs.size > 0) {\n                  // with incomming conn and through identify, going to pick one\n                  // of the available multiaddrs from the other peer as the one\n                  // I'm connected to as we really can't be sure at the moment\n                  // TODO add this consideration to the connection abstraction!\n                  peerInfo.connect(peerInfo.multiaddrs.toArray()[0]);\n                } else {\n                  // for the case of websockets in the browser, where peers have\n                  // no addr, use just their IPFS id\n                  peerInfo.connect(\"/ipfs/\".concat(b58Str));\n                }\n              }\n\n              muxedConn.once('close', function () {\n                connection.close();\n              });\n            });\n          });\n        }\n\n        return conn;\n      });\n    }\n    /**\n     * Adds the `encrypt` handler for the given `tag` and also sets the\n     * Switch's crypto to passed `encrypt` function\n     *\n     * @param {String} tag\n     * @param {function(PeerID, Connection, PeerId, Callback)} encrypt\n     * @returns {void}\n     */\n\n  }, {\n    key: \"crypto\",\n    value: function crypto(tag, encrypt) {\n      if (!tag && !encrypt) {\n        tag = plaintext.tag;\n        encrypt = plaintext.encrypt;\n      }\n\n      this.switch.crypto = {\n        tag: tag,\n        encrypt: encrypt\n      };\n    }\n    /**\n     * If config.enabled is true, a Circuit relay will be added to the\n     * available Switch transports.\n     *\n     * @param {any} config\n     * @returns {void}\n     */\n\n  }, {\n    key: \"enableCircuitRelay\",\n    value: function enableCircuitRelay(config) {\n      config = config || {};\n\n      if (config.enabled) {\n        if (!config.hop) {\n          Object.assign(config, {\n            hop: {\n              enabled: false,\n              active: false\n            }\n          });\n        }\n\n        this.switch.transport.add(Circuit.tag, new Circuit(this.switch, config));\n      }\n    }\n    /**\n     * Sets identify to true on the Switch and performs handshakes\n     * for libp2p-identify leveraging the Switch's muxer.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"reuse\",\n    value: function reuse() {\n      var _this3 = this;\n\n      this.switch.identify = true;\n      this.switch.handle(identify.multicodec, function (protocol, conn) {\n        identify.listener(conn, _this3.switch._peerInfo);\n      });\n    }\n  }]);\n\n  return ConnectionManager;\n}();\n\nmodule.exports = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}